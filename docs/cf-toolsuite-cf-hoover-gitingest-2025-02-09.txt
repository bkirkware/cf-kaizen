Directory structure:
└── cf-toolsuite-cf-hoover/
    ├── src/
    │   ├── main/
    │   │   └── java/
    │   │       └── org/
    │   │           └── cftoolsuite/
    │   │               └── cfapp/
    │   │                   ├── AppInit.java
    │   │                   ├── client/
    │   │                   │   ├── DemographicsClient.java
    │   │                   │   ├── OrganizationsClient.java
    │   │                   │   ├── SnapshotClient.java
    │   │                   │   ├── SpaceUsersClient.java
    │   │                   │   ├── SpacesClient.java
    │   │                   │   ├── SpringApplicationClient.java
    │   │                   │   ├── TimeKeeperClient.java
    │   │                   │   └── UsageClient.java
    │   │                   ├── config/
    │   │                   │   ├── HooverSettings.java
    │   │                   │   └── WebClientConfig.java
    │   │                   ├── controller/
    │   │                   │   ├── DemographicsController.java
    │   │                   │   ├── OrganizationsController.java
    │   │                   │   ├── SnapshotController.java
    │   │                   │   ├── SpaceUsersController.java
    │   │                   │   ├── SpacesController.java
    │   │                   │   ├── SpringApplicationController.java
    │   │                   │   ├── TimeKeeperController.java
    │   │                   │   └── UsageController.java
    │   │                   ├── domain/
    │   │                   │   ├── AppDetail.java
    │   │                   │   ├── AppRelationship.java
    │   │                   │   ├── ApplicationCounts.java
    │   │                   │   ├── Demographic.java
    │   │                   │   ├── Demographics.java
    │   │                   │   ├── JavaAppDetail.java
    │   │                   │   ├── Organization.java
    │   │                   │   ├── ServiceInstanceCounts.java
    │   │                   │   ├── ServiceInstanceDetail.java
    │   │                   │   ├── SnapshotDetail.java
    │   │                   │   ├── SnapshotSummary.java
    │   │                   │   ├── Space.java
    │   │                   │   ├── SpaceUsers.java
    │   │                   │   ├── TimeKeeper.java
    │   │                   │   ├── TimeKeepers.java
    │   │                   │   └── accounting/
    │   │                   │       ├── application/
    │   │                   │       │   ├── AppUsageMonthly.java
    │   │                   │       │   ├── AppUsageReport.java
    │   │                   │       │   └── AppUsageYearly.java
    │   │                   │       ├── service/
    │   │                   │       │   ├── ServicePlanUsageMonthly.java
    │   │                   │       │   ├── ServicePlanUsageYearly.java
    │   │                   │       │   ├── ServiceUsageMonthly.java
    │   │                   │       │   ├── ServiceUsageMonthlyAggregate.java
    │   │                   │       │   ├── ServiceUsageReport.java
    │   │                   │       │   └── ServiceUsageYearlyAggregate.java
    │   │                   │       └── task/
    │   │                   │           ├── TaskUsageMonthly.java
    │   │                   │           ├── TaskUsageReport.java
    │   │                   │           └── TaskUsageYearly.java
    │   │                   ├── report/
    │   │                   │   ├── AppDetailCsvReport.java
    │   │                   │   ├── AppRelationshipCsvReport.java
    │   │                   │   └── ServiceInstanceDetailCsvReport.java
    │   │                   └── task/
    │   │                       ├── AppDetailRetrievedEvent.java
    │   │                       ├── AppRelationshipRetrievedEvent.java
    │   │                       └── ServiceInstanceDetailRetrievedEvent.java
    │   └── test/
    │       └── java/
    │           └── org/
    │               └── cftoolsuite/
    │                   └── cfapp/
    │                       └── CfHooverApplicationTests.java
    └── .mvn/
        └── wrapper/
            └── MavenWrapperDownloader.java

================================================
File: src/main/java/org/cftoolsuite/cfapp/AppInit.java
================================================
package org.cftoolsuite.cfapp;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.actuate.autoconfigure.security.reactive.EndpointRequest;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.boot.autoconfigure.security.reactive.PathRequest;
import org.springframework.boot.context.properties.ConfigurationPropertiesScan;
import org.springframework.context.annotation.Bean;
import org.springframework.security.config.web.server.ServerHttpSecurity;
import org.springframework.security.web.server.SecurityWebFilterChain;

@SpringBootApplication
@ConfigurationPropertiesScan
public class AppInit {

	public static void main(String[] args) {
		SpringApplication.run(AppInit.class, args);
	}

	@Bean
	public SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {
		return http
				.authorizeExchange()
					.matchers(
						PathRequest.toStaticResources().atCommonLocations(),
						EndpointRequest.toAnyEndpoint())
						.permitAll()
					.pathMatchers("/accounting/**","/snapshot/**", "/space-users", "/users/**", "/collect")
						.permitAll()
					.and().build();
	}
}

================================================
File: src/main/java/org/cftoolsuite/cfapp/client/DemographicsClient.java
================================================
package org.cftoolsuite.cfapp.client;

import java.util.Map;
import java.util.stream.Collectors;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.web.reactive.function.client.WebClient;
import org.springframework.web.reactive.function.client.WebClientResponseException;

import org.cftoolsuite.cfapp.config.HooverSettings;
import org.cftoolsuite.cfapp.domain.Demographic;
import org.cftoolsuite.cfapp.domain.Demographics;
import lombok.extern.slf4j.Slf4j;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

@Slf4j
@Service
public class DemographicsClient {

    private final SnapshotClient snapshotClient;
	private final WebClient client;
    private final HooverSettings settings;

    @Autowired
    public DemographicsClient(
        SnapshotClient snapshotClient,
        WebClient client,
        HooverSettings settings) {
        this.snapshotClient = snapshotClient;
        this.client = client;
        this.settings = settings;
	}

    // We're going to get raw counts from each cf-butler instance registered w/ cf-hoover
    // User and service accounts represent a special case, we collect and merge sets before counting
	public Mono<Demographics> aggregateDemographics() {
        Mono<Long> serviceAccounts = snapshotClient.assembleServiceAccounts().flatMapMany(sa -> Flux.fromIterable(sa)).count();
        Mono<Long> userAccounts = snapshotClient.assembleUserAccounts().flatMapMany(sa -> Flux.fromIterable(sa)).count();
        Flux<Map.Entry<String, String>> butlers = Flux.fromIterable(settings.getButlers().entrySet());
        return
			butlers
				.flatMap(b -> obtainDemographics(b.getKey(), b.getValue()))
				.collect(Collectors.toSet())
                .map(dl -> Demographics
                            .builder()
                                .demographics(dl)
                                .foundations(settings.getButlers().keySet().size()))
                .flatMap(b -> serviceAccounts.map(c -> b.serviceAccounts(c)))
                .flatMap(b -> userAccounts.map(c -> b.userAccounts(c).build()));
    }

    protected Mono<Demographic> obtainDemographics(String foundation, String baseUrl) {
        String uri = baseUrl + "/snapshot/demographics";
        return client
                .get()
                    .uri(uri)
                    .retrieve()
                    .bodyToMono(Demographic.class)
                    .timeout(settings.getTimeout(), Mono.just(Demographic.builder().build()))
                    .onErrorResume(
                        WebClientResponseException.class,
                        e -> {
                            log.warn(String.format("Could not obtain Demographic from %s", uri), e);
                            return Mono.just(Demographic.builder().build());
                        }
                    )
                    .map(d -> Demographic
                                    .builder()
                                        .foundation(foundation)
                                        .organizations(d.getOrganizations())
                                        .spaces(d.getSpaces())
                                        .userAccounts(d.getUserAccounts())
                                        .serviceAccounts(d.getServiceAccounts())
                                        .build());
    }

}

================================================
File: src/main/java/org/cftoolsuite/cfapp/client/OrganizationsClient.java
================================================
package org.cftoolsuite.cfapp.client;

import java.util.List;
import java.util.Map;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.web.reactive.function.client.WebClient;
import org.springframework.web.reactive.function.client.WebClientResponseException;

import org.cftoolsuite.cfapp.config.HooverSettings;
import org.cftoolsuite.cfapp.domain.Organization;
import lombok.extern.slf4j.Slf4j;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

@Slf4j
@Service
public class OrganizationsClient {

    private final WebClient client;
    private final HooverSettings settings;

    @Autowired
    public OrganizationsClient(
        WebClient client,
        HooverSettings settings) {
        this.client = client;
        this.settings = settings;
    }

    public Mono<List<Organization>> assembleOrganizations() {
        Flux<Map.Entry<String, String>> butlers = Flux.fromIterable(settings.getButlers().entrySet());
        Flux<Organization> organizations =
            butlers.flatMap(b -> obtainOrganizations(b.getValue())
                                    .flatMapMany(lo -> Flux.fromIterable(lo))
                                    .map(o -> Organization.from(o).foundation(b.getKey()).build()));
        return organizations.collectList();
    }

    protected Mono<List<Organization>> obtainOrganizations(String baseUrl) {
        String uri = baseUrl + "/snapshot/organizations";
        return client
                .get()
                    .uri(uri)
                    .retrieve()
                    .toEntityList(Organization.class)
                    .map(response -> response.getBody())
                    .timeout(settings.getTimeout(), Mono.empty())
                    .onErrorResume(
                        WebClientResponseException.class,
                        e -> {
                            log.warn(String.format("Could not obtain organizations from %s", uri), e);
                            return Mono.empty();
                        }
                    );
    }

}

================================================
File: src/main/java/org/cftoolsuite/cfapp/client/SnapshotClient.java
================================================
package org.cftoolsuite.cfapp.client;

import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeSet;
import java.util.stream.Collectors;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.web.reactive.function.client.WebClient;
import org.springframework.web.reactive.function.client.WebClientResponseException;

import org.cftoolsuite.cfapp.config.HooverSettings;
import org.cftoolsuite.cfapp.domain.AppDetail;
import org.cftoolsuite.cfapp.domain.AppRelationship;
import org.cftoolsuite.cfapp.domain.ApplicationCounts;
import org.cftoolsuite.cfapp.domain.ServiceInstanceCounts;
import org.cftoolsuite.cfapp.domain.ServiceInstanceDetail;
import org.cftoolsuite.cfapp.domain.SnapshotDetail;
import org.cftoolsuite.cfapp.domain.SnapshotSummary;
import org.cftoolsuite.cfapp.report.AppDetailCsvReport;
import org.cftoolsuite.cfapp.report.ServiceInstanceDetailCsvReport;
import org.cftoolsuite.cfapp.task.AppDetailRetrievedEvent;
import org.cftoolsuite.cfapp.task.ServiceInstanceDetailRetrievedEvent;
import lombok.extern.slf4j.Slf4j;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

@Slf4j
@Service
public class SnapshotClient {

    private final WebClient client;
    private final HooverSettings settings;

    @Autowired
    public SnapshotClient(
        WebClient client,
        HooverSettings settings) {
        this.client = client;
        this.settings = settings;
    }

    public Mono<String> assembleCsvAIReport() {
        return assembleApplicationDetail()
                .map(r -> new AppDetailRetrievedEvent(this).detail(r))
                .map(event -> new AppDetailCsvReport().generateDetail(event));
    }

    public Mono<String> assembleCsvSIReport() {
        return assembleServiceInstanceDetail()
                .map(r -> new ServiceInstanceDetailRetrievedEvent(this).detail(r))
                .map(event -> new ServiceInstanceDetailCsvReport().generateDetail(event));
    }

    public Mono<List<AppDetail>> assembleApplicationDetail() {
        Flux<Map.Entry<String, String>> butlers = Flux.fromIterable(settings.getButlers().entrySet());
        Flux<AppDetail> detail =
            butlers.flatMap(b -> obtainSnapshotDetail(b.getValue())
                                    .flatMapMany(sd -> Flux.fromIterable(sd.getApplications()))
                                    .map(ad -> AppDetail.from(ad).foundation(b.getKey()).build()));
        return detail.collectList();
    }

    public Mono<List<ServiceInstanceDetail>> assembleServiceInstanceDetail() {
        Flux<Map.Entry<String, String>> butlers = Flux.fromIterable(settings.getButlers().entrySet());
        Flux<ServiceInstanceDetail> detail =
            butlers.flatMap(b -> obtainSnapshotDetail(b.getValue())
                                    .flatMapMany(sd -> Flux.fromIterable(sd.getServiceInstances()))
                                    .map(ad -> ServiceInstanceDetail.from(ad).foundation(b.getKey()).build()));
        return detail.collectList();
    }

    public Mono<List<AppRelationship>> assembleApplicationRelationships() {
        Flux<Map.Entry<String, String>> butlers = Flux.fromIterable(settings.getButlers().entrySet());
        Flux<AppRelationship> relations =
            butlers.flatMap(b -> obtainSnapshotDetail(b.getValue())
                                    .flatMapMany(sd -> Flux.fromIterable(sd.getApplicationRelationships()))
                                    .map(ad -> AppRelationship.from(ad).foundation(b.getKey()).build()));
        return relations.collectList();
    }

    protected Mono<SnapshotDetail> obtainSnapshotDetail(String baseUrl) {
        String uri = baseUrl + "/snapshot/detail";
        return client
                .get()
                    .uri(uri)
                    .retrieve()
                    .bodyToMono(SnapshotDetail.class)
                    .timeout(settings.getTimeout(), Mono.just(SnapshotDetail.builder().build()))
                    .onErrorResume(
                        WebClientResponseException.class,
                        e -> {
                            log.warn(String.format("Could not obtain SnapshotDetail from %s", uri), e);
                            return Mono.just(SnapshotDetail.builder().build());
                        }
                    );
    }

    protected Mono<SnapshotSummary> obtainSnapshotSummary(String baseUrl) {
        String uri = baseUrl + "/snapshot/summary";
        return client
                .get()
                    .uri(uri)
                    .retrieve()
                    .bodyToMono(SnapshotSummary.class)
                    .timeout(settings.getTimeout(), Mono.just(SnapshotSummary.builder().build()))
                    .onErrorResume(
                        WebClientResponseException.class,
                        e -> {
                            log.warn(String.format("Could not obtain SnapshotSummary from %s", uri), e);
                            return Mono.just(SnapshotSummary.builder().build());
                        }
                    );
    }

    public Mono<SnapshotDetail> assembleSnapshotDetail() {
        return assembleApplicationDetail()
                        .map(ad -> SnapshotDetail.builder().applications(ad))
                        .flatMap(b -> assembleServiceInstanceDetail()
                                        .map(sid -> b.serviceInstances(sid)))
                        .flatMap(b -> assembleApplicationRelationships()
                                        .map(ar -> b.applicationRelationships(ar)))
                        .flatMap(b -> assembleUserAccounts()
                                        .map(ua -> b.userAccounts(ua)))
                        .flatMap(b -> assembleServiceAccounts()
                                            .map(sa -> b.serviceAccounts(sa).build()));
    }

    public Mono<SnapshotSummary> assembleSnapshotSummary() {
        return assembleApplicationCounts()
                .map(ac -> SnapshotSummary.builder().applicationCounts(ac))
                .flatMap(b -> assembleServiceInstanceCounts().map(sic -> b.serviceInstanceCounts(sic).build()));
    }

    public Mono<Set<String>> assembleUserAccounts() {
        Flux<Map.Entry<String, String>> butlers = Flux.fromIterable(settings.getButlers().entrySet());
        Flux<String> accounts =
            butlers.flatMap(b -> obtainSnapshotDetail(b.getValue())
                                    .flatMapMany(sd -> Flux.fromIterable(sd.getUserAccounts())));
        return accounts.collect(Collectors.toCollection(TreeSet::new));
    }

    public Mono<Set<String>> assembleServiceAccounts() {
        Flux<Map.Entry<String, String>> butlers = Flux.fromIterable(settings.getButlers().entrySet());
        Flux<String> accounts =
            butlers.flatMap(b -> obtainSnapshotDetail(b.getValue())
                                    .flatMapMany(sd -> Flux.fromIterable(sd.getServiceAccounts())));
        return accounts.collect(Collectors.toCollection(TreeSet::new));
    }

    protected Mono<ApplicationCounts> assembleApplicationCounts() {
        Flux<Map.Entry<String, String>> butlers = Flux.fromIterable(settings.getButlers().entrySet());
        return butlers
                .flatMap(b -> obtainSnapshotSummary(b.getValue()))
                                .map(sd -> sd.getApplicationCounts())
                                .collectList()
                                .map(acl -> ApplicationCounts.aggregate(acl));
    }

    protected Mono<ServiceInstanceCounts> assembleServiceInstanceCounts() {
        Flux<Map.Entry<String, String>> butlers = Flux.fromIterable(settings.getButlers().entrySet());
        return butlers
                .flatMap(b -> obtainSnapshotSummary(b.getValue()))
                                .map(sd -> sd.getServiceInstanceCounts())
                                .collectList()
                                .map(acl -> ServiceInstanceCounts.aggregate(acl));
    }
}

================================================
File: src/main/java/org/cftoolsuite/cfapp/client/SpaceUsersClient.java
================================================
package org.cftoolsuite.cfapp.client;

import java.util.Map;
import java.util.Set;
import java.util.stream.Collectors;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.web.reactive.function.client.WebClient;
import org.springframework.web.reactive.function.client.WebClientResponseException;

import org.cftoolsuite.cfapp.config.HooverSettings;
import org.cftoolsuite.cfapp.domain.SpaceUsers;
import lombok.extern.slf4j.Slf4j;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

@Slf4j
@Service
public class SpaceUsersClient {

	private final WebClient client;
	private final HooverSettings settings;
	private final SnapshotClient snapshotClient;

    @Autowired
    public SpaceUsersClient(
        WebClient client,
		HooverSettings settings,
		SnapshotClient snapshotClient) {
        this.client = client;
		this.settings = settings;
		this.snapshotClient = snapshotClient;
	}

	public Flux<SpaceUsers> findAll() {
		Flux<Map.Entry<String, String>> butlers = Flux.fromIterable(settings.getButlers().entrySet());
		return
			butlers.flatMap(b -> obtainSpaceUsers(b.getValue())
									.map(su -> SpaceUsers.from(su).foundation(b.getKey()).build()));
	}

	protected Flux<SpaceUsers> obtainSpaceUsers(String baseUrl) {
        String uri = baseUrl + "/snapshot/spaces/users";
        return client
                .get()
                    .uri(uri)
                    .retrieve()
                    .bodyToFlux(SpaceUsers.class)
                    .timeout(settings.getTimeout(), Flux.just(SpaceUsers.builder().build()))
                    .onErrorResume(
                        WebClientResponseException.class,
                        e -> {
                            log.warn(String.format("Could not obtain SpaceUsers from %s", uri), e);
                            return Flux.just(SpaceUsers.builder().build());
                        }
                    );
    }

	public Mono<Set<String>> obtainAccountNames() {
		return snapshotClient.assembleSnapshotDetail()
				.flatMapMany(
					sd ->
						Flux.concat(
								Flux.fromIterable(sd.getServiceAccounts()),
								Flux.fromIterable(sd.getUserAccounts())
						)
				)
				.collect(Collectors.toSet());
	}

	public Mono<Long> totalAccounts() {
		return obtainAccountNames()
				.flatMapMany(s -> Flux.fromIterable(s))
				.count();
	}

}

================================================
File: src/main/java/org/cftoolsuite/cfapp/client/SpacesClient.java
================================================
package org.cftoolsuite.cfapp.client;

import java.util.List;
import java.util.Map;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.web.reactive.function.client.WebClient;
import org.springframework.web.reactive.function.client.WebClientResponseException;

import org.cftoolsuite.cfapp.config.HooverSettings;
import org.cftoolsuite.cfapp.domain.Space;
import lombok.extern.slf4j.Slf4j;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

@Slf4j
@Service
public class SpacesClient {

    private final WebClient client;
    private final HooverSettings settings;

    @Autowired
    public SpacesClient(
        WebClient client,
        HooverSettings settings) {
        this.client = client;
        this.settings = settings;
    }

    public Mono<List<Space>> assembleSpaces() {
        Flux<Map.Entry<String, String>> butlers = Flux.fromIterable(settings.getButlers().entrySet());
        Flux<Space> spaces =
            butlers.flatMap(b -> obtainSpaces(b.getValue())
                                    .flatMapMany(ls -> Flux.fromIterable(ls))
                                    .map(s -> Space.from(s).foundation(b.getKey()).build()));
        return spaces.collectList();
    }

    protected Mono<List<Space>> obtainSpaces(String baseUrl) {
        String uri = baseUrl + "/snapshot/spaces";
        return client
                .get()
                    .uri(uri)
                    .retrieve()
                    .toEntityList(Space.class)
                    .map(response -> response.getBody())
                    .timeout(settings.getTimeout(), Mono.empty())
                    .onErrorResume(
                        WebClientResponseException.class,
                        e -> {
                            log.warn(String.format("Could not obtain spaces from %s", uri), e);
                            return Mono.empty();
                        }
                    );
    }

}

================================================
File: src/main/java/org/cftoolsuite/cfapp/client/SpringApplicationClient.java
================================================
package org.cftoolsuite.cfapp.client;

import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.core.ParameterizedTypeReference;
import org.springframework.stereotype.Service;
import org.springframework.web.reactive.function.client.WebClient;
import org.springframework.web.reactive.function.client.WebClientResponseException;

import org.cftoolsuite.cfapp.config.HooverSettings;
import org.cftoolsuite.cfapp.domain.JavaAppDetail;
import lombok.extern.slf4j.Slf4j;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

@Slf4j
@Service
public class SpringApplicationClient {

    private final WebClient client;
    private final HooverSettings settings;

    @Autowired
    public SpringApplicationClient(
        WebClient client,
        HooverSettings settings) {
        this.client = client;
        this.settings = settings;
    }


    public Mono<List<JavaAppDetail>> assembleSpringApplicationDetail() {
        Flux<Map.Entry<String, String>> butlers = Flux.fromIterable(settings.getButlers().entrySet());
        return
            butlers
                .flatMap(b -> obtainSpringApplicationDetail(b.getValue())
                .map(ad -> JavaAppDetail.from(ad).foundation(b.getKey()).build()))
                .collectList();
    }

    protected Flux<JavaAppDetail> obtainSpringApplicationDetail(String baseUrl) {
        String uri = baseUrl + "/snapshot/detail/ai/spring";
        return client
                .get()
                    .uri(uri)
                    .retrieve()
                    .bodyToFlux(JavaAppDetail.class)
                    .timeout(settings.getTimeout(), Mono.just(JavaAppDetail.builder().build()))
                    .onErrorResume(
                        WebClientResponseException.class,
                        e -> {
                            log.warn(String.format("Could not obtain Spring application details from %s", uri), e);
                            return Mono.just(JavaAppDetail.builder().build());
                        }
                    );
    }

    public Mono<Map<String, Integer>> calculateSpringApplicationDependencyFrequency() {
        Flux<Map.Entry<String, String>> butlers = Flux.fromIterable(settings.getButlers().entrySet());
        return
            butlers
                .flatMap(b -> obtainSpringApplicationDependencyFrequency(b.getValue()))
                .flatMapIterable(Map::entrySet)
                .collect(Collectors.toMap(
                    Map.Entry::getKey,
                    Map.Entry::getValue,
                    Integer::sum
                ));
    }

    protected Mono<Map<String, Integer>> obtainSpringApplicationDependencyFrequency(String baseUrl) {
        String uri = baseUrl + "/snapshot/summary/ai/spring";
        return client
                .get()
                    .uri(uri)
                    .retrieve()
                    .bodyToMono(new ParameterizedTypeReference<Map<String, Integer>>() {})
                    .timeout(settings.getTimeout(), Mono.just(Collections.emptyMap()))
                    .onErrorResume(
                        WebClientResponseException.class,
                        e -> {
                            log.warn(String.format("Could not obtain Spring dependency frequency from %s", uri), e);
                            return Mono.just(Collections.emptyMap());
                        }
                    );
    }

}

================================================
File: src/main/java/org/cftoolsuite/cfapp/client/TimeKeeperClient.java
================================================
package org.cftoolsuite.cfapp.client;

import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.Map;
import java.util.Set;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.web.reactive.function.client.WebClient;
import org.springframework.web.reactive.function.client.WebClientResponseException;

import org.cftoolsuite.cfapp.config.HooverSettings;
import org.cftoolsuite.cfapp.domain.TimeKeeper;
import org.cftoolsuite.cfapp.domain.TimeKeepers;
import lombok.extern.slf4j.Slf4j;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

@Slf4j
@Service
public class TimeKeeperClient {

    private final WebClient client;
    private final HooverSettings settings;

    @Autowired
    public TimeKeeperClient(
        WebClient client,
        HooverSettings settings) {
        this.client = client;
        this.settings = settings;
    }

    public Mono<Set<TimeKeeper>> assembleDateTimeCollection() {
        Flux<Map.Entry<String, String>> butlers = Flux.fromIterable(settings.getButlers().entrySet());
        Flux<TimeKeeper> result =
            butlers.flatMap(b -> obtainDateTimeCollected(b.getValue())
                                    .map(dtc -> TimeKeeper.builder().foundation(b.getKey()).collectionDateTime(dtc).build()));
        return result.collectList().map(l -> Set.copyOf(l));
    }

    protected Mono<LocalDateTime> obtainDateTimeCollected(String baseUrl) {
        String uri = baseUrl + "/collect";
        return client
                .get()
                    .uri(uri)
                    .retrieve()
                    .bodyToMono(String.class)
                    .map(s -> LocalDateTime.parse(s, DateTimeFormatter.ISO_LOCAL_DATE_TIME))
                    .timeout(settings.getTimeout(), Mono.empty())
                    .onErrorResume(
                        WebClientResponseException.class,
                        e -> {
                            log.warn(String.format("Could not obtain X-DateTime-Collected from %s", uri), e);
                            return Mono.empty();
                        }
                    );
    }

    public Mono<TimeKeepers> assembleTimeKeepers() {
        return assembleDateTimeCollection()
                .map(tk -> TimeKeepers.builder().timeKeepers(tk).build());
    }

}

================================================
File: src/main/java/org/cftoolsuite/cfapp/client/UsageClient.java
================================================
package org.cftoolsuite.cfapp.client;

import java.util.Map;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.web.reactive.function.client.WebClient;
import org.springframework.web.reactive.function.client.WebClientResponseException;

import org.cftoolsuite.cfapp.config.HooverSettings;
import org.cftoolsuite.cfapp.domain.accounting.application.AppUsageReport;
import org.cftoolsuite.cfapp.domain.accounting.service.ServiceUsageReport;
import org.cftoolsuite.cfapp.domain.accounting.task.TaskUsageReport;
import lombok.extern.slf4j.Slf4j;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

// @see https://docs.pivotal.io/pivotalcf/2-4/opsguide/accounting-report.html

@Slf4j
@Service
public class UsageClient {

    private final WebClient client;
    private final HooverSettings settings;

    @Autowired
    public UsageClient(
        WebClient client,
        HooverSettings settings) {
        this.client = client;
        this.settings = settings;
    }

    protected Mono<TaskUsageReport> getTaskReport(String butlerRoute) {
        String uri = butlerRoute + "/accounting/tasks";
        return client
                .get()
                    .uri(uri)
                        .retrieve()
                            .bodyToMono(TaskUsageReport.class)
                            .timeout(settings.getTimeout(), Mono.just(TaskUsageReport.builder().build()))
                            .onErrorResume(
                                WebClientResponseException.class,
                                e -> {
                                    log.warn(String.format("Could not obtain TaskUsageReport from %s", uri), e);
                                    return Mono.just(TaskUsageReport.builder().build());
                                }
                            );
    }

    protected Mono<AppUsageReport> getApplicationReport(String butlerRoute) {
        String uri = butlerRoute + "/accounting/applications";
        return client
                .get()
                    .uri(uri)
                        .retrieve()
                            .bodyToMono(AppUsageReport.class)
                            .timeout(settings.getTimeout(), Mono.just(AppUsageReport.builder().build()))
                            .onErrorResume(
                                WebClientResponseException.class,
                                e -> {
                                    log.warn(String.format("Could not obtain AppUsageReport from %s", uri), e);
                                    return Mono.just(AppUsageReport.builder().build());
                                }
                            );
    }

    protected Mono<ServiceUsageReport> getServiceReport(String butlerRoute) {
        String uri = butlerRoute + "/accounting/services";
        return client
                .get()
                    .uri(uri)
                        .retrieve()
                            .bodyToMono(ServiceUsageReport.class)
                            .timeout(settings.getTimeout(), Mono.just(ServiceUsageReport.builder().build()))
                            .onErrorResume(
                                WebClientResponseException.class,
                                e -> {
                                    log.warn(String.format("Could not obtain ServiceUsageReport from %s", uri), e);
                                    return Mono.just(ServiceUsageReport.builder().build());
                                }
                            );
    }

    public Mono<TaskUsageReport> getTaskReport() {
        Flux<Map.Entry<String, String>> butlers = Flux.fromIterable(settings.getButlers().entrySet());
        return butlers.flatMap(b -> getTaskReport(b.getValue()))
                                        .collectList()
                                        .map(l -> TaskUsageReport.aggregate(l));
    }

    public Mono<AppUsageReport> getApplicationReport() {
        Flux<Map.Entry<String, String>> butlers = Flux.fromIterable(settings.getButlers().entrySet());
        return butlers.flatMap(b -> getApplicationReport(b.getValue()))
                                        .collectList()
                                        .map(l -> AppUsageReport.aggregate(l));
    }

    public Mono<ServiceUsageReport> getServiceReport() {
        Flux<Map.Entry<String, String>> butlers = Flux.fromIterable(settings.getButlers().entrySet());
        return butlers.flatMap(b -> getServiceReport(b.getValue()))
                                        .collectList()
                                        .map(l -> ServiceUsageReport.aggregate(l));
    }
}

================================================
File: src/main/java/org/cftoolsuite/cfapp/config/HooverSettings.java
================================================
package org.cftoolsuite.cfapp.config;

import java.time.Duration;
import java.util.HashMap;
import java.util.Map;

import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.cloud.context.config.annotation.RefreshScope;

import lombok.Data;

@Data
@RefreshScope
@ConfigurationProperties(prefix = "cf")
public class HooverSettings {

	private Map<String, String> butlers = new HashMap<>();
	private boolean sslValidationSkipped;
	private Duration timeout = Duration.ofMinutes(2);

	public void setButlers(Map<String, String> butlers) {
		butlers.replaceAll((k, v) -> butlerURL(v));
		this.butlers = butlers;
	}

	private String butlerURL(String url) {
		if (!url.startsWith("http")) {
			url = "https://" + url;
		}
		return url;
	}
}


================================================
File: src/main/java/org/cftoolsuite/cfapp/config/WebClientConfig.java
================================================
package org.cftoolsuite.cfapp.config;

import javax.net.ssl.SSLException;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
import org.springframework.cloud.context.config.annotation.RefreshScope;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.http.client.reactive.ReactorClientHttpConnector;
import org.springframework.web.reactive.function.client.ExchangeStrategies;
import org.springframework.web.reactive.function.client.WebClient;

import io.netty.handler.ssl.SslContext;
import io.netty.handler.ssl.SslContextBuilder;
import io.netty.handler.ssl.util.InsecureTrustManagerFactory;
import reactor.netty.http.client.HttpClient;

@RefreshScope
@Configuration
public class WebClientConfig {

    // @see https://stackoverflow.com/questions/45418523/spring-5-webclient-using-ssl/53147631#53147631

    @Bean
    @ConditionalOnProperty(name = "cf.sslValidationSkipped", havingValue="true")
    public WebClient insecureWebClient(
        WebClient.Builder builder,
        @Value("${spring.codec.max-in-memory-size}") Integer maxInMemorySize) throws SSLException {
        SslContext context =
            SslContextBuilder
                .forClient()
                .trustManager(InsecureTrustManagerFactory.INSTANCE)
                .build();
        HttpClient httpClient =
            HttpClient
                .create()
                .secure(t -> t.sslContext(context));
        return
            builder
                .exchangeStrategies(
                    ExchangeStrategies
                        .builder()
                        .codecs(
                            configurer ->
                                configurer
                                    .defaultCodecs()
                                    .maxInMemorySize(maxInMemorySize)
                        )
                        .build()
                )
                .clientConnector(new ReactorClientHttpConnector(httpClient))
                .build();
    }

    @Bean
    @ConditionalOnProperty(name = "cf.sslValidationSkipped", havingValue="false", matchIfMissing=true)
    public WebClient secureWebClient(
        WebClient.Builder builder,
        @Value("${spring.codec.max-in-memory-size}") Integer maxInMemorySize) {
        return
            builder
                .exchangeStrategies(
                    ExchangeStrategies
                        .builder()
                        .codecs(
                            configurer ->
                                configurer
                                    .defaultCodecs()
                                    .maxInMemorySize(maxInMemorySize)
                        )
                        .build()
                )
                .build();
    }
}


================================================
File: src/main/java/org/cftoolsuite/cfapp/controller/DemographicsController.java
================================================
package org.cftoolsuite.cfapp.controller;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

import org.cftoolsuite.cfapp.domain.Demographics;
import org.cftoolsuite.cfapp.client.DemographicsClient;
import reactor.core.publisher.Mono;

@RestController
public class DemographicsController {

    private final DemographicsClient client;

    @Autowired
    public DemographicsController(DemographicsClient client) {
        this.client = client;
    }

    @GetMapping("/snapshot/demographics")
    public Mono<ResponseEntity<Demographics>> aggregateDemographics() {
        return client.aggregateDemographics()
                .map(d -> ResponseEntity.ok(d))
                .defaultIfEmpty(ResponseEntity.notFound().build());
    }
}

================================================
File: src/main/java/org/cftoolsuite/cfapp/controller/OrganizationsController.java
================================================
package org.cftoolsuite.cfapp.controller;

import java.util.List;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

import org.cftoolsuite.cfapp.client.OrganizationsClient;
import org.cftoolsuite.cfapp.domain.Organization;
import reactor.core.publisher.Mono;

@RestController
public class OrganizationsController {

    private final OrganizationsClient client;

    @Autowired
    public OrganizationsController(OrganizationsClient client) {
        this.client = client;
    }

    @GetMapping("/snapshot/organizations")
    public Mono<ResponseEntity<List<Organization>>> assembleOrganizations() {
        return client.assembleOrganizations()
                .map(d -> ResponseEntity.ok(d))
                .defaultIfEmpty(ResponseEntity.notFound().build());
    }
}

================================================
File: src/main/java/org/cftoolsuite/cfapp/controller/SnapshotController.java
================================================
package org.cftoolsuite.cfapp.controller;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

import org.cftoolsuite.cfapp.domain.SnapshotDetail;
import org.cftoolsuite.cfapp.domain.SnapshotSummary;
import org.cftoolsuite.cfapp.client.SnapshotClient;
import reactor.core.publisher.Mono;

@RestController
public class SnapshotController {

	private final SnapshotClient client;

	@Autowired
	public SnapshotController(
		SnapshotClient client) {
		this.client = client;
	}

	@GetMapping("/snapshot/detail")
	public Mono<ResponseEntity<SnapshotDetail>> getDetail() {
		return client
					.assembleSnapshotDetail()
							.map(detail -> ResponseEntity.ok(detail))
							.defaultIfEmpty(new ResponseEntity<>(HttpStatus.NOT_FOUND));
	}

	@GetMapping("/snapshot/summary")
	public Mono<ResponseEntity<SnapshotSummary>> getSummary() {
		return client
					.assembleSnapshotSummary()
					.map(summary -> ResponseEntity.ok(summary))
					.defaultIfEmpty(new ResponseEntity<>(HttpStatus.NOT_FOUND));
	}

	@GetMapping(value = { "/snapshot/detail/si" }, produces = MediaType.TEXT_PLAIN_VALUE )
	public Mono<ResponseEntity<String>> getServiceInstanceCsvReport() {
		return client
					.assembleCsvSIReport()
					.map(r -> ResponseEntity.ok(r));
	}

	@GetMapping(value = { "/snapshot/detail/ai" }, produces = MediaType.TEXT_PLAIN_VALUE )
	public Mono<ResponseEntity<String>> getApplicationInstanceCsvReport() {
		return client
					.assembleCsvAIReport()
					.map(r -> ResponseEntity.ok(r));
	}

}


================================================
File: src/main/java/org/cftoolsuite/cfapp/controller/SpaceUsersController.java
================================================
package org.cftoolsuite.cfapp.controller;

import java.util.List;
import java.util.Set;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RestController;

import org.cftoolsuite.cfapp.domain.SpaceUsers;
import org.cftoolsuite.cfapp.client.SpaceUsersClient;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

@RestController
public class SpaceUsersController {

	private final SpaceUsersClient client;

	@Autowired
	public SpaceUsersController(
		SpaceUsersClient client) {
		this.client = client;
	}

	@GetMapping("/snapshot/spaces/users")
	public Mono<ResponseEntity<List<SpaceUsers>>> getAllSpaceUsers() {
		return client
					.findAll()
						.collectList()
							.map(users -> ResponseEntity.ok(users))
							.defaultIfEmpty(new ResponseEntity<>(HttpStatus.NOT_FOUND));
	}

	@GetMapping("/snapshot/{foundation}/{organization}/{space}/users")
	public Mono<ResponseEntity<SpaceUsers>> getUsersInOrganizationAndSpace(
		@PathVariable("foundation") String foundation,
		@PathVariable("organization") String organization,
		@PathVariable("space") String space) {
		return getAllSpaceUsers()
					.flatMapMany(r -> Flux.fromIterable(r.getBody()))
					.filter(su ->
						su.getFoundation().equals(foundation) &&
						su.getOrganization().equals(organization) &&
						su.getSpace().equals(space))
					.singleOrEmpty()
					.map(users -> ResponseEntity.ok(users))
					.defaultIfEmpty(ResponseEntity.notFound().build());
	}

	@GetMapping("/snapshot/users/count")
	public Mono<ResponseEntity<Long>> totalAccounts() {
		return client
				.totalAccounts()
				.map(t -> ResponseEntity.ok(t))
				.defaultIfEmpty(ResponseEntity.notFound().build());

	}

	@GetMapping("/snapshot/users")
	public Mono<ResponseEntity<Set<String>>> getAllAccountNames() {
		return client
				.obtainAccountNames()
				.map(r -> ResponseEntity.ok(r))
				.defaultIfEmpty(ResponseEntity.notFound().build());
	}
}


================================================
File: src/main/java/org/cftoolsuite/cfapp/controller/SpacesController.java
================================================
package org.cftoolsuite.cfapp.controller;

import java.util.List;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

import org.cftoolsuite.cfapp.client.SpacesClient;
import org.cftoolsuite.cfapp.domain.Space;
import reactor.core.publisher.Mono;

@RestController
public class SpacesController {

    private final SpacesClient client;

    @Autowired
    public SpacesController(SpacesClient client) {
        this.client = client;
    }

    @GetMapping("/snapshot/spaces")
    public Mono<ResponseEntity<List<Space>>> assembleSpaces() {
        return client.assembleSpaces()
                .map(d -> ResponseEntity.ok(d))
                .defaultIfEmpty(ResponseEntity.notFound().build());
    }
}

================================================
File: src/main/java/org/cftoolsuite/cfapp/controller/SpringApplicationController.java
================================================
package org.cftoolsuite.cfapp.controller;

import java.util.List;
import java.util.Map;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

import org.cftoolsuite.cfapp.client.SpringApplicationClient;
import org.cftoolsuite.cfapp.domain.JavaAppDetail;
import reactor.core.publisher.Mono;

@RestController
public class SpringApplicationController {

    private final SpringApplicationClient client;

    @Autowired
    public SpringApplicationController(SpringApplicationClient client) {
        this.client = client;
    }

    @GetMapping("/snapshot/detail/ai/spring")
    public Mono<ResponseEntity<List<JavaAppDetail>>> assembleSpringApplicationDetail() {
        return client.assembleSpringApplicationDetail()
                .map(d -> ResponseEntity.ok(d))
                .defaultIfEmpty(ResponseEntity.notFound().build());
    }

    @GetMapping("/snapshot/summary/ai/spring")
    public Mono<ResponseEntity<Map<String, Integer>>> calculateSpringApplicationDependencyFrequency() {
        return client.calculateSpringApplicationDependencyFrequency()
                .map(d -> ResponseEntity.ok(d))
                .defaultIfEmpty(ResponseEntity.notFound().build());
    }
}

================================================
File: src/main/java/org/cftoolsuite/cfapp/controller/TimeKeeperController.java
================================================
package org.cftoolsuite.cfapp.controller;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

import org.cftoolsuite.cfapp.client.TimeKeeperClient;
import org.cftoolsuite.cfapp.domain.TimeKeepers;
import reactor.core.publisher.Mono;

@RestController
public class TimeKeeperController {

	private final TimeKeeperClient client;

	@Autowired
	public TimeKeeperController(
		TimeKeeperClient client) {
		this.client = client;
	}

	@GetMapping("/collect")
	public Mono<ResponseEntity<TimeKeepers>> getTimeKeepers() {
		return client
					.assembleTimeKeepers()
						.map(tk -> ResponseEntity.ok(tk))
						.defaultIfEmpty(new ResponseEntity<>(HttpStatus.NOT_FOUND));
	}

}


================================================
File: src/main/java/org/cftoolsuite/cfapp/controller/UsageController.java
================================================
package org.cftoolsuite.cfapp.controller;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

import org.cftoolsuite.cfapp.domain.accounting.application.AppUsageReport;
import org.cftoolsuite.cfapp.domain.accounting.service.ServiceUsageReport;
import org.cftoolsuite.cfapp.domain.accounting.task.TaskUsageReport;
import org.cftoolsuite.cfapp.client.UsageClient;
import reactor.core.publisher.Mono;

@RestController
public class UsageController {

    private final UsageClient client;

    @Autowired
    public UsageController(UsageClient client) {
        this.client = client;
    }

    @GetMapping(value = "/accounting/tasks")
    public Mono<ResponseEntity<TaskUsageReport>> getTaskReport() {
        return client
                .getTaskReport()
                .map(r -> ResponseEntity.ok(r))
                .defaultIfEmpty(ResponseEntity.notFound().build());
    }

    @GetMapping(value = "/accounting/applications")
    public Mono<ResponseEntity<AppUsageReport>> getApplicationReport() {
        return client
                .getApplicationReport()
                .map(r -> ResponseEntity.ok(r))
                .defaultIfEmpty(ResponseEntity.notFound().build());
    }

    @GetMapping(value = "/accounting/services")
    public Mono<ResponseEntity<ServiceUsageReport>> getServiceReport() {
        return client
                .getServiceReport()
                .map(r -> ResponseEntity.ok(r))
                .defaultIfEmpty(ResponseEntity.notFound().build());
    }

}

================================================
File: src/main/java/org/cftoolsuite/cfapp/domain/AppDetail.java
================================================
package org.cftoolsuite.cfapp.domain;

import java.time.LocalDateTime;
import java.util.Collections;
import java.util.ArrayList;
import java.util.List;

import org.apache.commons.lang3.StringUtils;

import lombok.AccessLevel;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Builder.Default;
import lombok.EqualsAndHashCode;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.ToString;

@Builder
@AllArgsConstructor(access=AccessLevel.PACKAGE)
@NoArgsConstructor(access=AccessLevel.PACKAGE)
@Getter
@EqualsAndHashCode
@ToString
public class AppDetail {

	private String foundation;
	private String organization;
	private String space;
	private String appId;
	private String appName;
	private String buildpack;
	private String buildpackVersion;
	private String image;
	private String stack;
	@Default
	private Integer runningInstances = 0;
	@Default
	private Integer totalInstances = 0;
	@Default
	private Long memoryUsed = 0L;
	@Default
	private Long memoryQuota = 0L;
	@Default
	private Long diskUsed = 0L;
	@Default
	private Long diskQuota = 0L;
	@Default
	private List<String> urls = new ArrayList<>();
	private LocalDateTime lastPushed;
	private String lastEvent;
	private String lastEventActor;
	private LocalDateTime lastEventTime;
	private String buildpackReleaseType;
    private LocalDateTime buildpackReleaseDate;
    private String buildpackLatestVersion;
    private String buildpackLatestUrl;
	private String requestedState;

	public String toCsv() {
        return String.join(",", wrap(getFoundation()), wrap(getOrganization()), wrap(getSpace()), wrap(getAppId()), wrap(getAppName()),
                wrap(getBuildpack()), wrap(getBuildpackVersion()), wrap(getImage()), wrap(getStack()), wrap(String.valueOf(getRunningInstances())),
                wrap(String.valueOf(getTotalInstances())), wrap(Double.toString(toGigabytes(getMemoryUsed()))), wrap(Double.toString(toGigabytes(getMemoryQuota()))),
                wrap(Double.toString(toGigabytes(getDiskUsed()))), wrap(Double.toString(toGigabytes(getDiskQuota()))),
                (wrap(String.join(",", getUrls() != null ? getUrls(): Collections.emptyList()))),
                wrap(getLastPushed() != null ? getLastPushed().toString() : ""), wrap(getLastEvent()),
                wrap(getLastEventActor()), wrap(getLastEventTime() != null ? getLastEventTime().toString() : ""),
                wrap(getRequestedState()),
                wrap(getBuildpackReleaseType()),
                wrap(getBuildpackReleaseDate() != null ? getBuildpackReleaseDate().toString() : ""),
                wrap(getBuildpackLatestVersion()),
                wrap(getBuildpackLatestUrl()));
    }

	private static String wrap(String value) {
		return value != null ? StringUtils.wrap(value, '"') : StringUtils.wrap("", '"');
	}

	private Double toGigabytes(Long input) {
		return Double.valueOf(input / Math.pow(1024, 3));
	}

	public static String headers() {
		return String.join(",", "foundation", "organization", "space", "application id", "application name", "buildpack", "buildpack version", "image",
                "stack", "running instances", "total instances", "memory used (in gb)", "memory quota (in gb)", "disk used (in gb)", "disk quota (in gb)", "urls", "last pushed", "last event",
                "last event actor", "last event time", "requested state",
                "latest buildpack release type", "latest buildpack release date", "latest buildpack version", "latest buildpack Url" );
	}

	public static AppDetailBuilder from(AppDetail detail) {
        return AppDetail
					.builder()
						.foundation(detail.getFoundation())
						.organization(detail.getOrganization())
						.space(detail.getSpace())
						.appId(detail.getAppId())
						.appName(detail.getAppName())
						.buildpack(detail.getBuildpack())
						.buildpackVersion(detail.getBuildpackVersion())
						.image(detail.getImage())
						.stack(detail.getStack())
						.runningInstances(detail.getRunningInstances())
						.totalInstances(detail.getTotalInstances())
						.memoryUsed(detail.getMemoryUsed())
						.memoryQuota(detail.getMemoryQuota())
						.diskUsed(detail.getDiskUsed())
						.diskQuota(detail.getDiskQuota())
						.urls(detail.getUrls())
						.lastPushed(detail.getLastPushed())
						.lastEvent(detail.getLastEvent())
						.lastEventActor(detail.getLastEventActor())
						.lastEventTime(detail.getLastEventTime())
						.requestedState(detail.getRequestedState())
						.buildpackReleaseType(detail.getBuildpackReleaseType())
						.buildpackReleaseDate(detail.getBuildpackReleaseDate())
						.buildpackLatestVersion(detail.getBuildpackLatestVersion())
						.buildpackLatestUrl(detail.getBuildpackLatestUrl());
	}
}


================================================
File: src/main/java/org/cftoolsuite/cfapp/domain/AppRelationship.java
================================================
package org.cftoolsuite.cfapp.domain;

import org.apache.commons.lang3.StringUtils;

import lombok.AccessLevel;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.EqualsAndHashCode;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.ToString;

@Builder
@AllArgsConstructor(access=AccessLevel.PACKAGE)
@NoArgsConstructor(access=AccessLevel.PACKAGE)
@Getter
@EqualsAndHashCode
@ToString
public class AppRelationship {

	private String foundation;
	private String organization;
	private String space;
	private String appId;
	private String appName;
	private String serviceInstanceId;
	private String serviceName;
	private String servicePlan;
	private String serviceType;

	public String toCsv() {
		return String.join(",", wrap(getFoundation()), wrap(getOrganization()), wrap(getSpace()), wrap(getAppId()), wrap(getAppName()),
				wrap(getServiceInstanceId()), wrap(getServiceName()), wrap(getServicePlan()), wrap(getServiceType()));
	}

	private static String wrap(String value) {
		return value != null ? StringUtils.wrap(value, '"') : StringUtils.wrap("", '"');
	}

	public static String headers() {
        return String.join(",", "foundation", "organization", "space", "application id",
                "application name", "service instance id", "service name", "service plan", "service type");
	}

	public static AppRelationshipBuilder from(AppRelationship rel) {
		return AppRelationship
				.builder()
					.foundation(rel.getFoundation())
					.organization(rel.getOrganization())
					.space(rel.getSpace())
					.appId(rel.getAppId())
					.appName(rel.getAppName())
					.serviceInstanceId(rel.getServiceInstanceId())
					.serviceName(rel.getServiceName())
					.servicePlan(rel.getServicePlan())
					.serviceType(rel.getServiceType());
	}

}


================================================
File: src/main/java/org/cftoolsuite/cfapp/domain/ApplicationCounts.java
================================================
package org.cftoolsuite.cfapp.domain;

import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;
import java.util.stream.Stream;

import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;

import lombok.AccessLevel;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.ToString;
import lombok.Builder.Default;

@Builder
@AllArgsConstructor(access=AccessLevel.PACKAGE)
@NoArgsConstructor(access=AccessLevel.PACKAGE)
@Getter
@ToString
@JsonPropertyOrder({ "by-buildpack", "by-stack", "by-dockerimage", "by-status",
"total-applications", "total-running-application-instances", "total-stopped-application-instances", "total-crashed-application-instances",
"total-application-instances", "total-memory-used-in-gb", "total-disk-used-in-gb", "velocity"})
public class ApplicationCounts {

    @Default
    @JsonProperty("by-buildpack")
    private Map<String, Long> byBuildpack = new HashMap<>();

    @Default
    @JsonProperty("by-stack")
    private Map<String, Long> byStack = new HashMap<>();

    @Default
    @JsonProperty("by-dockerimage")
    private Map<String, Long> byDockerImage = new HashMap<>();

    @Default
    @JsonProperty("by-status")
    private Map<String, Long> byStatus = new HashMap<>();

    @Default
    @JsonProperty("total-applications")
    private Long totalApplications = 0L;

    @Default
    @JsonProperty("total-running-application-instances")
    private Long totalRunningApplicationInstances = 0L;

    @Default
    @JsonProperty("total-stopped-application-instances")
    private Long totalStoppedApplicationInstances = 0L;

    @Default
    @JsonProperty("total-crashed-application-instances")
    private Long totalCrashedApplicationInstances = 0L;

    @Default
    @JsonProperty("total-application-instances")
    private Long totalApplicationInstances = 0L;

    @Default
    @JsonProperty("total-memory-used-in-gb")
    private Double totalMemoryUsed = 0.0;

    @Default
    @JsonProperty("total-disk-used-in-gb")
    private Double totalDiskUsed = 0.0;

    @Default
    @JsonProperty("velocity")
    private Map<String, Long> velocity = new HashMap<>();

    public static ApplicationCounts aggregate(List<ApplicationCounts> counts) {
        Map<String, Long> byBuildpack = merge(counts.stream().map(c -> c.getByBuildpack().entrySet()));
        Map<String, Long> byStack = merge(counts.stream().map(c -> c.getByStack().entrySet()));
        Map<String, Long> byDockerImage = merge(counts.stream().map(c -> c.getByDockerImage().entrySet()));
        Map<String, Long> byStatus = merge(counts.stream().map(c -> c.getByStatus().entrySet()));
        Long totalApplications = counts.stream().mapToLong(c -> c.getTotalApplications()).sum();
        Long totalRunningApplicationInstances = counts.stream().mapToLong(c -> c.getTotalRunningApplicationInstances()).sum();
        Long totalStoppedApplicationInstances = counts.stream().mapToLong(c -> c.getTotalStoppedApplicationInstances()).sum();
        Long totalCrashedApplicationInstances = counts.stream().mapToLong(c -> c.getTotalCrashedApplicationInstances()).sum();
        Long totalApplicationInstances = counts.stream().mapToLong(c -> c.getTotalApplicationInstances()).sum();
        Double totalMemoryUsed = counts.stream().mapToDouble(c -> c.getTotalMemoryUsed()).sum();
        Double totalDiskUsed = counts.stream().mapToDouble(c -> c.getTotalDiskUsed()).sum();
        Map<String, Long> velocity = merge(counts.stream().map(c -> c.getVelocity().entrySet()));
        return ApplicationCounts
                .builder()
                    .byBuildpack(byBuildpack)
                    .byStack(byStack)
                    .byDockerImage(byDockerImage)
                    .byStatus(byStatus)
                    .totalApplications(totalApplications)
                    .totalRunningApplicationInstances(totalRunningApplicationInstances)
                    .totalStoppedApplicationInstances(totalStoppedApplicationInstances)
                    .totalCrashedApplicationInstances(totalCrashedApplicationInstances)
                    .totalApplicationInstances(totalApplicationInstances)
                    .totalMemoryUsed(totalMemoryUsed)
                    .totalDiskUsed(totalDiskUsed)
                    .velocity(velocity)
                    .build();
    }

    private static Map<String, Long> merge(Stream<Set<Entry<String, Long>>> source) {
        Map<String, Long> target = new HashMap<>();
        source.forEach(oe -> oe.forEach(ie -> {
            if (target.keySet().contains(ie.getKey())) {
                target.put(ie.getKey(), ie.getValue() + target.get(ie.getKey()));
            } else {
                target.put(ie.getKey(), ie.getValue());
            }
        }));
        return target;
    }
}


================================================
File: src/main/java/org/cftoolsuite/cfapp/domain/Demographic.java
================================================
package org.cftoolsuite.cfapp.domain;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;

import lombok.Builder;
import lombok.Builder.Default;
import lombok.Getter;

@Builder
@Getter
@JsonPropertyOrder({ "foundation", "total-organizations", "total-spaces", "total-user-accounts", "total-service-accounts" })
public class Demographic {

    @JsonProperty("foundation")
    private String foundation;

    @Default
    @JsonProperty("total-organizations")
    private Long organizations = 0L;

    @Default
    @JsonProperty("total-spaces")
    private Long spaces = 0L;

    @Default
    @JsonProperty("total-user-accounts")
    private Long userAccounts = 0L;

    @Default
    @JsonProperty("total-service-accounts")
    private Long serviceAccounts = 0L;

    @JsonCreator
    public Demographic(
        @JsonProperty("foundation") String foundation,
        @JsonProperty("total-organizations") Long organizations,
        @JsonProperty("total-spaces") Long spaces,
        @JsonProperty("total-user-accounts") Long userAccounts,
        @JsonProperty("total-service-accounts") Long serviceAccounts
    ) {
        this.foundation = foundation;
        this.organizations = organizations;
        this.spaces = spaces;
        this.userAccounts = userAccounts;
        this.serviceAccounts = serviceAccounts;
    }

}

================================================
File: src/main/java/org/cftoolsuite/cfapp/domain/Demographics.java
================================================
package org.cftoolsuite.cfapp.domain;

import java.util.HashSet;
import java.util.Set;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;

import lombok.Builder;
import lombok.Builder.Default;
import lombok.Getter;

@Builder
@Getter
@JsonPropertyOrder({ "demographics", "total-foundations", "total-user-accounts", "total-service-accounts" })
public class Demographics {

    @Default
    @JsonProperty("demographics")
    private Set<Demographic> demographics = new HashSet();

    @Default
    @JsonProperty("total-foundations")
    private Integer foundations = 0;

    @Default
    @JsonProperty("total-user-accounts")
    private Long userAccounts = 0L;

    @Default
    @JsonProperty("total-service-accounts")
    private Long serviceAccounts = 0L;

    @JsonCreator
    public Demographics(
        @JsonProperty("demographics") Set<Demographic> demographics,
        @JsonProperty("total-foundations") Integer foundations,
        @JsonProperty("total-user-accounts") Long userAccounts,
        @JsonProperty("total-service-accounts") Long serviceAccounts
    ) {
        this.demographics = demographics;
        this.foundations = foundations;
        this.userAccounts = userAccounts;
        this.serviceAccounts = serviceAccounts;
    }

}

================================================
File: src/main/java/org/cftoolsuite/cfapp/domain/JavaAppDetail.java
================================================
package org.cftoolsuite.cfapp.domain;

import org.apache.commons.lang3.StringUtils;

import lombok.AccessLevel;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.EqualsAndHashCode;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.ToString;

@Builder
@AllArgsConstructor(access=AccessLevel.PACKAGE)
@NoArgsConstructor(access=AccessLevel.PACKAGE)
@Getter
@EqualsAndHashCode
@ToString
public class JavaAppDetail {

    private String foundation;
    private String organization;
    private String space;
    private String appId;
    private String appName;
    private String dropletId;
    private String pomContents;
    private String springDependencies;

    public static JavaAppDetailBuilder from(JavaAppDetail detail) {
        return JavaAppDetail
                .builder()
                .foundation(detail.getFoundation())
                .organization(detail.getOrganization())
                .space(detail.getSpace())
                .appId(detail.getAppId())
                .appName(detail.getAppName())
                .dropletId(detail.getDropletId())
                .pomContents(detail.getPomContents())
                .springDependencies(detail.getSpringDependencies());
    }

    public static String headers() {
        return String.join(",", "foundation", "organization", "space", "application id", "application name", "droplet id", "pom contents", "spring dependencies" );
    }

    private static String wrap(String value) {
        return value != null ? StringUtils.wrap(value, '"') : StringUtils.wrap("", '"');
    }

    public String toCsv() {
        return String.join(",", wrap(getFoundation()), wrap(getOrganization()), wrap(getSpace()), wrap(getAppId()), wrap(getAppName()),
                wrap(getDropletId()), wrap(getPomContents()), wrap(getSpringDependencies()));
    }

}


================================================
File: src/main/java/org/cftoolsuite/cfapp/domain/Organization.java
================================================
package org.cftoolsuite.cfapp.domain;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;

import lombok.Builder;
import lombok.EqualsAndHashCode;
import lombok.Getter;
import lombok.ToString;

@Builder
@Getter
@EqualsAndHashCode
@JsonPropertyOrder({ "foundation", "id", "name"})
@ToString
public class Organization {

    @JsonProperty("foundation")
    private String foundation;

    @JsonProperty("id")
    private final String id;

    @JsonProperty("name")
    private final String name;

    @JsonCreator
    public Organization(
            @JsonProperty("foundation") String foundation,
            @JsonProperty("id") String id,
            @JsonProperty("name") String name) {
        this.foundation = foundation;
        this.id = id;
        this.name = name;
    }

    public static OrganizationBuilder from(Organization organization) {
        return Organization
					.builder()
						.foundation(organization.getFoundation())
                        .id(organization.getId())
						.name(organization.getName());
	}

}


================================================
File: src/main/java/org/cftoolsuite/cfapp/domain/ServiceInstanceCounts.java
================================================
package org.cftoolsuite.cfapp.domain;

import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.Map.Entry;
import java.util.stream.Stream;

import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;

import lombok.AccessLevel;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.ToString;
import lombok.Builder.Default;

@Builder
@AllArgsConstructor(access=AccessLevel.PACKAGE)
@NoArgsConstructor(access=AccessLevel.PACKAGE)
@Getter
@ToString
@JsonPropertyOrder({ "by-service", "by-service-and-plan", "total-service-instances", "velocity" })
public class ServiceInstanceCounts {

    @Default
    @JsonProperty("by-service")
    private Map<String,Long> byService = new HashMap<>();

    @Default
    @JsonProperty("by-service-and-plan")
    private Map<String, Long> byServiceAndPlan = new HashMap<>();

    @Default
    @JsonProperty("total-service-instances")
    private Long totalServiceInstances = 0L;

    @Default
    @JsonProperty("velocity")
    private Map<String,Long> velocity = new HashMap<>();

    public static ServiceInstanceCounts aggregate(List<ServiceInstanceCounts> counts) {
        Map<String, Long> byService = merge(counts.stream().map(c -> c.getByService().entrySet()));
        Map<String, Long> byServiceAndPlan = merge(counts.stream().map(c -> c.getByServiceAndPlan().entrySet()));
        Long totalServiceInstances = counts.stream().mapToLong(c -> c.getTotalServiceInstances()).sum();
        Map<String, Long> velocity = merge(counts.stream().map(c -> c.getVelocity().entrySet()));
        return ServiceInstanceCounts
                .builder()
                    .byService(byService)
                    .byServiceAndPlan(byServiceAndPlan)
                    .totalServiceInstances(totalServiceInstances)
                    .velocity(velocity)
                    .build();
    }

    private static Map<String, Long> merge(Stream<Set<Entry<String, Long>>> source) {
        Map<String, Long> target = new HashMap<>();
        source.forEach(oe -> oe.forEach(ie -> {
            if (target.keySet().contains(ie.getKey())) {
                target.put(ie.getKey(), ie.getValue() + target.get(ie.getKey()));
            } else {
                target.put(ie.getKey(), ie.getValue());
            }
        }));
        return target;
    }
}


================================================
File: src/main/java/org/cftoolsuite/cfapp/domain/ServiceInstanceDetail.java
================================================
package org.cftoolsuite.cfapp.domain;

import java.time.LocalDateTime;
import java.util.Collections;
import java.util.ArrayList;
import java.util.List;

import org.apache.commons.lang3.StringUtils;

import lombok.AccessLevel;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.EqualsAndHashCode;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.ToString;
import lombok.Builder.Default;

@Builder
@AllArgsConstructor(access=AccessLevel.PACKAGE)
@NoArgsConstructor(access=AccessLevel.PACKAGE)
@Getter
@EqualsAndHashCode
@ToString
public class ServiceInstanceDetail {

	private String foundation;
	private String organization;
	private String space;
	private String serviceInstanceId;
	private String name;
	private String service;
	private String description;
	private String plan;
	private String type;
	@Default
	private List<String> applications = new ArrayList<>();
	private String lastOperation;
	private LocalDateTime lastUpdated;
	private String dashboardUrl;
	private String requestedState;

	public String toCsv() {
		return String.join(",", wrap(getFoundation()), wrap(getOrganization()), wrap(getSpace()), wrap(getServiceInstanceId()), wrap(getName()),
				wrap(getService()), wrap(getDescription()), wrap(getPlan()), wrap(getType()),
				wrap(String.join(",", getApplications() != null ? getApplications(): Collections.emptyList())), wrap(getLastOperation()),
				wrap(getLastUpdated() != null ? getLastUpdated().toString() : ""), wrap(getDashboardUrl()),
				wrap(getRequestedState()));
	}

	private static String wrap(String value) {
		return value != null ? StringUtils.wrap(value, '"') : StringUtils.wrap("", '"');
	}

	public static String headers() {
        return String.join(",", "foundation", "organization", "space", "service instance id",
                "name", "service", "description", "plan", "type", "bound applications", "last operation", "last updated", "dashboard url", "requested state");
    }

	public static ServiceInstanceDetailBuilder from(ServiceInstanceDetail detail) {
        return ServiceInstanceDetail
				.builder()
					.foundation(detail.getFoundation())
                    .organization(detail.getOrganization())
                    .space(detail.getSpace())
                    .serviceInstanceId(detail.getServiceInstanceId())
                    .name(detail.getName())
                    .service(detail.getService())
                    .description(detail.getDescription())
                    .plan(detail.getPlan())
                    .type(detail.getType())
                    .applications(detail.getApplications())
                    .lastOperation(detail.getLastOperation())
                    .lastUpdated(detail.getLastUpdated())
                    .dashboardUrl(detail.getDashboardUrl())
                    .requestedState(detail.getRequestedState());
    }

}


================================================
File: src/main/java/org/cftoolsuite/cfapp/domain/SnapshotDetail.java
================================================
package org.cftoolsuite.cfapp.domain;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;

import lombok.Builder;
import lombok.Builder.Default;
import lombok.Getter;
import lombok.ToString;

@Builder
@Getter
@ToString
@JsonPropertyOrder({ "applications", "service-instances", "application-relationships", "user-accounts", "service-accounts" })
public class SnapshotDetail {

    @Default
    @JsonProperty("applications")
    private List<AppDetail> applications = new ArrayList<>();

    @Default
    @JsonProperty("service-instances")
    private List<ServiceInstanceDetail> serviceInstances = new ArrayList<>();

    @Default
    @JsonProperty("application-relationships")
    private List<AppRelationship> applicationRelationships = new ArrayList<>();

    @Default
    @JsonProperty("user-accounts")
    private Set<String> userAccounts = new HashSet<>();

    @Default
    @JsonProperty("service-accounts")
    private Set<String> serviceAccounts = new HashSet<>();

    @JsonCreator
    public SnapshotDetail(
        @JsonProperty("applications") List<AppDetail> applications,
        @JsonProperty("service-instances") List<ServiceInstanceDetail> serviceInstances,
        @JsonProperty("application-relationships") List<AppRelationship> applicationRelationships,
        @JsonProperty("user-accounts") Set<String> userAccounts,
        @JsonProperty("service-accounts") Set<String> serviceAccounts) {
        this.applications = applications;
        this.serviceInstances = serviceInstances;
        this.applicationRelationships = applicationRelationships;
        this.userAccounts = userAccounts;
        this.serviceAccounts = serviceAccounts;
    }

}

================================================
File: src/main/java/org/cftoolsuite/cfapp/domain/SnapshotSummary.java
================================================
package org.cftoolsuite.cfapp.domain;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;

import lombok.Builder;
import lombok.Builder.Default;
import lombok.Getter;
import lombok.ToString;

@Builder
@Getter
@ToString
@JsonPropertyOrder({ "application-counts", "service-instance-counts" })
public class SnapshotSummary {

    @Default
    @JsonProperty("application-counts")
    private ApplicationCounts applicationCounts = ApplicationCounts.builder().build();

    @Default
    @JsonProperty("service-instance-counts")
    private ServiceInstanceCounts serviceInstanceCounts = ServiceInstanceCounts.builder().build();

    @JsonCreator
    public SnapshotSummary(
        @JsonProperty("application-counts") ApplicationCounts applicationCounts,
        @JsonProperty("service-instance-counts") ServiceInstanceCounts serviceInstanceCounts) {
        this.applicationCounts = applicationCounts;
        this.serviceInstanceCounts = serviceInstanceCounts;
    }

}

================================================
File: src/main/java/org/cftoolsuite/cfapp/domain/Space.java
================================================
package org.cftoolsuite.cfapp.domain;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;

import lombok.Builder;
import lombok.EqualsAndHashCode;
import lombok.Getter;
import lombok.ToString;

@Builder
@Getter
@JsonPropertyOrder({ "foundation", "organization-id", "organization-name", "space-id", "space-name" })
@EqualsAndHashCode
@ToString
public class Space {

    @JsonProperty("foundation")
    private String foundation;

    @JsonProperty("organization-id")
    private final String organizationId;

    @JsonProperty("organization-name")
    private final String organizationName;

    @JsonProperty("space-id")
    private final String spaceId;

    @JsonProperty("space-name")
    private final String spaceName;

    @JsonCreator
    Space(
            @JsonProperty("foundation") String foundation,
            @JsonProperty("organization-id") String organizationId,
            @JsonProperty("organization-name") String organizationName,
            @JsonProperty("space-id") String spaceId,
            @JsonProperty("space-name") String spaceName) {
        this.foundation = foundation;
        this.organizationId = organizationId;
        this.organizationName = organizationName;
        this.spaceId = spaceId;
        this.spaceName = spaceName;
    }

    public static SpaceBuilder from(Space space) {
        return Space
                    .builder()
                        .foundation(space.getFoundation())
                        .organizationId(space.getOrganizationId())
                        .organizationName(space.getOrganizationName())
                        .spaceId(space.getSpaceId())
                        .spaceName(space.getSpaceName());
    }
}


================================================
File: src/main/java/org/cftoolsuite/cfapp/domain/SpaceUsers.java
================================================
package org.cftoolsuite.cfapp.domain;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;

import lombok.Builder;
import lombok.Builder.Default;
import lombok.EqualsAndHashCode;
import lombok.Getter;
import lombok.ToString;

@Builder
@Getter
@EqualsAndHashCode
@ToString
@JsonPropertyOrder({"foundation", "organization", "space", "auditors", "developers", "managers", "users", "user-count"})
public class SpaceUsers {

	@JsonProperty("foundation")
	private String foundation;

	@JsonProperty("organization")
	private String organization;

	@JsonProperty("space")
	private String space;

	@Default
	@JsonProperty("auditors")
	private List<String> auditors = new ArrayList<>();

	@Default
	@JsonProperty("developers")
	private List<String> developers = new ArrayList<>();

	@Default
	@JsonProperty("managers")
	private List<String> managers = new ArrayList<>();

	@Default
	@JsonProperty("users")
	private Set<String> users = new HashSet<>();

	@Default
	@JsonProperty("user-count")
	private Integer userCount = 0;

	@JsonCreator
	public SpaceUsers(
		@JsonProperty("foundation") String foundation,
		@JsonProperty("organization") String organization,
		@JsonProperty("space") String space,
		@JsonProperty("auditors") List<String> auditors,
		@JsonProperty("developers") List<String> developers,
		@JsonProperty("managers") List<String> managers,
		@JsonProperty("users") Set<String> users,
		@JsonProperty("user-count") Integer userCount
	) {
		this.foundation = foundation;
		this.organization = organization;
		this.space = space;
		this.auditors = auditors;
		this.developers = developers;
		this.managers = managers;
		this.users = users;
		this.userCount = userCount;
	}

	public static SpaceUsersBuilder from(SpaceUsers users) {
		return SpaceUsers
				.builder()
					.organization(users.getOrganization())
					.space(users.getSpace())
					.foundation(users.getFoundation())
					.auditors(users.getAuditors())
					.developers(users.getDevelopers())
					.managers(users.getManagers())
					.users(users.getUsers())
					.userCount(users.getUserCount());
	}
}


================================================
File: src/main/java/org/cftoolsuite/cfapp/domain/TimeKeeper.java
================================================
package org.cftoolsuite.cfapp.domain;

import java.time.LocalDateTime;

import org.apache.commons.lang3.StringUtils;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;

import lombok.AccessLevel;
import lombok.Builder;
import lombok.EqualsAndHashCode;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.ToString;

@Builder
@NoArgsConstructor(access=AccessLevel.PACKAGE)
@Getter
@EqualsAndHashCode
@ToString
@JsonPropertyOrder({ "foundation", "collection-date-time" })
public class TimeKeeper {

	@JsonProperty("foundation")
	private String foundation;

	@JsonProperty("collection-date-time")
	private LocalDateTime collectionDateTime;

    @JsonCreator
    TimeKeeper(@JsonProperty("foundation") String foundation,
        @JsonProperty("collection-date-time") LocalDateTime collectionDateTime) {
        this.foundation = foundation;
        this.collectionDateTime = collectionDateTime;
    }

	public String toCsv() {
		return String.join(",", wrap(getFoundation()), wrap(getCollectionDateTime() != null ? getCollectionDateTime().toString() : ""));
	}

	private static String wrap(String value) {
		return value != null ? StringUtils.wrap(value, '"') : StringUtils.wrap("", '"');
	}

	public static String headers() {
		return String.join(",", "foundation", "collection date/time");
	}

}


================================================
File: src/main/java/org/cftoolsuite/cfapp/domain/TimeKeepers.java
================================================
package org.cftoolsuite.cfapp.domain;

import java.util.HashSet;
import java.util.Set;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;

import lombok.Builder;
import lombok.Builder.Default;
import lombok.Getter;
import lombok.ToString;

@Builder
@Getter
@ToString
@JsonPropertyOrder({ "time-keepers" })
public class TimeKeepers {

    @Default
    @JsonProperty("time-keepers")
    private Set<TimeKeeper> timeKeepers = new HashSet<>();

    @JsonCreator
    public TimeKeepers(
        @JsonProperty("time-keepers") Set<TimeKeeper> timeKeepers) {
        this.timeKeepers = timeKeepers;
    }

}

================================================
File: src/main/java/org/cftoolsuite/cfapp/domain/accounting/application/AppUsageMonthly.java
================================================
package org.cftoolsuite.cfapp.domain.accounting.application;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;

import lombok.Builder;
import lombok.Builder.Default;
import lombok.Getter;

@Builder
@Getter
@JsonPropertyOrder({"month", "year", "average_app_instances","maximum_app_instances", "app_instance_hours"})
public class AppUsageMonthly {

    @JsonProperty("month")
    private Integer month;

    @JsonProperty("year")
    private Integer year;

    @Default
    @JsonProperty("average_app_instances")
    private Double averageAppInstances = 0.0;

    @Default
    @JsonProperty("maximum_app_instances")
    private Integer maximumAppInstances = 0;

    @Default
    @JsonProperty("app_instance_hours")
    private Double appInstanceHours = 0.0;

    @JsonCreator
    public AppUsageMonthly(
        @JsonProperty("month") Integer month,
        @JsonProperty("year") Integer year,
        @JsonProperty("average_app_instances") Double averageAppInstances,
        @JsonProperty("maximum_app_instances") Integer maximumAppInstances,
        @JsonProperty("app_instance_hours") Double appInstanceHours) {
        this.month = month;
        this.year = year;
        this.averageAppInstances = averageAppInstances;
        this.maximumAppInstances = maximumAppInstances;
        this.appInstanceHours = appInstanceHours;
    }


    @JsonIgnore
    public AppUsageMonthly combine(AppUsageMonthly usage) {
        AppUsageMonthly result = null;
        if (usage == null) {
            result = this;
        } else if (usage.getMonth().equals(month) && usage.getYear().equals(year)) {
            result =
                AppUsageMonthly
                    .builder()
                        .year(usage.getYear())
                        .month(usage.getMonth())
                        .appInstanceHours(this.appInstanceHours + usage.getAppInstanceHours())
                        .averageAppInstances(this.averageAppInstances + usage.getAverageAppInstances())
                        .maximumAppInstances(this.maximumAppInstances + usage.getMaximumAppInstances())
                        .build();
        } else {
            result = usage;
        }
        return result;
    }

    @JsonIgnore
    public String getYearAndMonth() {
        return String.join("-", String.valueOf(year), String.format("%02d", month));
    }

}

================================================
File: src/main/java/org/cftoolsuite/cfapp/domain/accounting/application/AppUsageReport.java
================================================
package org.cftoolsuite.cfapp.domain.accounting.application;

import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;

import lombok.Builder;
import lombok.Builder.Default;
import lombok.Getter;

@Builder
@Getter
@JsonPropertyOrder({"report_time", "monthly_reports", "yearly_reports"})
public class AppUsageReport {

    @JsonProperty("report_time")
    private String reportTime;

    @Default
    @JsonProperty("monthly_reports")
    private List<AppUsageMonthly> monthlyReports = new ArrayList<>();

    @Default
    @JsonProperty("yearly_reports")
    private List<AppUsageYearly> yearlyReports = new ArrayList<>();

    @JsonCreator
    public AppUsageReport(
        @JsonProperty("report_time") String reportTime,
        @JsonProperty("monthly_reports") List<AppUsageMonthly> monthlyReports,
        @JsonProperty("yearly_reports") List<AppUsageYearly> yearlyReports) {
        this.reportTime = reportTime;
        this.monthlyReports = monthlyReports;
        this.yearlyReports = yearlyReports;
    }


    public static AppUsageReport aggregate(List<AppUsageReport> source) {
        AppUsageReportBuilder report = AppUsageReport.builder();
        Map<String, AppUsageMonthly> monthlyReports = new HashMap<>();
        Map<Integer, AppUsageYearly> yearlyReports = new HashMap<>();
        report.reportTime(LocalDateTime.now().toString());
        source.forEach(aur -> {
                for (AppUsageMonthly smr: aur.getMonthlyReports()) {
                    if (monthlyReports.isEmpty()) {
                        monthlyReports.put(smr.getYearAndMonth(), smr);
                    } else {
                        AppUsageMonthly existing = monthlyReports.get(smr.getYearAndMonth());
                        monthlyReports.put(smr.getYearAndMonth(), smr.combine(existing));
                    }
                }
                for (AppUsageYearly syr: aur.getYearlyReports()) {
                    if (yearlyReports.isEmpty()) {
                        yearlyReports.put(syr.getYear(), syr);
                    } else {
                        AppUsageYearly existing = yearlyReports.get(syr.getYear());
                        yearlyReports.put(syr.getYear(), syr.combine(existing));
                    }
                }
        });
        List<AppUsageMonthly> sortedMonthlyReports = new ArrayList<>();
        sortedMonthlyReports.addAll(monthlyReports.values());
        sortedMonthlyReports.sort(Comparator.comparing(AppUsageMonthly::getYearAndMonth));
        report.monthlyReports(sortedMonthlyReports);
        List<AppUsageYearly> sortedYearlyReports = new ArrayList<>();
        sortedYearlyReports.addAll(yearlyReports.values());
        sortedYearlyReports.sort(Comparator.comparing(AppUsageYearly::getYear));
        report.yearlyReports(sortedYearlyReports);
        return report.build();
    }
}

================================================
File: src/main/java/org/cftoolsuite/cfapp/domain/accounting/application/AppUsageYearly.java
================================================
package org.cftoolsuite.cfapp.domain.accounting.application;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;

import lombok.Builder;
import lombok.Builder.Default;
import lombok.Getter;

@Builder
@Getter
@JsonPropertyOrder({"year", "average_app_instances", "maximum_app_instances", "app_instance_hours"})
public class AppUsageYearly {

    @JsonProperty("year")
    private Integer year;

    @Default
    @JsonProperty("average_app_instances")
    private Double averageAppInstances = 0.0;

    @Default
    @JsonProperty("maximum_app_instances")
    private Integer maximumAppInstances = 0;

    @Default
    @JsonProperty("app_instance_hours")
    private Double appInstanceHours = 0.0;

    @JsonCreator
    public AppUsageYearly(
        @JsonProperty("year") Integer year,
        @JsonProperty("average_app_instances") Double averageAppInstances,
        @JsonProperty("maximum_app_instances") Integer maximumAppInstances,
        @JsonProperty("app_instance_hours") Double appInstanceHours) {
        this.year = year;
        this.averageAppInstances = averageAppInstances;
        this.maximumAppInstances = maximumAppInstances;
        this.appInstanceHours = appInstanceHours;
    }

    @JsonIgnore
    public AppUsageYearly combine(AppUsageYearly usage) {
        AppUsageYearly result = null;
        if (usage == null) {
            result = this;
        } else if (usage.getYear().equals(year)) {
            result =
                AppUsageYearly
                    .builder()
                        .year(usage.getYear())
                        .appInstanceHours(this.appInstanceHours + usage.getAppInstanceHours())
                        .averageAppInstances(this.averageAppInstances + usage.getAverageAppInstances())
                        .maximumAppInstances(this.maximumAppInstances + usage.getMaximumAppInstances())
                        .build();
        } else {
            result = usage;
        }
        return result;
    }
}


================================================
File: src/main/java/org/cftoolsuite/cfapp/domain/accounting/service/ServicePlanUsageMonthly.java
================================================
package org.cftoolsuite.cfapp.domain.accounting.service;

import java.util.ArrayList;
import java.util.List;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;

import lombok.Builder;
import lombok.Builder.Default;
import lombok.Getter;

@Builder
@Getter
@JsonPropertyOrder({ "usages", "service_plan_name", "service_plan_guid"})
public class ServicePlanUsageMonthly {

    @Default
    @JsonProperty("usages")
    public List<ServiceUsageMonthly> usages = new ArrayList<>();

    @JsonProperty("service_plan_name")
    public String servicePlanName;

    @JsonProperty("service_plan_guid")
    public String servicePlanGuid;

    @JsonCreator
    public ServicePlanUsageMonthly(
        @JsonProperty("usages") List<ServiceUsageMonthly> usages,
        @JsonProperty("service_plan_name") String servicePlanName,
        @JsonProperty("service_plan_guid") String servicePlanGuid) {
        this.usages = usages;
        this.servicePlanName = servicePlanName;
        this.servicePlanGuid = servicePlanGuid;
    }

    @JsonIgnore
    public ServicePlanUsageMonthly combine(ServicePlanUsageMonthly usage) {
        ServicePlanUsageMonthly result = null;
        if (usage == null) {
            result = this;
        } else if (usage.getServicePlanName().equals(servicePlanName)) {
            List<ServiceUsageMonthly> u = new ArrayList<>();
            for (ServiceUsageMonthly su: usage.getUsages()) {
                for (ServiceUsageMonthly suu: usages) {
                    u.add(suu.combine(su));
                }
            }
            String newServicePlanGuid = usage.getServicePlanGuid();
            if (!usage.getServicePlanGuid().contains(this.servicePlanGuid)) {
                newServicePlanGuid = String.join(",", this.servicePlanGuid, usage.getServicePlanGuid());
            }
            result =
                ServicePlanUsageMonthly
                    .builder()
                        .servicePlanGuid(newServicePlanGuid)
                        .servicePlanName(usage.getServicePlanName())
                        .usages(u)
                        .build();
        } else {
            result = usage;
        }
        return result;
    }

}


================================================
File: src/main/java/org/cftoolsuite/cfapp/domain/accounting/service/ServicePlanUsageYearly.java
================================================
package org.cftoolsuite.cfapp.domain.accounting.service;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;

import lombok.Builder;
import lombok.Builder.Default;
import lombok.Getter;

@Builder
@Getter
@JsonPropertyOrder({ "service_plan_name", "service_plan_guid", "year", "duration_in_hours", "maximum_instances", "average_instances"})
public class ServicePlanUsageYearly {

    @JsonProperty("service_plan_name")
    public String servicePlanName;

    @JsonProperty("service_plan_guid")
    public String servicePlanGuid;

    @JsonProperty("year")
    public Integer year;

    @Default
    @JsonProperty("duration_in_hours")
    public Double durationInHours = 0.0;

    @Default
    @JsonProperty("maximum_instances")
    public Integer maximumInstances = 0;

    @Default
    @JsonProperty("average_instances")
    public Double averageInstances = 0.0;

    @JsonCreator
    public ServicePlanUsageYearly(
        @JsonProperty("service_plan_name") String servicePlanName,
        @JsonProperty("service_plan_guid") String servicePlanGuid,
        @JsonProperty("year") Integer year,
        @JsonProperty("duration_in_hours") Double durationInHours,
        @JsonProperty("maximum_instances") Integer maximumInstances,
        @JsonProperty("average_instances") Double averageInstances) {
        this.servicePlanName = servicePlanName;
        this.servicePlanGuid = servicePlanGuid;
        this.year = year;
        this.durationInHours = durationInHours;
        this.maximumInstances = maximumInstances;
        this.averageInstances = averageInstances;
    }

    @JsonIgnore
    public ServicePlanUsageYearly combine(ServicePlanUsageYearly usage) {
        ServicePlanUsageYearly result = null;
        if (usage == null) {
            result = this;
        } else if (usage.getYear().equals(year) && usage.getServicePlanName().equals(servicePlanName)) {
            String newServicePlanGuid = usage.getServicePlanGuid();
            if (!usage.getServicePlanGuid().contains(this.servicePlanGuid)) {
                newServicePlanGuid = String.join(",", this.servicePlanGuid, usage.getServicePlanGuid());
            }
            result =
                ServicePlanUsageYearly
                    .builder()
                        .year(usage.getYear())
                        .servicePlanGuid(newServicePlanGuid)
                        .servicePlanName(usage.getServicePlanName())
                        .durationInHours(this.durationInHours + usage.getDurationInHours())
                        .averageInstances(this.averageInstances + usage.getAverageInstances())
                        .maximumInstances(this.maximumInstances + usage.getMaximumInstances())
                        .build();
        } else {
            result = usage;
        }
        return result;
    }

}


================================================
File: src/main/java/org/cftoolsuite/cfapp/domain/accounting/service/ServiceUsageMonthly.java
================================================
package org.cftoolsuite.cfapp.domain.accounting.service;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;

import lombok.Builder;
import lombok.Builder.Default;
import lombok.Getter;

@Builder
@Getter
@JsonPropertyOrder({"month", "year", "duration_in_hours", "average_instances", "maximum_instances"})
public class ServiceUsageMonthly {

    @JsonProperty("month")
    public Integer month;

    @JsonProperty("year")
    public Integer year;

    @Default
    @JsonProperty("duration_in_hours")
    public Double durationInHours = 0.0;

    @Default
    @JsonProperty("average_instances")
    public Double averageInstances = 0.0;

    @Default
    @JsonProperty("maximum_instances")
    public Integer maximumInstances = 0;

    @JsonCreator
    public ServiceUsageMonthly(
        @JsonProperty("month") Integer month,
        @JsonProperty("year") Integer year,
        @JsonProperty("duration_in_hours") Double durationInHours,
        @JsonProperty("average_instances") Double averageInstances,
        @JsonProperty("maximum_instances") Integer maximumInstances) {
        this.month = month;
        this.year = year;
        this.durationInHours = durationInHours;
        this.averageInstances = averageInstances;
        this.maximumInstances = maximumInstances;
    }

    @JsonIgnore
    public ServiceUsageMonthly combine(ServiceUsageMonthly usage) {
        ServiceUsageMonthly result = null;
        if (usage == null) {
            result = this;
        } else if (usage.getYear().equals(year) && usage.getMonth().equals(month)) {
            result =
                ServiceUsageMonthly
                    .builder()
                        .month(usage.getMonth())
                        .year(usage.getYear())
                        .durationInHours(this.durationInHours + usage.getDurationInHours())
                        .averageInstances(this.averageInstances + usage.getAverageInstances())
                        .maximumInstances(this.maximumInstances + usage.getMaximumInstances())
                        .build();
        } else {
            result = usage;
        }
        return result;
    }

    @JsonIgnore
    public String getYearAndMonth() {
        return String.join("-", String.valueOf(year), String.format("%02d", month));
    }

}


================================================
File: src/main/java/org/cftoolsuite/cfapp/domain/accounting/service/ServiceUsageMonthlyAggregate.java
================================================

package org.cftoolsuite.cfapp.domain.accounting.service;

import java.util.ArrayList;
import java.util.Comparator;
import java.util.List;
import java.util.HashMap;
import java.util.Map;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;

import lombok.Builder;
import lombok.Getter;
import lombok.Builder.Default;

@Builder
@Getter
@JsonPropertyOrder({"service_name", "service_guid", "usages", "plans"})
public class ServiceUsageMonthlyAggregate {

    @JsonProperty("service_name")
    public String serviceName;

    @JsonProperty("service_guid")
    public String serviceGuid;

    @Default
    @JsonProperty("usages")
    public List<ServiceUsageMonthly> usages = new ArrayList<>();

    @Default
    @JsonProperty("plans")
    public List<ServicePlanUsageMonthly> plans = new ArrayList<>();

    @JsonCreator
    public ServiceUsageMonthlyAggregate(
        @JsonProperty("service_name") String serviceName,
        @JsonProperty("service_guid") String serviceGuid,
        @JsonProperty("usages") List<ServiceUsageMonthly> usages,
        @JsonProperty("plans") List<ServicePlanUsageMonthly> plans) {
        this.serviceName = serviceName;
        this.serviceGuid = serviceGuid;
        this.usages = usages;
        this.plans = plans;
    }

    @JsonIgnore
    public ServiceUsageMonthlyAggregate combine(ServiceUsageMonthlyAggregate usage) {
        ServiceUsageMonthlyAggregate result = null;
        if (usage == null) {
            result = this;
        } else if (usage.getServiceName().equals(serviceName)) {
            Map<String, ServiceUsageMonthly> monthlyUsage = new HashMap<>();
            Map<String, ServicePlanUsageMonthly> monthlyPlans = new HashMap<>();
            usage.getUsages().forEach(su -> {
                for (ServiceUsageMonthly suu: usages) {
                    if (monthlyUsage.isEmpty()) {
                        monthlyUsage.put(suu.getYearAndMonth(), suu);
                    } else {
                        ServiceUsageMonthly existing = monthlyUsage.get(suu.getYearAndMonth());
                        monthlyUsage.put(suu.getYearAndMonth(), suu.combine(existing));
                    }
                }
            });
            usage.getPlans().forEach(pu -> {
                for (ServicePlanUsageMonthly spu: plans) {
                    if (monthlyPlans.isEmpty()) {
                        monthlyPlans.put(spu.getServicePlanName(), spu);
                    } else {
                        ServicePlanUsageMonthly existing = monthlyPlans.get(spu.getServicePlanName());
                        monthlyPlans.put(spu.getServicePlanName(), spu.combine(existing));
                    }
                }
            });
            List<ServiceUsageMonthly> sortedMonthlyUsage = new ArrayList<>();
            sortedMonthlyUsage.addAll(monthlyUsage.values());
            sortedMonthlyUsage.sort(Comparator.comparing(ServiceUsageMonthly::getYearAndMonth));
            List<ServicePlanUsageMonthly> sortedMonthlyPlans = new ArrayList<>();
            sortedMonthlyPlans.addAll(monthlyPlans.values());
            sortedMonthlyPlans.sort(Comparator.comparing(ServicePlanUsageMonthly::getServicePlanName));
            String newServiceGuid = usage.getServiceGuid();
            if (!usage.getServiceGuid().contains(this.serviceGuid)) {
                newServiceGuid = String.join(",", this.serviceGuid, usage.getServiceGuid());
            }
            result =
                ServiceUsageMonthlyAggregate
                    .builder()
                        .serviceGuid(newServiceGuid)
                        .serviceName(usage.getServiceName())
                        .usages(sortedMonthlyUsage)
                        .plans(sortedMonthlyPlans)
                        .build();
        } else {
            result = usage;
        }
        return result;
    }

}


================================================
File: src/main/java/org/cftoolsuite/cfapp/domain/accounting/service/ServiceUsageReport.java
================================================
package org.cftoolsuite.cfapp.domain.accounting.service;

import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;

import lombok.Builder;
import lombok.Builder.Default;
import lombok.Getter;

@Builder
@Getter
@JsonPropertyOrder({"report_time", "monthly_service_reports", "yearly_service_reports"})
public class ServiceUsageReport {

    @JsonProperty("report_time")
    public String reportTime;

    @Default
    @JsonProperty("monthly_service_reports")
    public List<ServiceUsageMonthlyAggregate> monthlyServiceReports = new ArrayList<>();

    @Default
    @JsonProperty("yearly_service_report")
    public List<ServiceUsageYearlyAggregate> yearlyServiceReport = new ArrayList<>();

    @JsonCreator
    public ServiceUsageReport(
        @JsonProperty("report_time") String reportTime,
        @JsonProperty("monthly_service_reports") List<ServiceUsageMonthlyAggregate> monthlyServiceReports,
        @JsonProperty("yearly_service_report") List<ServiceUsageYearlyAggregate> yearlyServiceReport) {
        this.reportTime = reportTime;
        this.monthlyServiceReports = monthlyServiceReports;
        this.yearlyServiceReport = yearlyServiceReport;
    }


    public static ServiceUsageReport aggregate(List<ServiceUsageReport> source) {
        ServiceUsageReportBuilder report = ServiceUsageReport.builder();
        Map<String, ServiceUsageMonthlyAggregate> monthlyReports = new HashMap<>();
        Map<String, ServiceUsageYearlyAggregate> yearlyReport = new HashMap<>();
        report.reportTime(LocalDateTime.now().toString());
        source.forEach(sur -> {
            for (ServiceUsageMonthlyAggregate smr: sur.getMonthlyServiceReports()) {
                if (monthlyReports.isEmpty()) {
                    monthlyReports.put(smr.getServiceName(), smr);
                } else {
                    ServiceUsageMonthlyAggregate existing = monthlyReports.get(smr.getServiceName());
                    monthlyReports.put(smr.getServiceName(), smr.combine(existing));
                }
            }
            for (ServiceUsageYearlyAggregate syr: sur.getYearlyServiceReport()) {
                if (yearlyReport.isEmpty()) {
                    yearlyReport.put(syr.getServiceName(), syr);
                } else {
                    ServiceUsageYearlyAggregate existing = yearlyReport.get(syr.getServiceName());
                    yearlyReport.put(syr.getServiceName(), syr.combine(existing));
                }
            }
        });
        List<ServiceUsageMonthlyAggregate> sortedMonthlyReports = new ArrayList<>();
        sortedMonthlyReports.addAll(monthlyReports.values());
        sortedMonthlyReports.sort(Comparator.comparing(ServiceUsageMonthlyAggregate::getServiceName));
        report.monthlyServiceReports(sortedMonthlyReports);
        List<ServiceUsageYearlyAggregate> sortedYearlyReports = new ArrayList<>();
        sortedYearlyReports.addAll(yearlyReport.values());
        sortedYearlyReports.sort(Comparator.comparing(ServiceUsageYearlyAggregate::getServiceName));
        report.yearlyServiceReport(sortedYearlyReports);
        return report.build();
    }

}


================================================
File: src/main/java/org/cftoolsuite/cfapp/domain/accounting/service/ServiceUsageYearlyAggregate.java
================================================
package org.cftoolsuite.cfapp.domain.accounting.service;

import java.util.ArrayList;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;

import lombok.Builder;
import lombok.Builder.Default;
import lombok.Getter;

@Builder
@Getter
@JsonPropertyOrder({"service_name", "service_guid", "year", "duration_in_hours", "maximum_instances", "average_instances", "plans"})
public class ServiceUsageYearlyAggregate {

    @JsonProperty("service_name")
    public String serviceName;

    @JsonProperty("service_guid")
    public String serviceGuid;

    @JsonProperty("year")
    public Integer year;

    @Default
    @JsonProperty("duration_in_hours")
    public Double durationInHours = 0.0;

    @Default
    @JsonProperty("maximum_instances")
    public Integer maximumInstances = 0;

    @Default
    @JsonProperty("average_instances")
    public Double averageInstances = 0.0;

    @Default
    @JsonProperty("plans")
    public List<ServicePlanUsageYearly> plans = new ArrayList<>();

    @JsonCreator
    public ServiceUsageYearlyAggregate(
        @JsonProperty("service_name") String serviceName,
        @JsonProperty("service_guid") String serviceGuid,
        @JsonProperty("year") Integer year,
        @JsonProperty("duration_in_hours") Double durationInHours,
        @JsonProperty("maximum_instances") Integer maximumInstances,
        @JsonProperty("average_instances") Double averageInstances,
        @JsonProperty("plans") List<ServicePlanUsageYearly> plans) {
        this.serviceName = serviceName;
        this.serviceGuid = serviceGuid;
        this.year = year;
        this.durationInHours = durationInHours;
        this.maximumInstances = maximumInstances;
        this.averageInstances = averageInstances;
        this.plans = plans;
    }

    @JsonIgnore
    public ServiceUsageYearlyAggregate combine(ServiceUsageYearlyAggregate usage) {
        ServiceUsageYearlyAggregate result = null;
        if (usage == null) {
            result = this;
        } else if (usage.getYear().equals(year) && usage.getServiceName().equals(serviceName)) {
            Map<Integer, ServicePlanUsageYearly> yearlyPlanUsage = new HashMap<>();
            usage.getPlans().forEach(pu -> {
                for (ServicePlanUsageYearly spu: plans) {
                    if (yearlyPlanUsage.isEmpty()) {
                        yearlyPlanUsage.put(spu.getYear(), spu);
                    } else {
                        ServicePlanUsageYearly existing = yearlyPlanUsage.get(spu.getYear());
                        yearlyPlanUsage.put(spu.getYear(), spu.combine(existing));
                    }
                }
            });
            List<ServicePlanUsageYearly> sortedYearlyPlans = new ArrayList<>();
            sortedYearlyPlans.addAll(yearlyPlanUsage.values());
            sortedYearlyPlans.sort(Comparator.comparing(ServicePlanUsageYearly::getYear));
            String newServiceGuid = usage.getServiceGuid();
            if (!usage.getServiceGuid().contains(this.serviceGuid)) {
                newServiceGuid = String.join(",", this.serviceGuid, usage.getServiceGuid());
            }
            result =
                ServiceUsageYearlyAggregate
                    .builder()
                    .serviceName(usage.getServiceName())
                    .serviceGuid(newServiceGuid)
                    .averageInstances(this.averageInstances + usage.getAverageInstances())
                    .maximumInstances(this.maximumInstances + usage.getMaximumInstances())
                    .durationInHours(this.durationInHours + usage.getDurationInHours())
                    .plans(sortedYearlyPlans)
                    .build();
        } else {
            result = usage;
        }
        return result;
    }
}


================================================
File: src/main/java/org/cftoolsuite/cfapp/domain/accounting/task/TaskUsageMonthly.java
================================================
package org.cftoolsuite.cfapp.domain.accounting.task;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;

import lombok.Builder;
import lombok.Builder.Default;
import lombok.Getter;

@Builder
@Getter
@JsonPropertyOrder({"month", "year", "total_task_runs", "maximum_concurrent_tasks", "task_hours"})
public class TaskUsageMonthly {

    @JsonProperty("month")
    private Integer month;

    @JsonProperty("year")
    private Integer year;

    @Default
    @JsonProperty("total_task_runs")
    private Integer totalTaskRuns = 0;

    @Default
    @JsonProperty("maximum_concurrent_tasks")
    private Integer maximumConcurrentTasks = 0;

    @Default
    @JsonProperty("task_hours")
    private Double taskHours = 0.0;

    @JsonCreator
    public TaskUsageMonthly(
        @JsonProperty("month") Integer month,
        @JsonProperty("year") Integer year,
        @JsonProperty("total_task_runs") Integer totalTaskRuns,
        @JsonProperty("maximum_concurrent_tasks") Integer maximumConcurrentTasks,
        @JsonProperty("task_hours") Double taskHours) {
        this.month = month;
        this.year = year;
        this.totalTaskRuns = totalTaskRuns;
        this.maximumConcurrentTasks = maximumConcurrentTasks;
        this.taskHours = taskHours;
    }

    @JsonIgnore
    public TaskUsageMonthly combine(TaskUsageMonthly usage) {
        TaskUsageMonthly result = null;
        if (usage == null) {
            result = this;
        } else if (usage.getMonth().equals(month) && usage.getYear().equals(year)) {
            result =
                TaskUsageMonthly
                    .builder()
                        .year(usage.getYear())
                        .month(usage.getMonth())
                        .totalTaskRuns(this.totalTaskRuns + usage.getTotalTaskRuns())
                        .maximumConcurrentTasks(this.maximumConcurrentTasks + usage.getMaximumConcurrentTasks())
                        .taskHours(this.taskHours + usage.getTaskHours())
                        .build();
        } else {
            result = usage;
        }
        return result;
    }

    @JsonIgnore
    public String getYearAndMonth() {
        return String.join("-", String.valueOf(year), String.format("%02d", month));
    }
}

================================================
File: src/main/java/org/cftoolsuite/cfapp/domain/accounting/task/TaskUsageReport.java
================================================
package org.cftoolsuite.cfapp.domain.accounting.task;

import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;

import lombok.Builder;
import lombok.Builder.Default;
import lombok.Getter;

@Builder
@Getter
@JsonPropertyOrder({"report_time", "monthly_reports", "yearly_reports"})
public class TaskUsageReport {

    @JsonProperty("report_time")
    private String reportTime;

    @Default
    @JsonProperty("monthly_reports")
    private List<TaskUsageMonthly> monthlyReports = new ArrayList<>();

    @Default
    @JsonProperty("yearly_reports")
    private List<TaskUsageYearly> yearlyReports = new ArrayList<>();

    @JsonCreator
    public TaskUsageReport(
        @JsonProperty("report_time") String reportTime,
        @JsonProperty("monthly_reports") List<TaskUsageMonthly> monthlyReports,
        @JsonProperty("yearly_reports") List<TaskUsageYearly> yearlyReports) {
        this.reportTime = reportTime;
        this.monthlyReports = monthlyReports;
        this.yearlyReports = yearlyReports;
    }


    public static TaskUsageReport aggregate(List<TaskUsageReport> source) {
        TaskUsageReportBuilder report = TaskUsageReport.builder();
        Map<String, TaskUsageMonthly> monthlyReports = new HashMap<>();
        Map<Integer, TaskUsageYearly> yearlyReports = new HashMap<>();
        report.reportTime(LocalDateTime.now().toString());
        source.forEach(aur -> {
                for (TaskUsageMonthly smr: aur.getMonthlyReports()) {
                    if (monthlyReports.isEmpty()) {
                        monthlyReports.put(smr.getYearAndMonth(), smr);
                    } else {
                        TaskUsageMonthly existing = monthlyReports.get(smr.getYearAndMonth());
                        monthlyReports.put(smr.getYearAndMonth(), smr.combine(existing));
                    }
                }
                for (TaskUsageYearly syr: aur.getYearlyReports()) {
                    if (yearlyReports.isEmpty()) {
                        yearlyReports.put(syr.getYear(), syr);
                    } else {
                        TaskUsageYearly existing = yearlyReports.get(syr.getYear());
                        yearlyReports.put(syr.getYear(), syr.combine(existing));
                    }
                }
        });
        List<TaskUsageMonthly> sortedMonthlyReports = new ArrayList<>();
        sortedMonthlyReports.addAll(monthlyReports.values());
        sortedMonthlyReports.sort(Comparator.comparing(TaskUsageMonthly::getYearAndMonth));
        report.monthlyReports(sortedMonthlyReports);
        List<TaskUsageYearly> sortedYearlyReports = new ArrayList<>();
        sortedYearlyReports.addAll(yearlyReports.values());
        sortedYearlyReports.sort(Comparator.comparing(TaskUsageYearly::getYear));
        report.yearlyReports(sortedYearlyReports);
        return report.build();
    }
}



================================================
File: src/main/java/org/cftoolsuite/cfapp/domain/accounting/task/TaskUsageYearly.java
================================================
package org.cftoolsuite.cfapp.domain.accounting.task;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;

import lombok.Builder;
import lombok.Builder.Default;
import lombok.Getter;

@Builder
@Getter
@JsonPropertyOrder({"year", "total_task_runs", "maximum_concurrent_tasks", "task_hours"})
public class TaskUsageYearly {

    @JsonProperty("year")
    private Integer year;

    @Default
    @JsonProperty("total_task_runs")
    private Integer totalTaskRuns = 0;

    @Default
    @JsonProperty("maximum_concurrent_tasks")
    private Integer maximumConcurrentTasks = 0;

    @Default
    @JsonProperty("task_hours")
    private Double taskHours = 0.0;

    @JsonCreator
    public TaskUsageYearly(
        @JsonProperty("year") Integer year,
        @JsonProperty("total_task_runs") Integer totalTaskRuns,
        @JsonProperty("maximum_concurrent_tasks") Integer maximumConcurrentTasks,
        @JsonProperty("task_hours") Double taskHours) {
        this.year = year;
        this.totalTaskRuns = totalTaskRuns;
        this.maximumConcurrentTasks = maximumConcurrentTasks;
        this.taskHours = taskHours;
    }

    @JsonIgnore
    public TaskUsageYearly combine(TaskUsageYearly usage) {
        TaskUsageYearly result = null;
        if (usage == null) {
            result = this;
        } else if (usage.getYear().equals(year)) {
            result =
                TaskUsageYearly
                    .builder()
                        .year(usage.getYear())
                        .totalTaskRuns(this.totalTaskRuns + usage.getTotalTaskRuns())
                        .maximumConcurrentTasks(this.maximumConcurrentTasks + usage.getMaximumConcurrentTasks())
                        .taskHours(this.taskHours + usage.getTaskHours())
                        .build();
        } else {
            result = usage;
        }
        return result;
    }
}

================================================
File: src/main/java/org/cftoolsuite/cfapp/report/AppDetailCsvReport.java
================================================
package org.cftoolsuite.cfapp.report;

import org.cftoolsuite.cfapp.domain.AppDetail;
import org.cftoolsuite.cfapp.task.AppDetailRetrievedEvent;

public class AppDetailCsvReport  {

    public String generateDetail(AppDetailRetrievedEvent event) {
        StringBuffer details = new StringBuffer();
        details.append("\n");
        details.append(AppDetail.headers());
        details.append("\n");
        event.getDetail()
                .forEach(a -> {
                    details.append(a.toCsv());
                    details.append("\n");
                });
        return details.toString();
    }

}

================================================
File: src/main/java/org/cftoolsuite/cfapp/report/AppRelationshipCsvReport.java
================================================
package org.cftoolsuite.cfapp.report;

import org.cftoolsuite.cfapp.domain.AppRelationship;
import org.cftoolsuite.cfapp.task.AppRelationshipRetrievedEvent;

public class AppRelationshipCsvReport  {

    public String generateDetail(AppRelationshipRetrievedEvent event) {
        StringBuffer details = new StringBuffer();
        details.append("\n");
        details.append(AppRelationship.headers());
        details.append("\n");
        event.getRelations()
                .forEach(a -> {
                    details.append(a.toCsv());
                    details.append("\n");
                });
        return details.toString();
    }
}

================================================
File: src/main/java/org/cftoolsuite/cfapp/report/ServiceInstanceDetailCsvReport.java
================================================
package org.cftoolsuite.cfapp.report;

import org.cftoolsuite.cfapp.domain.ServiceInstanceDetail;
import org.cftoolsuite.cfapp.task.ServiceInstanceDetailRetrievedEvent;

public class ServiceInstanceDetailCsvReport {

    public String generateDetail(ServiceInstanceDetailRetrievedEvent event) {
    	StringBuffer detail = new StringBuffer();
        detail.append("\n");
        detail.append(ServiceInstanceDetail.headers());
        detail.append("\n");
        event.getDetail()
                .forEach(a -> {
                    detail.append(a.toCsv());
                    detail.append("\n");
                });
        return detail.toString();
    }

}


================================================
File: src/main/java/org/cftoolsuite/cfapp/task/AppDetailRetrievedEvent.java
================================================
package org.cftoolsuite.cfapp.task;

import java.util.List;

import org.springframework.context.ApplicationEvent;

import org.cftoolsuite.cfapp.domain.AppDetail;

public class AppDetailRetrievedEvent extends ApplicationEvent {

    private static final long serialVersionUID = 1L;

    private List<AppDetail> detail;

    public AppDetailRetrievedEvent(Object source) {
        super(source);
    }

    public AppDetailRetrievedEvent detail(List<AppDetail> detail) {
        this.detail = detail;
        return this;
    }

    public List<AppDetail> getDetail() {
        return detail;
    }

}


================================================
File: src/main/java/org/cftoolsuite/cfapp/task/AppRelationshipRetrievedEvent.java
================================================
package org.cftoolsuite.cfapp.task;

import java.util.List;

import org.springframework.context.ApplicationEvent;

import org.cftoolsuite.cfapp.domain.AppRelationship;

public class AppRelationshipRetrievedEvent extends ApplicationEvent {

    private static final long serialVersionUID = 1L;

    private List<AppRelationship> relations;

    public AppRelationshipRetrievedEvent(Object source) {
        super(source);
    }

    public AppRelationshipRetrievedEvent relations(List<AppRelationship> relations) {
        this.relations = relations;
        return this;
    }

    public List<AppRelationship> getRelations() {
        return relations;
    }

}


================================================
File: src/main/java/org/cftoolsuite/cfapp/task/ServiceInstanceDetailRetrievedEvent.java
================================================
package org.cftoolsuite.cfapp.task;

import java.util.List;

import org.springframework.context.ApplicationEvent;

import org.cftoolsuite.cfapp.domain.ServiceInstanceDetail;

public class ServiceInstanceDetailRetrievedEvent extends ApplicationEvent {

    private static final long serialVersionUID = 1L;

    private List<ServiceInstanceDetail> detail;

    public ServiceInstanceDetailRetrievedEvent(Object source) {
        super(source);
    }

    public ServiceInstanceDetailRetrievedEvent detail(List<ServiceInstanceDetail> detail) {
        this.detail = detail;
        return this;
    }

    public List<ServiceInstanceDetail> getDetail() {
        return detail;
    }


}


================================================
File: src/test/java/org/cftoolsuite/cfapp/CfHooverApplicationTests.java
================================================
package org.cftoolsuite.cfapp;

import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.test.context.TestPropertySource;

@SpringBootTest
@TestPropertySource(properties = "cf.butlers.example=https://cf-butler.example.com")
public class CfHooverApplicationTests {

	@Test
	public void contextLoads() {
	}

}


================================================
File: .mvn/wrapper/MavenWrapperDownloader.java
================================================
/*
 * Copyright 2007-present the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import java.net.*;
import java.io.*;
import java.nio.channels.*;
import java.util.Properties;

public class MavenWrapperDownloader {

    private static final String WRAPPER_VERSION = "0.5.6";
    /**
     * Default URL to download the maven-wrapper.jar from, if no 'downloadUrl' is provided.
     */
    private static final String DEFAULT_DOWNLOAD_URL = "https://repo.maven.apache.org/maven2/io/takari/maven-wrapper/"
        + WRAPPER_VERSION + "/maven-wrapper-" + WRAPPER_VERSION + ".jar";

    /**
     * Path to the maven-wrapper.properties file, which might contain a downloadUrl property to
     * use instead of the default one.
     */
    private static final String MAVEN_WRAPPER_PROPERTIES_PATH =
            ".mvn/wrapper/maven-wrapper.properties";

    /**
     * Path where the maven-wrapper.jar will be saved to.
     */
    private static final String MAVEN_WRAPPER_JAR_PATH =
            ".mvn/wrapper/maven-wrapper.jar";

    /**
     * Name of the property which should be used to override the default download url for the wrapper.
     */
    private static final String PROPERTY_NAME_WRAPPER_URL = "wrapperUrl";

    public static void main(String args[]) {
        System.out.println("- Downloader started");
        File baseDirectory = new File(args[0]);
        System.out.println("- Using base directory: " + baseDirectory.getAbsolutePath());

        // If the maven-wrapper.properties exists, read it and check if it contains a custom
        // wrapperUrl parameter.
        File mavenWrapperPropertyFile = new File(baseDirectory, MAVEN_WRAPPER_PROPERTIES_PATH);
        String url = DEFAULT_DOWNLOAD_URL;
        if(mavenWrapperPropertyFile.exists()) {
            FileInputStream mavenWrapperPropertyFileInputStream = null;
            try {
                mavenWrapperPropertyFileInputStream = new FileInputStream(mavenWrapperPropertyFile);
                Properties mavenWrapperProperties = new Properties();
                mavenWrapperProperties.load(mavenWrapperPropertyFileInputStream);
                url = mavenWrapperProperties.getProperty(PROPERTY_NAME_WRAPPER_URL, url);
            } catch (IOException e) {
                System.out.println("- ERROR loading '" + MAVEN_WRAPPER_PROPERTIES_PATH + "'");
            } finally {
                try {
                    if(mavenWrapperPropertyFileInputStream != null) {
                        mavenWrapperPropertyFileInputStream.close();
                    }
                } catch (IOException e) {
                    // Ignore ...
                }
            }
        }
        System.out.println("- Downloading from: " + url);

        File outputFile = new File(baseDirectory.getAbsolutePath(), MAVEN_WRAPPER_JAR_PATH);
        if(!outputFile.getParentFile().exists()) {
            if(!outputFile.getParentFile().mkdirs()) {
                System.out.println(
                        "- ERROR creating output directory '" + outputFile.getParentFile().getAbsolutePath() + "'");
            }
        }
        System.out.println("- Downloading to: " + outputFile.getAbsolutePath());
        try {
            downloadFileFromURL(url, outputFile);
            System.out.println("Done");
            System.exit(0);
        } catch (Throwable e) {
            System.out.println("- Error downloading");
            e.printStackTrace();
            System.exit(1);
        }
    }

    private static void downloadFileFromURL(String urlString, File destination) throws Exception {
        if (System.getenv("MVNW_USERNAME") != null && System.getenv("MVNW_PASSWORD") != null) {
            String username = System.getenv("MVNW_USERNAME");
            char[] password = System.getenv("MVNW_PASSWORD").toCharArray();
            Authenticator.setDefault(new Authenticator() {
                @Override
                protected PasswordAuthentication getPasswordAuthentication() {
                    return new PasswordAuthentication(username, password);
                }
            });
        }
        URL website = new URL(urlString);
        ReadableByteChannel rbc;
        rbc = Channels.newChannel(website.openStream());
        FileOutputStream fos = new FileOutputStream(destination);
        fos.getChannel().transferFrom(rbc, 0, Long.MAX_VALUE);
        fos.close();
        rbc.close();
    }

}


