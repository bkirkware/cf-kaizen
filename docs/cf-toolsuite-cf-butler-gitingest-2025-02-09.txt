Directory structure:
└── cf-toolsuite-cf-butler/
    ├── src/
    │   ├── main/
    │   │   └── java/
    │   │       └── org/
    │   │           └── cftoolsuite/
    │   │               └── cfapp/
    │   │                   ├── AppInit.java
    │   │                   ├── client/
    │   │                   │   ├── GitClient.java
    │   │                   │   ├── OpsmanAccessTokenProvider.java
    │   │                   │   ├── OpsmanClient.java
    │   │                   │   └── PivnetClient.java
    │   │                   ├── config/
    │   │                   │   ├── ButlerCfEnvProcessor.java
    │   │                   │   ├── ButlerConfig.java
    │   │                   │   ├── DbmsSettings.java
    │   │                   │   ├── GitSettings.java
    │   │                   │   ├── H2ConsoleConfig.java
    │   │                   │   ├── JacksonDeSerConfig.java
    │   │                   │   ├── JavaArtifactReaderConfig.java
    │   │                   │   ├── NotifierConfig.java
    │   │                   │   ├── OpsmanSettings.java
    │   │                   │   ├── PasSettings.java
    │   │                   │   ├── PivnetSettings.java
    │   │                   │   ├── R2dbcConfig.java
    │   │                   │   └── WebClientConfig.java
    │   │                   ├── controller/
    │   │                   │   ├── DbmsOnlyPoliciesController.java
    │   │                   │   ├── DemographicsController.java
    │   │                   │   ├── DormantWorkloadsController.java
    │   │                   │   ├── HistoricalReportController.java
    │   │                   │   ├── JavaAppDetailController.java
    │   │                   │   ├── LegacyWorkloadsController.java
    │   │                   │   ├── OnDemandCollectorTriggerController.java
    │   │                   │   ├── OnDemandEventsController.java
    │   │                   │   ├── OnDemandPolicyTriggerController.java
    │   │                   │   ├── OnDemandResourceMetadataController.java
    │   │                   │   ├── OpsmanController.java
    │   │                   │   ├── OrganizationController.java
    │   │                   │   ├── PivnetController.java
    │   │                   │   ├── PoliciesController.java
    │   │                   │   ├── PomFileExportController.java
    │   │                   │   ├── ProductMetricsController.java
    │   │                   │   ├── SnapshotController.java
    │   │                   │   ├── SpaceController.java
    │   │                   │   ├── SpaceUsersController.java
    │   │                   │   ├── TimeKeeperController.java
    │   │                   │   ├── UsageController.java
    │   │                   │   └── UserSpacesController.java
    │   │                   ├── deser/
    │   │                   │   └── RelaxedLocalDateDeserializer.java
    │   │                   ├── domain/
    │   │                   │   ├── AppDetail.java
    │   │                   │   ├── AppDetailReadConverter.java
    │   │                   │   ├── AppDetailWriteConverter.java
    │   │                   │   ├── AppRelationship.java
    │   │                   │   ├── AppRelationshipRequest.java
    │   │                   │   ├── ApplicationCounts.java
    │   │                   │   ├── ApplicationOperation.java
    │   │                   │   ├── ApplicationPolicy.java
    │   │                   │   ├── ApplicationPolicyReadConverter.java
    │   │                   │   ├── ApplicationPolicyWriteConverter.java
    │   │                   │   ├── ApplicationState.java
    │   │                   │   ├── Buildpack.java
    │   │                   │   ├── CustomConverters.java
    │   │                   │   ├── Defaults.java
    │   │                   │   ├── Demographics.java
    │   │                   │   ├── EmailAttachment.java
    │   │                   │   ├── EmailNotificationTemplate.java
    │   │                   │   ├── EmailValidator.java
    │   │                   │   ├── EmbeddedMetadata.java
    │   │                   │   ├── EndpointPolicy.java
    │   │                   │   ├── EndpointPolicyReadConverter.java
    │   │                   │   ├── EndpointPolicyWriteConverter.java
    │   │                   │   ├── EndpointRequest.java
    │   │                   │   ├── Event.java
    │   │                   │   ├── HasCronExpression.java
    │   │                   │   ├── HasIdentifier.java
    │   │                   │   ├── HasOrganizationWhiteList.java
    │   │                   │   ├── HistoricalRecord.java
    │   │                   │   ├── Href.java
    │   │                   │   ├── HygienePolicy.java
    │   │                   │   ├── HygienePolicyReadConverter.java
    │   │                   │   ├── HygienePolicyWriteConverter.java
    │   │                   │   ├── JavaAppDetail.java
    │   │                   │   ├── LegacyPolicy.java
    │   │                   │   ├── LegacyPolicyReadConverter.java
    │   │                   │   ├── LegacyPolicyWriteConverter.java
    │   │                   │   ├── Metadata.java
    │   │                   │   ├── ObjectUtils.java
    │   │                   │   ├── Organization.java
    │   │                   │   ├── OwnerNotificationTemplate.java
    │   │                   │   ├── Pagination.java
    │   │                   │   ├── Policies.java
    │   │                   │   ├── PoliciesValidator.java
    │   │                   │   ├── Policy.java
    │   │                   │   ├── Query.java
    │   │                   │   ├── QueryPolicy.java
    │   │                   │   ├── QueryPolicyReadConverter.java
    │   │                   │   ├── QueryPolicyWriteConverter.java
    │   │                   │   ├── Resource.java
    │   │                   │   ├── ResourceEmailMetadata.java
    │   │                   │   ├── ResourceNotificationPolicy.java
    │   │                   │   ├── ResourceNotificationPolicyReadConverter.java
    │   │                   │   ├── ResourceNotificationPolicyWriteConverter.java
    │   │                   │   ├── ResourceType.java
    │   │                   │   ├── Resources.java
    │   │                   │   ├── ServiceInstanceCounts.java
    │   │                   │   ├── ServiceInstanceDetail.java
    │   │                   │   ├── ServiceInstanceDetailReadConverter.java
    │   │                   │   ├── ServiceInstanceDetailWriteConverter.java
    │   │                   │   ├── ServiceInstanceOperation.java
    │   │                   │   ├── ServiceInstancePolicy.java
    │   │                   │   ├── ServiceInstancePolicyReadConverter.java
    │   │                   │   ├── ServiceInstancePolicyWriteConverter.java
    │   │                   │   ├── SnapshotDetail.java
    │   │                   │   ├── SnapshotSummary.java
    │   │                   │   ├── Space.java
    │   │                   │   ├── SpaceUsers.java
    │   │                   │   ├── SpaceUsersReadConverter.java
    │   │                   │   ├── SpaceUsersWriteConverter.java
    │   │                   │   ├── Stack.java
    │   │                   │   ├── TimeKeeper.java
    │   │                   │   ├── UserAccounts.java
    │   │                   │   ├── UserCounts.java
    │   │                   │   ├── UserSpaces.java
    │   │                   │   ├── Workloads.java
    │   │                   │   ├── WorkloadsFilter.java
    │   │                   │   ├── accounting/
    │   │                   │   │   ├── application/
    │   │                   │   │   │   ├── AppUsageMonthly.java
    │   │                   │   │   │   ├── AppUsageReport.java
    │   │                   │   │   │   └── AppUsageYearly.java
    │   │                   │   │   ├── service/
    │   │                   │   │   │   ├── NormalizedServiceMonthlyUsage.java
    │   │                   │   │   │   ├── NormalizedServicePlanMonthlyUsage.java
    │   │                   │   │   │   ├── ServicePlanUsageMonthly.java
    │   │                   │   │   │   ├── ServicePlanUsageYearly.java
    │   │                   │   │   │   ├── ServiceUsageMonthly.java
    │   │                   │   │   │   ├── ServiceUsageMonthlyAggregate.java
    │   │                   │   │   │   ├── ServiceUsageReport.java
    │   │                   │   │   │   └── ServiceUsageYearlyAggregate.java
    │   │                   │   │   └── task/
    │   │                   │   │       ├── TaskUsageMonthly.java
    │   │                   │   │       ├── TaskUsageReport.java
    │   │                   │   │       └── TaskUsageYearly.java
    │   │                   │   ├── event/
    │   │                   │   │   ├── Entity.java
    │   │                   │   │   ├── EntityMetadata.java
    │   │                   │   │   ├── EventType.java
    │   │                   │   │   ├── Events.java
    │   │                   │   │   ├── Request.java
    │   │                   │   │   ├── Resource.java
    │   │                   │   │   └── ResourceMetadata.java
    │   │                   │   └── product/
    │   │                   │       ├── ArtifactReferences.java
    │   │                   │       ├── DeployedProduct.java
    │   │                   │       ├── Eula.java
    │   │                   │       ├── EulaAcceptance.java
    │   │                   │       ├── EulaLinks.java
    │   │                   │       ├── FileGroups.java
    │   │                   │       ├── OmInfo.java
    │   │                   │       ├── PivnetCache.java
    │   │                   │       ├── Product.java
    │   │                   │       ├── ProductFiles.java
    │   │                   │       ├── ProductLinks.java
    │   │                   │       ├── ProductMetric.java
    │   │                   │       ├── ProductMetrics.java
    │   │                   │       ├── ProductType.java
    │   │                   │       ├── Products.java
    │   │                   │       ├── Release.java
    │   │                   │       ├── ReleaseLinks.java
    │   │                   │       ├── Releases.java
    │   │                   │       ├── Self.java
    │   │                   │       ├── Staleness.java
    │   │                   │       ├── StemcellAssignment.java
    │   │                   │       ├── StemcellAssignments.java
    │   │                   │       ├── StemcellAssociation.java
    │   │                   │       ├── StemcellAssociations.java
    │   │                   │       ├── StemcellDetail.java
    │   │                   │       └── UserGroups.java
    │   │                   ├── event/
    │   │                   │   ├── AppDetailReadyToBeRetrievedEvent.java
    │   │                   │   ├── AppDetailRetrievedEvent.java
    │   │                   │   ├── AppRelationshipRetrievedEvent.java
    │   │                   │   ├── BuildpacksRetrievedEvent.java
    │   │                   │   ├── DatabaseCreatedEvent.java
    │   │                   │   ├── EmailNotificationEvent.java
    │   │                   │   ├── HistoricalRecordRetrievedEvent.java
    │   │                   │   ├── OrganizationsRetrievedEvent.java
    │   │                   │   ├── PoliciesLoadedEvent.java
    │   │                   │   ├── ProductsAndReleasesRetrievedEvent.java
    │   │                   │   ├── ServiceInstanceDetailRetrievedEvent.java
    │   │                   │   ├── SpacesRetrievedEvent.java
    │   │                   │   ├── StacksRetrievedEvent.java
    │   │                   │   ├── TkRetrievedEvent.java
    │   │                   │   └── UserAccountsRetrievedEvent.java
    │   │                   ├── notifier/
    │   │                   │   ├── AppDetailConsoleNotifier.java
    │   │                   │   ├── AppRelationshipConsoleNotifier.java
    │   │                   │   ├── EmailNotifier.java
    │   │                   │   ├── JavaMailNotifier.java
    │   │                   │   ├── ProductsAndReleasesConsoleNotifier.java
    │   │                   │   ├── SendGridNotifier.java
    │   │                   │   └── ServiceInstanceDetailConsoleNotifier.java
    │   │                   ├── report/
    │   │                   │   ├── AppDetailCsvReport.java
    │   │                   │   ├── AppRelationshipCsvReport.java
    │   │                   │   ├── HistoricalRecordCsvReport.java
    │   │                   │   ├── ServiceInstanceDetailCsvReport.java
    │   │                   │   └── UserAccountsCsvReport.java
    │   │                   ├── repository/
    │   │                   │   ├── PolicyIdProvider.java
    │   │                   │   ├── R2dbcAppDetailRepository.java
    │   │                   │   ├── R2dbcAppMetricsRepository.java
    │   │                   │   ├── R2dbcAppRelationshipRepository.java
    │   │                   │   ├── R2dbcHistoricalRecordRepository.java
    │   │                   │   ├── R2dbcJavaAppDetailRepository.java
    │   │                   │   ├── R2dbcOrganizationRepository.java
    │   │                   │   ├── R2dbcPoliciesRepository.java
    │   │                   │   ├── R2dbcQueryRepository.java
    │   │                   │   ├── R2dbcServiceInstanceDetailRepository.java
    │   │                   │   ├── R2dbcServiceInstanceMetricsRepository.java
    │   │                   │   ├── R2dbcSpaceRepository.java
    │   │                   │   ├── R2dbcSpaceUsersRepository.java
    │   │                   │   └── R2dbcTimeKeeperRepository.java
    │   │                   ├── service/
    │   │                   │   ├── AccountMatcher.java
    │   │                   │   ├── AppDetailService.java
    │   │                   │   ├── AppMetricsService.java
    │   │                   │   ├── AppRelationshipService.java
    │   │                   │   ├── ApplicationReporter.java
    │   │                   │   ├── BuildpacksCache.java
    │   │                   │   ├── DemographicsService.java
    │   │                   │   ├── DormantWorkloadsService.java
    │   │                   │   ├── DropletsService.java
    │   │                   │   ├── EventsService.java
    │   │                   │   ├── HistoricalRecordService.java
    │   │                   │   ├── JavaAppDetailService.java
    │   │                   │   ├── JavaArtifactRuntimeMetadataRetrievalService.java
    │   │                   │   ├── LegacyWorkloadsService.java
    │   │                   │   ├── OrganizationService.java
    │   │                   │   ├── PoliciesService.java
    │   │                   │   ├── ProductMetricsService.java
    │   │                   │   ├── QueryService.java
    │   │                   │   ├── R2dbcAppDetailService.java
    │   │                   │   ├── R2dbcAppMetricsService.java
    │   │                   │   ├── R2dbcAppRelationshipService.java
    │   │                   │   ├── R2dbcHistoricalRecordService.java
    │   │                   │   ├── R2dbcJavaAppDetailService.java
    │   │                   │   ├── R2dbcOrganizationService.java
    │   │                   │   ├── R2dbcPoliciesService.java
    │   │                   │   ├── R2dbcQueryService.java
    │   │                   │   ├── R2dbcServiceInstanceDetailService.java
    │   │                   │   ├── R2dbcServiceInstanceMetricsService.java
    │   │                   │   ├── R2dbcSpaceService.java
    │   │                   │   ├── R2dbcSpaceUsersService.java
    │   │                   │   ├── ReportRequest.java
    │   │                   │   ├── ResourceMetadataService.java
    │   │                   │   ├── ServiceInstanceDetailService.java
    │   │                   │   ├── ServiceInstanceMetricsService.java
    │   │                   │   ├── ServiceInstanceReporter.java
    │   │                   │   ├── SnapshotService.java
    │   │                   │   ├── SpaceService.java
    │   │                   │   ├── SpaceUsersService.java
    │   │                   │   ├── StacksCache.java
    │   │                   │   ├── TimeKeeperService.java
    │   │                   │   ├── TkServiceUtil.java
    │   │                   │   ├── UsageCache.java
    │   │                   │   ├── UsageService.java
    │   │                   │   └── UserSpacesService.java
    │   │                   ├── task/
    │   │                   │   ├── AppDetailReadyToBeCollectedDecider.java
    │   │                   │   ├── AppDetailTask.java
    │   │                   │   ├── AppRelationshipTask.java
    │   │                   │   ├── BuildpacksTask.java
    │   │                   │   ├── DatabaseCreator.java
    │   │                   │   ├── DeleteAppPolicyExecutorTask.java
    │   │                   │   ├── DeleteServiceInstancePolicyExecutorTask.java
    │   │                   │   ├── EndpointPolicyExecutorTask.java
    │   │                   │   ├── ExtractJavaArtifactsFromDropletTask.java
    │   │                   │   ├── HygienePolicyExecutorTask.java
    │   │                   │   ├── LegacyWorkloadReportingTask.java
    │   │                   │   ├── ObtainJavaArtifactsFromAppRuntimeMetadataTask.java
    │   │                   │   ├── OrganizationsTask.java
    │   │                   │   ├── PoliciesLoader.java
    │   │                   │   ├── PolicyExecutorTask.java
    │   │                   │   ├── PolicyExecutorTaskScheduler.java
    │   │                   │   ├── ProductsAndReleasesRetrievedListener.java
    │   │                   │   ├── ProductsAndReleasesTask.java
    │   │                   │   ├── QueryPolicyExecutorTask.java
    │   │                   │   ├── ResourceNotificationPolicyExecutorTask.java
    │   │                   │   ├── ScaleAppInstancesPolicyExecutorTask.java
    │   │                   │   ├── ServiceInstanceDetailTask.java
    │   │                   │   ├── SpaceUsersTask.java
    │   │                   │   ├── SpacesRetrievedListener.java
    │   │                   │   ├── SpacesTask.java
    │   │                   │   ├── StackChangeAppInstancesPolicyExecutorTask.java
    │   │                   │   ├── StacksTask.java
    │   │                   │   ├── StopAppPolicyExecutorTask.java
    │   │                   │   ├── TkTask.java
    │   │                   │   └── UsageTask.java
    │   │                   └── util/
    │   │                       ├── CsvUtil.java
    │   │                       ├── DbmsOnlyCondition.java
    │   │                       ├── DropletProcessingCondition.java
    │   │                       ├── JarManifestUtil.java
    │   │                       ├── JarSetFilterReader.java
    │   │                       ├── JarSetFilterReaderCondition.java
    │   │                       ├── JavaArtifactReader.java
    │   │                       ├── JsonToCsvConverter.java
    │   │                       ├── MavenPomReader.java
    │   │                       ├── PolicyFilter.java
    │   │                       ├── RetryableTokenProvider.java
    │   │                       └── TgzUtil.java
    │   └── test/
    │       └── java/
    │           └── org/
    │               └── cftoolsuite/
    │                   └── cfapp/
    │                       ├── ButlerTest.java
    │                       ├── domain/
    │                       │   ├── EmbeddedMetadataTest.java
    │                       │   ├── OrganizationTest.java
    │                       │   ├── PoliciesValidatorTest.java
    │                       │   └── product/
    │                       │       └── OmInfoTest.java
    │                       ├── notifier/
    │                       │   ├── JavaMailNotifierTest.java
    │                       │   └── SendGridNotifierTest.java
    │                       ├── repository/
    │                       │   ├── ListRemoteRepositoryExample.java
    │                       │   ├── R2dbcAppDetailRepositoryTest.java
    │                       │   ├── R2dbcAppMetricsRepositoryTest.java
    │                       │   ├── R2dbcOrganizationRepositoryTest.java
    │                       │   ├── R2dbcServiceInstanceDetailRepositoryTest.java
    │                       │   ├── R2dbcSpaceRepositoryTest.java
    │                       │   ├── R2dbcSpaceUsersRepositoryTest.java
    │                       │   └── R2dbcTimeKeeperRepositoryTest.java
    │                       ├── service/
    │                       │   ├── ApplicationReporterTest.java
    │                       │   ├── ReportRequestSpec.java
    │                       │   ├── ServiceInstanceReporterTest.java
    │                       │   └── SnapshotServiceTest.java
    │                       └── util/
    │                           ├── EmailTestUtil.java
    │                           └── JsonToCsvConverterTest.java
    └── .mvn/
        └── wrapper/
            └── MavenWrapperDownloader.java

================================================
File: src/main/java/org/cftoolsuite/cfapp/AppInit.java
================================================
package org.cftoolsuite.cfapp;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.boot.context.properties.ConfigurationPropertiesScan;
import org.springframework.transaction.annotation.EnableTransactionManagement;

import io.netty.util.ResourceLeakDetector;
import reactor.core.publisher.Hooks;


@EnableTransactionManagement
@ConfigurationPropertiesScan
@SpringBootApplication
public class AppInit {

    public static void main(String[] args) {
        Hooks.onOperatorDebug();
        ResourceLeakDetector.setLevel(ResourceLeakDetector.Level.ADVANCED);
        SpringApplication.run(AppInit.class, args);
    }
}


================================================
File: src/main/java/org/cftoolsuite/cfapp/client/GitClient.java
================================================
package org.cftoolsuite.cfapp.client;

import java.io.File;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.Comparator;
import java.util.List;

import org.apache.commons.lang3.StringUtils;
import org.cftoolsuite.cfapp.config.GitSettings;
import org.eclipse.jgit.api.Git;
import org.eclipse.jgit.api.errors.GitAPIException;
import org.eclipse.jgit.lib.ObjectId;
import org.eclipse.jgit.lib.Ref;
import org.eclipse.jgit.lib.Repository;
import org.eclipse.jgit.revwalk.RevCommit;
import org.eclipse.jgit.revwalk.RevWalk;
import org.eclipse.jgit.transport.UsernamePasswordCredentialsProvider;
import org.eclipse.jgit.treewalk.TreeWalk;
import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
import org.springframework.stereotype.Component;
import org.springframework.util.Assert;

import lombok.extern.slf4j.Slf4j;

@Slf4j
@Component
@ConditionalOnProperty(
        prefix = "cf.policies.git", name = "uri"
        )
public class GitClient {

    // @see https://stackoverflow.com/questions/42820282/get-the-latest-commit-in-a-repository-with-jgit
    public RevCommit getLatestCommit(Repository repo) throws IOException, GitAPIException {
        RevCommit latestCommit = null;
        int inc = 0;
        try(
                Git git = new Git(repo);
                RevWalk walk = new RevWalk(repo);
                ) {
            List<Ref> branches = git.branchList().call();
            for(Ref branch : branches) {
                RevCommit commit = walk.parseCommit(branch.getObjectId());
                if (inc == 0)
                    latestCommit = commit;
                if(commit.getAuthorIdent().getWhen().compareTo(latestCommit.getAuthorIdent().getWhen()) > 0)
                    latestCommit = commit;
                inc++;
            }
        }
        return latestCommit;
    }

    public Repository getRepository(GitSettings settings) {
        Repository result = null;
        String uri = settings.getUri();
        Assert.hasText(uri, "URI of remote Git repository must be specified");
        Assert.isTrue(uri.startsWith("https://"), "URI scheme must be https");
        Assert.isTrue(uri.endsWith(".git"), "URI must end with .git");
        String path = String.join(File.separator, "tmp", uri.substring(uri.lastIndexOf("/") + 1).replace(".git",""));
        try {
            File directory = new File(path);
            Path p = Paths.get(directory.toURI());
            if (Files.exists(p)) {
                Files
                .walk(p)
                .sorted(Comparator.reverseOrder())
                .map(Path::toFile)
                .forEach(File::delete);
            }
            Files.deleteIfExists(p);
            if (settings.isAuthenticated()) {
                String username = settings.getUsername();
                String password = settings.getPassword();
                Git
                    .cloneRepository()
                    .setURI(uri)
                    .setCredentialsProvider(new UsernamePasswordCredentialsProvider(username, password))
                    .setDirectory(directory)
                    .setCloneAllBranches(true)
                    .call()
                    .close();
            } else {
                Git
                    .cloneRepository()
                    .setURI(uri)
                    .setDirectory(directory)
                    .setCloneAllBranches(true)
                    .call()
                    .close();
            }
            result = Git.open(directory).getRepository();
        } catch (GitAPIException | IOException e) {
            log.warn(String.format("Cannot clone Git repository at %s", uri), e);
        }
        return result;
    }

    public String orLatestCommit(String commit, Repository repo) {
        String result = null;
        if (StringUtils.isNotBlank(commit)) {
            result = commit;
        } else {
            try {
                result = getLatestCommit(repo).getName();
            } catch (GitAPIException | IOException e) {
                log.error("Trouble fetching latest commit id.", e);
            }
        }
        return result;
    }

    public String readFile(Repository repo, String commitId, String filePath) throws IOException {
        ObjectId oid = repo.resolve(commitId);
        RevCommit commit = repo.parseCommit(oid);
        try (TreeWalk walk = TreeWalk.forPath(repo, filePath, commit.getTree())) {
            if (walk != null) {
                byte[] bytes = repo.open(walk.getObjectId(0)).getBytes();
                return new String(bytes, StandardCharsets.UTF_8);
            } else {
                throw new IllegalArgumentException(String.format("No file found for commitId=%s and filePath=%s", commitId, filePath));
            }
        }
    }

}


================================================
File: src/main/java/org/cftoolsuite/cfapp/client/OpsmanAccessTokenProvider.java
================================================
package org.cftoolsuite.cfapp.client;

import org.cftoolsuite.cfapp.config.OpsmanSettings;
import org.cloudfoundry.uaa.tokens.GetTokenByClientCredentialsResponse;
import org.cloudfoundry.uaa.tokens.GetTokenByPasswordResponse;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;
import org.springframework.util.LinkedMultiValueMap;
import org.springframework.web.reactive.function.client.WebClient;

import reactor.core.publisher.Mono;

@Component
class OpsmanAccessTokenProvider {

    private static final String URI_TEMPLATE = "https://%s%s";
    private final WebClient client;
    private final OpsmanSettings settings;

    @Autowired
    public OpsmanAccessTokenProvider(
            WebClient client,
            OpsmanSettings settings
            ) {
        this.client = client;
        this.settings = settings;
    }

    // @see https://docs.cloudfoundry.org/api/uaa/version/4.35.0/index.html
    Mono<String> obtainAccessToken() {
        String get = String.format(URI_TEMPLATE, settings.getApiHost(), "/uaa/oauth/token");
        LinkedMultiValueMap<String, String> request = new LinkedMultiValueMap<>();
        request.add("grant_type", settings.getGrantType().getValue());
        request.add("client_id", settings.getClientId());
        request.add("client_secret", settings.getClientSecret());
        request.add("username", settings.getUsername());
        request.add("password", settings.getPassword());
        Mono<String> response = null;
        switch(settings.getGrantType()) {
            case PASSWORD:
                response =
                    client
                        .post()
                        .uri(get)
                        .bodyValue(request)
                        .retrieve()
                        .bodyToMono(GetTokenByPasswordResponse.class)
                        .map(GetTokenByPasswordResponse::getAccessToken);
                break;
            case CLIENT_CREDENTIALS:
                response =
                    client
                        .post()
                        .uri(get)
                        .bodyValue(request)
                        .retrieve()
                        .bodyToMono(GetTokenByClientCredentialsResponse.class)
                        .map(GetTokenByClientCredentialsResponse::getAccessToken);
                break;
            default:
                response =
                    client
                        .post()
                        .uri(get)
                        .bodyValue(request)
                        .retrieve()
                        .bodyToMono(GetTokenByPasswordResponse.class)
                        .map(GetTokenByPasswordResponse::getAccessToken);
                break;
        }
        return response;
    }

    Mono<Void> revokeAccessToken(String bearerToken) {
        String revoke = String.format(URI_TEMPLATE, settings.getApiHost(), "/uaa/oauth/revoke/client");
        return
            client
                .delete()
                .uri(revoke + "/" + settings.getClientId())
                .headers(h -> h.setBearerAuth(bearerToken))
                .retrieve()
                .bodyToMono(Void.class);
    }

}


================================================
File: src/main/java/org/cftoolsuite/cfapp/client/OpsmanClient.java
================================================
package org.cftoolsuite.cfapp.client;

import java.util.List;

import org.cftoolsuite.cfapp.config.OpsmanSettings;
import org.cftoolsuite.cfapp.domain.product.DeployedProduct;
import org.cftoolsuite.cfapp.domain.product.OmInfo;
import org.cftoolsuite.cfapp.domain.product.StemcellAssignments;
import org.cftoolsuite.cfapp.domain.product.StemcellAssociations;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
import org.springframework.stereotype.Component;
import org.springframework.web.reactive.function.client.WebClient;

import reactor.core.publisher.Mono;

@Component
@ConditionalOnProperty(name = "om.enabled", havingValue = "true")
public class OpsmanClient {

    private static final String URI_TEMPLATE = "https://%s%s";
    private final WebClient client;
    private final OpsmanSettings settings;
    private final OpsmanAccessTokenProvider tokenProvider;

    @Autowired
    public OpsmanClient(
            WebClient client,
            OpsmanSettings settings,
            OpsmanAccessTokenProvider tokenProvider
            ) {
        this.client = client;
        this.settings = settings;
        this.tokenProvider = tokenProvider;
    }

    public Mono<List<DeployedProduct>> getDeployedProducts() {
        String uri = String.format(URI_TEMPLATE, settings.getApiHost(), "/api/v0/deployed/products");
        return
            tokenProvider
                .obtainAccessToken()
                .flatMap(token ->
                    client
                        .get()
                        .uri(uri)
                        .headers(h -> h.setBearerAuth(token))
                        .retrieve()
                        .bodyToFlux(DeployedProduct.class)
                        .collectList()
                );
    }

    public Mono<OmInfo> getOmInfo() {
        String uri = String.format(URI_TEMPLATE, settings.getApiHost(), "/api/v0/info");
        return
            tokenProvider
                .obtainAccessToken()
                .flatMap(token ->
                    client
                        .get()
                        .uri(uri)
                        .headers(h -> h.setBearerAuth(token))
                        .retrieve()
                        .bodyToMono(OmInfo.class)
                );
    }

    public Mono<String> getOmVersion() {
        String uri = String.format(URI_TEMPLATE, settings.getApiHost(), "/api/v0/info");
        return
            client
                .get()
                .uri(uri)
                .retrieve()
                .bodyToMono(OmInfo.class)
                .map(response -> response.getInfo().getVersion());
    }

    public Mono<StemcellAssignments> getStemcellAssignments() {
        String uri = String.format(URI_TEMPLATE, settings.getApiHost(), "/api/v0/stemcell_assignments");
        return
            tokenProvider
                .obtainAccessToken()
                .flatMap(token ->
                    client
                        .get()
                        .uri(uri)
                        .headers(h -> h.setBearerAuth(token))
                        .retrieve()
                        .bodyToMono(StemcellAssignments.class)
                );
    }

    public Mono<StemcellAssociations> getStemcellAssociations() {
        String uri = String.format(URI_TEMPLATE, settings.getApiHost(), "/api/v0/stemcell_associations");
        return
            getOmInfo()
                .filter(info -> info.getMajorVersion() >= 2 && info.getMinorVersion() >= 6)
                .flatMap(r ->
                    tokenProvider
                        .obtainAccessToken()
                        .flatMap(token ->
                            client
                                .get()
                                .uri(uri)
                                .headers(h -> h.setBearerAuth(token))
                                .retrieve()
                                .bodyToMono(StemcellAssociations.class)
                        )
                );
    }
}


================================================
File: src/main/java/org/cftoolsuite/cfapp/client/PivnetClient.java
================================================
package org.cftoolsuite.cfapp.client;

import org.cftoolsuite.cfapp.config.PivnetSettings;
import org.cftoolsuite.cfapp.domain.product.Products;
import org.cftoolsuite.cfapp.domain.product.Release;
import org.cftoolsuite.cfapp.domain.product.Releases;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
import org.springframework.http.HttpHeaders;
import org.springframework.stereotype.Component;
import org.springframework.web.reactive.function.client.WebClient;

import lombok.extern.slf4j.Slf4j;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

@Slf4j
@Component
@ConditionalOnProperty(name = "pivnet.enabled", havingValue = "true")
public class PivnetClient {

    private static final String BASE_URL = "https://network.tanzu.vmware.com/api";
    private final PivnetSettings settings;
    private final WebClient client;

    @Autowired
    public PivnetClient(PivnetSettings settings, WebClient client) {
        this.settings = settings;
        this.client = client;
    }

    public Flux<Release> getAllProductReleases() {
        return getProducts()
                .flatMapMany(list -> Flux.fromIterable(list.getProducts()))
                .flatMap(l -> getProductReleases(l.getSlug()))
                .onErrorContinue(
                        (ex, data) -> log.warn("Problem obtaining releases for product [{}].", data, ex));
    }

    public Mono<Release> getLatestProductRelease(String slug) {
        return getProductReleases(slug)
                .next()
                .onErrorContinue(
                        (ex, data) -> log.warn("Problem obtaining releases for product [{}].", slug, ex));
    }

    public Flux<Release> getLatestProductReleases() {
        return getProducts()
                .flatMapMany(list -> Flux.fromIterable(list.getProducts()))
                .flatMap(p -> getLatestProductRelease(p.getSlug()));
    }

    public Flux<Release> getProductReleases(String slug) {
        String uri = String.format("%s%s%s%s", BASE_URL, "/v2/products/", slug, "/releases");
        return client
                .get()
                .uri(uri)
                .header(HttpHeaders.AUTHORIZATION, settings.getApiToken())
                .retrieve()
                .bodyToMono(Releases.class)
                .flatMapMany(r -> Flux.fromIterable(r.getReleases()));
    }

    public Mono<Products> getProducts() {
        String uri = String.format("%s%s", BASE_URL, "/v2/products");
        return client
                .get()
                .uri(uri)
                .header(HttpHeaders.AUTHORIZATION, settings.getApiToken())
                .retrieve()
                .bodyToMono(Products.class);
    }
}


================================================
File: src/main/java/org/cftoolsuite/cfapp/config/ButlerCfEnvProcessor.java
================================================
package org.cftoolsuite.cfapp.config;

import java.util.Map;

import io.pivotal.cfenv.core.CfCredentials;
import io.pivotal.cfenv.core.CfService;
import io.pivotal.cfenv.spring.boot.CfEnvProcessor;
import io.pivotal.cfenv.spring.boot.CfEnvProcessorProperties;

public class ButlerCfEnvProcessor implements CfEnvProcessor {

    private static final String SERVICE_NAME = "cf-butler-secrets";

    private static void addOrUpdatePropertyValue(String propertyName, String credentialName, CfCredentials cfCredentials, Map<String, Object> properties) {
        Object credential = cfCredentials.getMap().get(credentialName);
        if (credential != null) {
            properties.put(propertyName, credential);
        }
    }

    private static void addPropertyValue(String propertyName, Object propertyValue, Map<String, Object> properties) {
        properties.put(propertyName, propertyValue);
    }

    @Override
    public boolean accept(CfService service) {
        return
            service.getName().equalsIgnoreCase(SERVICE_NAME);
    }

    @Override
    public CfEnvProcessorProperties getProperties() {
        return
            CfEnvProcessorProperties
                .builder()
                .serviceName(SERVICE_NAME)
                .build();
    }

    @Override
    public void process(CfCredentials cfCredentials, Map<String, Object> properties) {
        addPropertyValue("credhub.url", "https://credhub.service.cf.internal:8844", properties);
        addOrUpdatePropertyValue("spring.mail.host", "MAIL_HOST", cfCredentials, properties);
        addOrUpdatePropertyValue("spring.mail.port", "MAIL_PORT", cfCredentials, properties);
        addOrUpdatePropertyValue("spring.mail.username", "MAIL_USERNAME", cfCredentials, properties);
        addOrUpdatePropertyValue("spring.mail.password", "MAIL_PASSWORD", cfCredentials, properties);
        addOrUpdatePropertyValue("spring.mail.properties.mail.smtp.auth", "MAIL_SMTP_AUTH_ENABLED", cfCredentials, properties);
        addOrUpdatePropertyValue("spring.mail.properties.mail.smtp.starttls.enable", "MAIL_SMTP_STARTTLS_ENABLED", cfCredentials, properties);
        addOrUpdatePropertyValue("spring.mail.properties.mail.smtp.ssl.enable", "MAIL_SMTP_SSL_ENABLED", cfCredentials, properties);
        addOrUpdatePropertyValue("spring.sendgrid.api-key", "SENDGRID_API-KEY", cfCredentials, properties);
        addOrUpdatePropertyValue("spring.r2dbc.url", "R2DBC_URL", cfCredentials, properties);
        addOrUpdatePropertyValue("spring.r2dbc.username", "R2DBC_USERNAME", cfCredentials, properties);
        addOrUpdatePropertyValue("spring.r2dbc.password", "R2DBC_PASSWORD", cfCredentials, properties);
        addOrUpdatePropertyValue("notification.engine", "NOTIFICATION_ENGINE", cfCredentials, properties);
        addOrUpdatePropertyValue("cf.apiHost", "CF_API-HOST", cfCredentials, properties);
        addOrUpdatePropertyValue("cf.username", "CF_USERNAME", cfCredentials, properties);
        addOrUpdatePropertyValue("cf.password", "CF_PASSWORD", cfCredentials, properties);
        addOrUpdatePropertyValue("cf.sslValidationSkipped", "CF_SKIP-SSL-VALIDATION", cfCredentials, properties);
        addOrUpdatePropertyValue("cf.connectionPoolSize", "CF_CONNECTION_POOLSIZE", cfCredentials, properties);
        addOrUpdatePropertyValue("cf.connectionTimeout", "CF_CONNECTION_TIMEOUT", cfCredentials, properties);
        addOrUpdatePropertyValue("cf.tokenProvider", "CF_TOKEN-PROVIDER", cfCredentials, properties);
        addOrUpdatePropertyValue("cf.refreshToken", "CF_REFRESH-TOKEN", cfCredentials, properties);
        addOrUpdatePropertyValue("cf.organizationBlackList", "CF_ORGANIZATION-BLACK-LIST", cfCredentials, properties);
        addOrUpdatePropertyValue("cf.spaceBlackList", "CF_SPACE-BLACK-LIST", cfCredentials, properties);
        addOrUpdatePropertyValue("cf.accountRegex", "CF_ACCOUNT-REGEX", cfCredentials, properties);
        addOrUpdatePropertyValue("cf.policies.git.uri", "CF_POLICIES_GIT_URI", cfCredentials, properties);
        addOrUpdatePropertyValue("cf.policies.git.username", "CF_POLICIES_GIT_USERNAME", cfCredentials, properties);
        addOrUpdatePropertyValue("cf.policies.git.password", "CF_POLICIES_GIT_PASSWORD", cfCredentials, properties);
        addOrUpdatePropertyValue("cf.policies.git.commit", "CF_POLICIES_GIT_COMMIT", cfCredentials, properties);
        addOrUpdatePropertyValue("cf.policies.git.filePaths", "CF_POLICIES_GIT_FILE-PATHS", cfCredentials, properties);
        addOrUpdatePropertyValue("cf.buildpacks", "CF_BUILDPACKS", cfCredentials, properties);
        addOrUpdatePropertyValue("om.apiHost", "OM_API-HOST", cfCredentials, properties);
        addOrUpdatePropertyValue("om.clientId", "OM_CLIENT-ID", cfCredentials, properties);
        addOrUpdatePropertyValue("om.clientSecret", "OM_CLIENT-SECRET", cfCredentials, properties);
        addOrUpdatePropertyValue("om.username", "OM_USERNAME", cfCredentials, properties);
        addOrUpdatePropertyValue("om.password", "OM_PASSWORD", cfCredentials, properties);
        addOrUpdatePropertyValue("om.enabled", "OM_ENABLED", cfCredentials, properties);
        addOrUpdatePropertyValue("om.grantType", "OM_GRANT-TYPE", cfCredentials, properties);
        addOrUpdatePropertyValue("pivnet.apiToken", "PIVNET_API-TOKEN", cfCredentials, properties);
        addOrUpdatePropertyValue("pivnet.enabled", "PIVNET_ENABLED", cfCredentials, properties);
        addOrUpdatePropertyValue("cron.collection", "CRON_COLLECTION", cfCredentials, properties);
        addOrUpdatePropertyValue("management.endpoints.web.exposure.include", "EXPOSED_ACTUATOR_ENDPOINTS", cfCredentials, properties);
        addOrUpdatePropertyValue("java.artifacts.fetch.mode", "JAVA_ARTIFACTS_FETCH_MODE", cfCredentials, properties);
    }
}


================================================
File: src/main/java/org/cftoolsuite/cfapp/config/ButlerConfig.java
================================================
package org.cftoolsuite.cfapp.config;

import java.time.Duration;

import org.cloudfoundry.operations.DefaultCloudFoundryOperations;
import org.cloudfoundry.reactor.ConnectionContext;
import org.cloudfoundry.reactor.DefaultConnectionContext;
import org.cloudfoundry.reactor.TokenProvider;
import org.cloudfoundry.reactor.client.ReactorCloudFoundryClient;
import org.cloudfoundry.reactor.doppler.ReactorDopplerClient;
import org.cloudfoundry.reactor.tokenprovider.PasswordGrantTokenProvider;
import org.cloudfoundry.reactor.tokenprovider.RefreshTokenGrantTokenProvider;
import org.cloudfoundry.reactor.uaa.ReactorUaaClient;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.event.ApplicationEventMulticaster;
import org.springframework.context.event.SimpleApplicationEventMulticaster;
import org.springframework.core.task.SimpleAsyncTaskExecutor;

@Configuration
public class ButlerConfig {

    @Bean
    public ReactorCloudFoundryClient cloudFoundryClient(ConnectionContext connectionContext, TokenProvider tokenProvider) {
        return ReactorCloudFoundryClient
                .builder()
                .connectionContext(connectionContext)
                .tokenProvider(tokenProvider)
                .build();
    }

    @Bean
    public DefaultConnectionContext connectionContext(PasSettings settings) {
        return DefaultConnectionContext
                .builder()
                .apiHost(settings.getApiHost())
                .skipSslValidation(settings.isSslValidationSkipped())
                .keepAlive(true)
                .connectionPoolSize(settings.getConnectionPoolSize())
                .connectTimeout(Duration.parse(settings.getConnectionTimeout()))
                .sslHandshakeTimeout(Duration.ofSeconds(30))
                .build();
    }

    @Bean
    public ReactorDopplerClient dopplerClient(ConnectionContext connectionContext, TokenProvider tokenProvider) {
        return ReactorDopplerClient
                .builder()
                .connectionContext(connectionContext)
                .tokenProvider(tokenProvider)
                .build();
    }

    @Bean
    public DefaultCloudFoundryOperations opsClient(ReactorCloudFoundryClient cloudFoundryClient,
            ReactorDopplerClient dopplerClient, ReactorUaaClient uaaClient) {
        return DefaultCloudFoundryOperations
                .builder()
                .cloudFoundryClient(cloudFoundryClient)
                .dopplerClient(dopplerClient)
                .uaaClient(uaaClient)
                .build();
    }

    @Bean(name = "applicationEventMulticaster")
    public ApplicationEventMulticaster simpleApplicationEventMulticaster() {
        SimpleApplicationEventMulticaster eventMulticaster =
                new SimpleApplicationEventMulticaster();
        eventMulticaster.setTaskExecutor(new SimpleAsyncTaskExecutor());
        return eventMulticaster;
    }

    @Bean
    public TokenProvider tokenProvider(PasSettings settings) {
        if (settings.getTokenProvider().equalsIgnoreCase("userpass")) {
            return PasswordGrantTokenProvider
                    .builder()
                    .username(settings.getUsername())
                    .password(settings.getPassword())
                    .build();
        } else if (settings.getTokenProvider().equalsIgnoreCase("sso")) {
            return RefreshTokenGrantTokenProvider
                    .builder()
                    .token(settings.getRefreshToken())
                    .build();
        } else {
            throw new IllegalStateException("Unknown TokenProvider");
        }
    }

    @Bean
    public ReactorUaaClient uaaClient(ConnectionContext connectionContext, TokenProvider tokenProvider) {
        return ReactorUaaClient
                .builder()
                .connectionContext(connectionContext)
                .tokenProvider(tokenProvider)
                .build();
    }

}


================================================
File: src/main/java/org/cftoolsuite/cfapp/config/DbmsSettings.java
================================================
package org.cftoolsuite.cfapp.config;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import io.r2dbc.spi.ConnectionFactory;

@Component
public class DbmsSettings {

    private final ConnectionFactory factory;

    @Autowired
    public DbmsSettings(ConnectionFactory factory) {
        this.factory = factory;
    }

    public String getProvider() {
        return factory.getMetadata().getName();
    }
}


================================================
File: src/main/java/org/cftoolsuite/cfapp/config/GitSettings.java
================================================
package org.cftoolsuite.cfapp.config;

import java.util.Set;

import org.apache.commons.lang3.StringUtils;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.boot.context.properties.bind.ConstructorBinding;

import lombok.Builder;
import lombok.Builder.Default;
import lombok.Getter;

@Builder
@Getter
@ConfigurationProperties(prefix = "cf.policies.git")
public class GitSettings {

    @Default
    private String uri = "";
    private String username;
    @Default
    private String password = "";
    private String commit;
    private Set<String> filePaths;

    public boolean isAuthenticated() {
        return StringUtils.isNotBlank(getUsername());
    }

    public boolean isPinnedCommit() {
        return StringUtils.isNotBlank(getCommit());
    }

    public boolean isVersionManaged() {
        return StringUtils.isNotBlank(uri);
    }

    @ConstructorBinding
    GitSettings(
        String uri,
        String username,
        String password,
        String commit,
        Set<String> filePaths) {
            this.uri = uri;
            this.username = username;
            this.password = password;
            this.commit = commit;
            this.filePaths = filePaths;
    }
}


================================================
File: src/main/java/org/cftoolsuite/cfapp/config/H2ConsoleConfig.java
================================================
package org.cftoolsuite.cfapp.config;

import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
import org.springframework.context.event.ContextClosedEvent;
import org.springframework.context.event.ContextRefreshedEvent;
import org.springframework.context.event.EventListener;
import org.springframework.stereotype.Component;

import lombok.extern.slf4j.Slf4j;

@Slf4j
@Component
@ConditionalOnProperty(prefix = "spring.h2.console", name = "enabled", havingValue = "true", matchIfMissing = false)
public class H2ConsoleConfig {

    private org.h2.tools.Server webServer;

    private org.h2.tools.Server server;

    @EventListener(ContextRefreshedEvent.class)
    public void start() throws java.sql.SQLException {
        log.trace("Enabling H2 Web console...");
        this.webServer = org.h2.tools.Server.createWebServer("-webPort", "8082", "-tcpAllowOthers").start();
        this.server = org.h2.tools.Server.createTcpServer("-tcpPort", "9092", "-tcpAllowOthers").start();
    }

    @EventListener(ContextClosedEvent.class)
    public void stop() {
        this.webServer.stop();
        this.server.stop();
    }

}


================================================
File: src/main/java/org/cftoolsuite/cfapp/config/JacksonDeSerConfig.java
================================================
package org.cftoolsuite.cfapp.config;

import java.time.LocalDate;

import org.cftoolsuite.cfapp.deser.RelaxedLocalDateDeserializer;
import org.springframework.boot.autoconfigure.jackson.Jackson2ObjectMapperBuilderCustomizer;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import com.fasterxml.jackson.databind.module.SimpleModule;

@Configuration
public class JacksonDeSerConfig {

    @Bean
    public Jackson2ObjectMapperBuilderCustomizer addCustomDeserialization() {
        return builder -> {
            SimpleModule module = new SimpleModule();
            module.addDeserializer(LocalDate.class, new RelaxedLocalDateDeserializer());
            builder.modulesToInstall(module);
        };
    }
}


================================================
File: src/main/java/org/cftoolsuite/cfapp/config/JavaArtifactReaderConfig.java
================================================
package org.cftoolsuite.cfapp.config;

import java.util.Map;
import java.util.Set;

import org.cftoolsuite.cfapp.util.JarSetFilterReader;
import org.cftoolsuite.cfapp.util.JarSetFilterReaderCondition;
import org.cftoolsuite.cfapp.util.JavaArtifactReader;
import org.cftoolsuite.cfapp.util.MavenPomReader;
import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Conditional;
import org.springframework.context.annotation.Configuration;

@Configuration
public class JavaArtifactReaderConfig {

    @Configuration
    @ConditionalOnProperty(prefix = "java.artifacts.fetch", name= "mode", havingValue="unpack-pom-contents-in-droplet")
    static class MavenPomReaderConfig {

        @Bean
        public JavaArtifactReader mavenPomReader() {
            return new MavenPomReader(
                Set.of(
                    "org.springframework",
                    "io.pivotal.spring.cloud"
                ),
                true
            );
        }
    }

    @Configuration
    @Conditional(JarSetFilterReaderCondition.class)
    static class JarSetFilterReaderConfig {

        @Bean
        public JavaArtifactReader jarSetFilterReader() {
            return new JarSetFilterReader(
                Map.of(
                    "spring-core", "org.springframework",
                    "spring-boot", "org.springframework.boot",
                    "spring-cloud-context", "org.springframework.cloud",
                    "spring-data-commons", "org.springframework.data"
                )
            );
        }
    }

}


================================================
File: src/main/java/org/cftoolsuite/cfapp/config/NotifierConfig.java
================================================
package org.cftoolsuite.cfapp.config;

import org.cftoolsuite.cfapp.notifier.EmailNotifier;
import org.cftoolsuite.cfapp.notifier.JavaMailNotifier;
import org.cftoolsuite.cfapp.notifier.SendGridNotifier;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.boot.autoconfigure.EnableAutoConfiguration;
import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
import org.springframework.boot.autoconfigure.mail.MailSenderAutoConfiguration;
import org.springframework.boot.autoconfigure.sendgrid.SendGridAutoConfiguration;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.mail.javamail.JavaMailSender;

import com.sendgrid.SendGrid;

@Configuration
public class NotifierConfig {

    @Configuration
    @ConditionalOnProperty(prefix="notification", name="engine", havingValue="java-mail")
    @EnableAutoConfiguration(exclude = { SendGridAutoConfiguration.class })
    static class MailConfig {

        @Bean
        public EmailNotifier javaMailNotifier(@Value("${email.template.path:}") String customTemplatePath, JavaMailSender javaMailSender) {
            return new JavaMailNotifier(customTemplatePath, javaMailSender);
        }
    }

    @Configuration
    @ConditionalOnProperty(prefix="notification", name="engine", havingValue="none", matchIfMissing=true)
    @EnableAutoConfiguration(exclude = { MailSenderAutoConfiguration.class, SendGridAutoConfiguration.class })
    static class NoMailConfig {}

    @Configuration
    @ConditionalOnProperty(prefix="notification", name="engine", havingValue="sendgrid")
    @EnableAutoConfiguration(exclude = { MailSenderAutoConfiguration.class })
    static class SendGridConfig {

        @Bean
        public EmailNotifier sendGridNotifier(@Value("${email.template.path:}") String customTemplatePath, SendGrid sendGrid) {
            return new SendGridNotifier(customTemplatePath, sendGrid);
        }
    }
}


================================================
File: src/main/java/org/cftoolsuite/cfapp/config/OpsmanSettings.java
================================================
package org.cftoolsuite.cfapp.config;

import org.cloudfoundry.uaa.tokens.GrantType;
import org.springframework.boot.context.properties.ConfigurationProperties;

import lombok.Data;

@Data
@ConfigurationProperties(prefix = "om")
public class OpsmanSettings {

    private String apiHost;
    private String clientId = "opsman";
    private String clientSecret = "";
    private String username;
    private String password;
    private GrantType grantType = GrantType.PASSWORD;
    private boolean enabled;

}


================================================
File: src/main/java/org/cftoolsuite/cfapp/config/PasSettings.java
================================================
package org.cftoolsuite.cfapp.config;

import java.time.Duration;
import java.util.Collections;
import java.util.HashSet;
import java.util.Optional;
import java.util.Set;
import java.util.stream.Collectors;

import org.apache.commons.lang3.StringUtils;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.util.CollectionUtils;

import lombok.Data;

@Data
@ConfigurationProperties(prefix = "cf")
public class PasSettings {

    public static final String SYSTEM_ORG = "system";
    private static final Set<String> DEFAULT_ORG_BLACKLIST = Set.of(SYSTEM_ORG);
    private static final Set<String> DEFAULT_SPACE_BLACKLIST = Collections.emptySet();
    private static final String[] KNOWN_BUILDPACKS = "apt,binary,clojure,dotnet,elixir,emberjs,erlang,go,haskell,hwc,java,jboss,jetty,liberty,markdown,mendix,meta,meteor,nginx,nodejs,php,pyspark,python,r_buildpack,ruby,rust,staticfile,swift,tc,tomcat,tomee,virgo,weblogic".split(",");
    private static final Set<String> DEFAULT_BUILDPACKS = Set.of(KNOWN_BUILDPACKS);
    // user accounts are typically email addresses, so we'll define a regex to match on recognizable email pattern
    // @see https://howtodoinjava.com/regex/java-regex-validate-email-address/
    private static final String DEFAULT_ACCOUNT_REGEX = "^[a-zA-Z0-9_!#$%&’*+/=?`{|}~^-]+(?:\\.[a-zA-Z0-9_!#$%&’*+/=?`{|}~^-]+)*@[a-zA-Z0-9-]+(?:\\.[a-zA-Z0-9-]+)*$";

    private String apiHost;
    private Set<String> buildpacks = DEFAULT_BUILDPACKS;
    private boolean sslValidationSkipped;
    private Integer connectionPoolSize;
    private String connectionTimeout;
    private String username;
    private String password;
    private String tokenProvider = "userpass";
    // this is the value of RefreshToken within ~/.cf/config.json after one authenticates w/ cf login -a {api_endpoint} -sso
    private String refreshToken;
    private String accountRegex;
    private Set<String> organizationBlackList = DEFAULT_ORG_BLACKLIST;
    private Set<String> spaceBlackList = DEFAULT_SPACE_BLACKLIST;
    private Duration timeout = Duration.ofSeconds(10);


    public String getAccountRegex() {
        return StringUtils.isNotBlank(accountRegex) ? accountRegex: DEFAULT_ACCOUNT_REGEX;
    }

    public String getAppsDomain() {
        return "https://" + getApiHost().replace("api.", "apps.");
    }

    public String getBuildpack(String input) {
        String result = null;
        if (StringUtils.isNotBlank(input)) {// detect and standardize reporting of Buildpack, otherwise use input
            Optional<String> buildpack =
                    getBuildpacks()
                    .stream()
                    .filter(b -> input.contains(b))
                    .collect(Collectors.reducing((a, b) -> null));
            result = buildpack.orElse(input);
        }
        return result;
    }

    public Set<String> getBuildpacks() {
        while (buildpacks.remove(""));
        Set<String> nonEmptyBuildpacks = CollectionUtils.isEmpty(buildpacks) ?
                DEFAULT_BUILDPACKS: buildpacks;
        return merge(nonEmptyBuildpacks, DEFAULT_BUILDPACKS);
    }

    public Set<String> getOrganizationBlackList() {
        while (organizationBlackList.remove(""));
        Set<String> nonEmptyBlacklist = CollectionUtils.isEmpty(organizationBlackList) ?
                DEFAULT_ORG_BLACKLIST: organizationBlackList;
        return merge(nonEmptyBlacklist, DEFAULT_ORG_BLACKLIST);
    }

    public Set<String> getSpaceBlackList() {
        while(spaceBlackList.remove(""));
        return CollectionUtils.isEmpty(spaceBlackList) ? DEFAULT_SPACE_BLACKLIST: spaceBlackList;
    }

    public boolean hasSpaceBlackList() {
        return !CollectionUtils.isEmpty(getSpaceBlackList());
    }

    public String getUsageDomain() {
        return "https://" + getApiHost().replace("api.", "app-usage.");
    }

    private Set<String> merge(Set<String> source, Set<String> defaultList) {
        Set<String> result = new HashSet<>();
        result.addAll(source);
        result.addAll(defaultList);
        return result;
    }

}


================================================
File: src/main/java/org/cftoolsuite/cfapp/config/PivnetSettings.java
================================================
package org.cftoolsuite.cfapp.config;

import org.springframework.boot.context.properties.ConfigurationProperties;

import lombok.Data;

@Data
@ConfigurationProperties(prefix = "pivnet")
public class PivnetSettings {

    private String apiToken;
    private boolean enabled;
}


================================================
File: src/main/java/org/cftoolsuite/cfapp/config/R2dbcConfig.java
================================================
package org.cftoolsuite.cfapp.config;

import java.net.URI;
import java.util.Arrays;
import java.util.List;

import org.cftoolsuite.cfapp.domain.CustomConverters;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.autoconfigure.r2dbc.R2dbcProperties;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.core.env.Environment;
import org.springframework.data.r2dbc.config.AbstractR2dbcConfiguration;
import org.springframework.util.StringUtils;

import io.pivotal.cfenv.jdbc.CfJdbcEnv;
import io.pivotal.cfenv.jdbc.CfJdbcService;
import io.r2dbc.spi.ConnectionFactories;
import io.r2dbc.spi.ConnectionFactory;
import io.r2dbc.spi.ConnectionFactoryOptions;
import io.r2dbc.spi.Option;
import lombok.extern.slf4j.Slf4j;

@Slf4j
@Configuration
public class R2dbcConfig extends AbstractR2dbcConfiguration {

    private static final List<String> SUPPORTED_SCHEMES = Arrays.asList(new String[] { "mysql", "postgresql"});
    private static final String VCAP_SERVICE = "cf-butler-backend";

    private Environment environment;
    private R2dbcProperties r2dbcProperties;
    private PasSettings settings;

    @Autowired
    public void setEnvironment(Environment environment) {
        this.environment = environment;
    }

    @Autowired
    public void setR2dbcProperties(R2dbcProperties r2dbcProperties) {
        this.r2dbcProperties = r2dbcProperties;
    }

    @Autowired
    public void setSettings(PasSettings settings) {
        this.settings = settings;
    }

    @Bean
    public ConnectionFactory connectionFactory() {
        R2dbcProperties properties = r2dbcProperties(this.environment);
        ConnectionFactoryOptions.Builder builder = ConnectionFactoryOptions
                .parse(properties.getUrl()).mutate();
        String username = properties.getUsername();
        if (StringUtils.hasText(username)) {
            builder.option(ConnectionFactoryOptions.USER, username);
        }
        String password = properties.getPassword();
        if (StringUtils.hasText(password)) {
            builder.option(ConnectionFactoryOptions.PASSWORD, password);
        }
        String databaseName = properties.getName();
        if (StringUtils.hasText(databaseName)) {
            builder.option(ConnectionFactoryOptions.DATABASE, databaseName);
        }
        if (properties.getProperties() != null) {
            properties.getProperties()
                .forEach((key, value) -> builder
                    .option(Option.valueOf(key), value));
        }
        return ConnectionFactories.get(builder.build());
    }

    // support for external R2DBC source is limited to providers that support URI scheme
    private R2dbcProperties r2dbcProperties(Environment environment) {
        try {
            CfJdbcService service = null;
            if (Arrays.stream(environment.getActiveProfiles()).anyMatch(
                env -> env.equalsIgnoreCase("cloud"))) {
                    CfJdbcEnv cfJdbcEnv = new CfJdbcEnv();
                    service = cfJdbcEnv.findJdbcServiceByName(VCAP_SERVICE);
            }
            URI uri = service.getCredentials().getUriInfo().getUri();
            String scheme = uri.getScheme();
            log.info("Attempting to connect to a {} database instance.", scheme);
            if (scheme.startsWith("postgres")) {
                scheme = "postgresql";
            }
            if (SUPPORTED_SCHEMES.contains(scheme)) {
                R2dbcProperties r2dbcProperties = new R2dbcProperties();
                r2dbcProperties.setName(uri.getPath().replaceAll("/",""));
                String[] userInfoParts = uri.getUserInfo().split(":");
                String username = userInfoParts[0];
                String password = userInfoParts[1];
                r2dbcProperties.setUsername(username);
                r2dbcProperties.setPassword(password);
                StringBuilder builder = new StringBuilder();
                builder.append(String.format("r2dbc:pool:%s://", scheme));
                builder.append(uri.getHost());
                if (uri.getPort() != -1) {
                    builder.append(":" + uri.getPort());
                }
                builder.append(uri.getPath());
                r2dbcProperties.setUrl(builder.toString());
                if (scheme.startsWith("mysql")) {
                    if (settings.isSslValidationSkipped()) {
                        r2dbcProperties.getProperties().put("sslMode", "disabled");
                    }
                }
                return r2dbcProperties;
            } else {
                throw new IllegalStateException(String.format("Could not initialize R2dbcProperties. Service instance was found with scheme {} but it is not supported. Supported schemes are {}.", uri.getScheme(), SUPPORTED_SCHEMES));
            }
        } catch (IllegalArgumentException iae) {
            log.info("No bound service instance named {} was found. Falling back to embedded database.", VCAP_SERVICE);
            return this.r2dbcProperties;
        } catch (NullPointerException npe) {
            log.info("Not running on Cloud Foundry.");
            return this.r2dbcProperties;
        }
    }

    protected List<Object> getCustomConverters() {
        return CustomConverters.get();
    }

}


================================================
File: src/main/java/org/cftoolsuite/cfapp/config/WebClientConfig.java
================================================
package org.cftoolsuite.cfapp.config;

import javax.net.ssl.SSLException;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.http.client.reactive.ReactorClientHttpConnector;
import org.springframework.web.reactive.function.client.WebClient;
import org.springframework.web.reactive.function.client.ExchangeStrategies;

import io.netty.handler.ssl.SslContext;
import io.netty.handler.ssl.SslContextBuilder;
import io.netty.handler.ssl.util.InsecureTrustManagerFactory;
import reactor.netty.http.client.HttpClient;

@Configuration
public class WebClientConfig {

    // @see https://stackoverflow.com/questions/45418523/spring-5-webclient-using-ssl/53147631#53147631

    @Bean
    @ConditionalOnProperty(name = "cf.sslValidationSkipped", havingValue="true")
    public WebClient insecureWebClient(
        WebClient.Builder builder,
        @Value("${spring.codec.max-in-memory-size}") Integer maxInMemorySize) throws SSLException {
        SslContext context =
            SslContextBuilder
                .forClient()
                .trustManager(InsecureTrustManagerFactory.INSTANCE)
                .build();
        HttpClient httpClient =
            HttpClient
                .create()
                .secure(t -> t.sslContext(context))
                .followRedirect(true);
        return
            builder
                .exchangeStrategies(
                    ExchangeStrategies
                        .builder()
                        .codecs(
                            configurer ->
                                configurer
                                    .defaultCodecs()
                                    .maxInMemorySize(maxInMemorySize)
                        )
                        .build()
                )
                .clientConnector(new ReactorClientHttpConnector(httpClient))
                .build();
    }

    @Bean
    @ConditionalOnProperty(name = "cf.sslValidationSkipped", havingValue="false", matchIfMissing=true)
    public WebClient secureWebClient(
        WebClient.Builder builder,
        @Value("${spring.codec.max-in-memory-size}") Integer maxInMemorySize) {
        HttpClient httpClient =
            HttpClient
                .create()
                .followRedirect(true);
        return
            builder
                .exchangeStrategies(
                    ExchangeStrategies
                        .builder()
                        .codecs(
                            configurer ->
                                configurer
                                    .defaultCodecs()
                                    .maxInMemorySize(maxInMemorySize)
                        )
                        .build()
                )
                .clientConnector(
                    new ReactorClientHttpConnector(httpClient)
                )
                .build();
    }
}


================================================
File: src/main/java/org/cftoolsuite/cfapp/controller/DbmsOnlyPoliciesController.java
================================================
package org.cftoolsuite.cfapp.controller;

import org.cftoolsuite.cfapp.domain.Policies;
import org.cftoolsuite.cfapp.service.PoliciesService;
import org.cftoolsuite.cfapp.util.DbmsOnlyCondition;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Conditional;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RestController;

import reactor.core.publisher.Mono;

@RestController
@Conditional(DbmsOnlyCondition.class)
public class DbmsOnlyPoliciesController {

    private final PoliciesService policiesService;

    @Autowired
    public DbmsOnlyPoliciesController(
            PoliciesService policiesService) {
        this.policiesService = policiesService;
    }

    @DeleteMapping("/policies")
    public Mono<ResponseEntity<Void>> deleteAllPolicies() {
        return policiesService.deleteAll()
                .map(ResponseEntity::ok);
    }

    @DeleteMapping("/policies/application/{id}")
    public Mono<ResponseEntity<Void>> deleteApplicationPolicy(@PathVariable String id) {
        return policiesService.deleteApplicationPolicyById(id)
                .map(ResponseEntity::ok);
    }

    @DeleteMapping("/policies/endpoint/{id}")
    public Mono<ResponseEntity<Void>> deleteEndpointPolicy(@PathVariable String id) {
        return policiesService.deleteEndpointPolicyById(id)
                .map(ResponseEntity::ok);
    }

    @DeleteMapping("/policies/hygiene/{id}")
    public Mono<ResponseEntity<Void>> deleteHygienePolicy(@PathVariable String id) {
        return policiesService.deleteHygienePolicyById(id)
                .map(ResponseEntity::ok);
    }

    @DeleteMapping("/policies/resourcenotification/{id}")
    public Mono<ResponseEntity<Void>> deleteResourceNotificationPolicy(@PathVariable String id) {
        return policiesService.deleteResourceNotificationPolicyById(id)
                .map(ResponseEntity::ok);
    }

    @DeleteMapping("/policies/legacy/{id}")
    public Mono<ResponseEntity<Void>> deleteLegacyPolicy(@PathVariable String id) {
        return policiesService.deleteLegacyPolicyById(id)
                .map(ResponseEntity::ok);
    }

    @DeleteMapping("/policies/query/{id}")
    public Mono<ResponseEntity<Void>> deleteQueryPolicy(@PathVariable String id) {
        return policiesService.deleteQueryPolicyById(id)
                .map(ResponseEntity::ok);
    }

    @DeleteMapping("/policies/serviceInstance/{id}")
    public Mono<ResponseEntity<Void>> deleteServiceInstancePolicy(@PathVariable String id) {
        return policiesService.deleteServiceInstancePolicyById(id)
                .map(ResponseEntity::ok);
    }

    @PostMapping("/policies")
    public Mono<ResponseEntity<Policies>> establishPolicies(@RequestBody Policies policies) {
        return policiesService.save(policies)
                .map(ResponseEntity::ok);
    }
}


================================================
File: src/main/java/org/cftoolsuite/cfapp/controller/DemographicsController.java
================================================
package org.cftoolsuite.cfapp.controller;

import org.cftoolsuite.cfapp.domain.Demographics;
import org.cftoolsuite.cfapp.service.DemographicsService;
import org.cftoolsuite.cfapp.service.TimeKeeperService;
import org.cftoolsuite.cfapp.service.TkServiceUtil;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

import reactor.core.publisher.Mono;

@RestController
public class DemographicsController {

    private final DemographicsService demoService;
    private final TkServiceUtil util;

    @Autowired
    public DemographicsController(
            DemographicsService demoService,
            TimeKeeperService tkService
            ) {
        this.demoService = demoService;
        this.util = new TkServiceUtil(tkService);
    }

    @GetMapping("/snapshot/demographics")
    public Mono<ResponseEntity<Demographics>> getDemographics() {
        return util.getHeaders()
                .flatMap(h -> demoService
                        .getDemographics()
                        .map(d -> new ResponseEntity<>(d, h, HttpStatus.OK)))
                .defaultIfEmpty(ResponseEntity.notFound().build());
    }
}


================================================
File: src/main/java/org/cftoolsuite/cfapp/controller/DormantWorkloadsController.java
================================================
package org.cftoolsuite.cfapp.controller;

import org.cftoolsuite.cfapp.domain.Workloads;
import org.cftoolsuite.cfapp.domain.Workloads.WorkloadsBuilder;
import org.cftoolsuite.cfapp.service.DormantWorkloadsService;
import org.cftoolsuite.cfapp.service.TimeKeeperService;
import org.cftoolsuite.cfapp.service.TkServiceUtil;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RestController;

import reactor.core.publisher.Mono;

@RestController
public class DormantWorkloadsController {

    private final DormantWorkloadsService service;
    private final TkServiceUtil util;

    @Autowired
    public DormantWorkloadsController(
            DormantWorkloadsService service,
            TimeKeeperService tkService) {
        this.service = service;
        this.util = new TkServiceUtil(tkService);
    }

    @GetMapping(value = { "/snapshot/detail/dormant/{daysSinceLastUpdate}" } )
    public Mono<ResponseEntity<Workloads>> getDormantWorkloads(@PathVariable("daysSinceLastUpdate") Integer daysSinceLastUpdate) {
        final WorkloadsBuilder builder = Workloads.builder();
        return service
                .getDormantApplications(daysSinceLastUpdate)
                .map(list -> builder.applications(list))
                .then(service.getDormantServiceInstances(daysSinceLastUpdate))
                .map(list -> builder.serviceInstances(list))
                .flatMap(dwb -> util
                        .getHeaders()
                        .map(h -> new ResponseEntity<Workloads>(dwb.build(), h, HttpStatus.OK)))
                .defaultIfEmpty(ResponseEntity.notFound().build());
    }

}


================================================
File: src/main/java/org/cftoolsuite/cfapp/controller/HistoricalReportController.java
================================================
package org.cftoolsuite.cfapp.controller;

import java.time.Duration;
import java.time.LocalDate;

import org.cftoolsuite.cfapp.config.PasSettings;
import org.cftoolsuite.cfapp.event.HistoricalRecordRetrievedEvent;
import org.cftoolsuite.cfapp.report.HistoricalRecordCsvReport;
import org.cftoolsuite.cfapp.service.HistoricalRecordService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.format.annotation.DateTimeFormat;
import org.springframework.format.annotation.DateTimeFormat.ISO;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

import lombok.extern.slf4j.Slf4j;
import reactor.core.publisher.Mono;

@Slf4j
@RestController
public class HistoricalReportController {

    private final HistoricalRecordService historicalRecordService;
    private final HistoricalRecordCsvReport report;

    @Autowired
    public HistoricalReportController(
            PasSettings butlerSettings,
            HistoricalRecordService historicalRecordService) {
        this.historicalRecordService = historicalRecordService;
        this.report = new HistoricalRecordCsvReport(butlerSettings);
    }

    @GetMapping(value = { "/policies/report" }, produces = MediaType.TEXT_PLAIN_VALUE)
    public Mono<ResponseEntity<String>> generateReport(
            @DateTimeFormat(iso = ISO.DATE)
            @RequestParam(required = false, value = "start")
            LocalDate start,
            @DateTimeFormat(iso = ISO.DATE)
            @RequestParam(required = false, value = "end")
            LocalDate end) {
        Mono<ResponseEntity<String>> result = null;
        boolean hasDateRange = start != null && end != null;
        boolean hasValidDateRange = hasDateRange && start.isBefore(end);
        if (!hasDateRange) {
            result = historicalRecordService
                    .findAll()
                    .collectList()
                    .map(r ->
                    new HistoricalRecordRetrievedEvent(this)
                    .records(r)
                            )
                    .delayElement(Duration.ofMillis(500))
                    .map(e -> ResponseEntity.ok(
                            String.join(
                                    "\n\n",
                                    report.generatePreamble(),
                                    report.generateDetail(e))))
                    .defaultIfEmpty(ResponseEntity.notFound().build());
        } else if (hasValidDateRange) {
            result = historicalRecordService
                    .findByDateRange(start, end)
                    .collectList()
                    .map(r ->
                    new HistoricalRecordRetrievedEvent(this)
                    .records(r)
                            )
                    .delayElement(Duration.ofMillis(500))
                    .map(e -> ResponseEntity.ok(
                            String.join(
                                    "\n\n",
                                    report.generatePreamble(),
                                    report.generateDetail(e))))
                    .defaultIfEmpty(ResponseEntity.notFound().build());
        } else {
            log.error("The start date must be before end date when fetching historical records contrained by a date range.");
            result = Mono.just(ResponseEntity.badRequest().build());
        }
        return result;
    }
}


================================================
File: src/main/java/org/cftoolsuite/cfapp/controller/JavaAppDetailController.java
================================================
package org.cftoolsuite.cfapp.controller;

import java.util.Map;

import org.cftoolsuite.cfapp.service.JavaAppDetailService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;


@RestController
public class JavaAppDetailController {

    private JavaAppDetailService service;

    @Autowired
    public JavaAppDetailController(JavaAppDetailService service) {
        this.service = service;
    }

    @GetMapping("/snapshot/detail/ai/spring")
    public ResponseEntity<Flux<Map<String, String>>> getSpringApplications() {
        return
            ResponseEntity
                .ok()
                .body(service.findSpringApplications());
    }

    @GetMapping("/snapshot/summary/ai/spring")
    public ResponseEntity<Mono<Map<String, Integer>>> calculateSpringDependencyFrequency() {
        return
            ResponseEntity
                .ok()
                .body(service.calculateSpringDependencyFrequency());
    }

}


================================================
File: src/main/java/org/cftoolsuite/cfapp/controller/LegacyWorkloadsController.java
================================================
package org.cftoolsuite.cfapp.controller;

import org.cftoolsuite.cfapp.domain.Workloads;
import org.cftoolsuite.cfapp.domain.WorkloadsFilter;
import org.cftoolsuite.cfapp.domain.Workloads.WorkloadsBuilder;
import org.cftoolsuite.cfapp.service.LegacyWorkloadsService;
import org.cftoolsuite.cfapp.service.TimeKeeperService;
import org.cftoolsuite.cfapp.service.TkServiceUtil;
import org.cftoolsuite.cfapp.util.CsvUtil;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

import reactor.core.publisher.Mono;

@RestController
public class LegacyWorkloadsController {

    private final LegacyWorkloadsService service;
    private final TkServiceUtil util;

    @Autowired
    public LegacyWorkloadsController(
            LegacyWorkloadsService service,
            TimeKeeperService tkService) {
        this.service = service;
        this.util = new TkServiceUtil(tkService);
    }


    @GetMapping(value = { "/snapshot/detail/legacy" } )
    public Mono<ResponseEntity<Workloads>> getLegacyWorkloads(@RequestParam(value = "stacks", defaultValue = "", required = false) String stacks,
            @RequestParam(value = "service-offerings", defaultValue = "", required = false) String serviceOfferings
            ) {
        final WorkloadsBuilder builder = Workloads.builder();
        final WorkloadsFilter workloadsFilters = WorkloadsFilter.builder()
                .stacks(CsvUtil.parse(stacks))
                .serviceOfferings(CsvUtil.parse(serviceOfferings))
                .build();
        return service
                .getLegacyApplications(workloadsFilters)
                .map(list -> builder.applications(list))
                .then(service.getLegacyApplicationRelationships(workloadsFilters))
                .map(list -> builder.appRelationships(list))
                .flatMap(dwb -> util
                        .getHeaders()
                        .map(h -> new ResponseEntity<Workloads>(dwb.build(), h, HttpStatus.OK)))
                .defaultIfEmpty(ResponseEntity.notFound().build());
    }
}


================================================
File: src/main/java/org/cftoolsuite/cfapp/controller/OnDemandCollectorTriggerController.java
================================================
package org.cftoolsuite.cfapp.controller;

import org.cftoolsuite.cfapp.task.ProductsAndReleasesTask;
import org.cftoolsuite.cfapp.task.TkTask;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Profile;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RestController;

import reactor.core.publisher.Mono;

@Profile("on-demand")
@RestController
public class OnDemandCollectorTriggerController {

    @Autowired
    private TkTask tkCollector;

    @Autowired(required = false)
    private ProductsAndReleasesTask productsAndReleasesCollector;

    @PostMapping("/collect")
    public Mono<ResponseEntity<Void>> triggerCollection() {
        tkCollector.collect();
        if (productsAndReleasesCollector != null) {
            productsAndReleasesCollector.collect();
        }
        return Mono.just(ResponseEntity.accepted().build());
    }

}


================================================
File: src/main/java/org/cftoolsuite/cfapp/controller/OnDemandEventsController.java
================================================
package org.cftoolsuite.cfapp.controller;

import java.util.List;

import org.cftoolsuite.cfapp.domain.Event;
import org.cftoolsuite.cfapp.service.EventsService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Profile;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

import reactor.core.publisher.Mono;

@Profile("on-demand")
@RestController
public class OnDemandEventsController {

    private final EventsService service;

    @Autowired
    public OnDemandEventsController(EventsService service) {
        this.service = service;
    }

    @GetMapping("/events/{id}")
    public Mono<ResponseEntity<List<Event>>> getEvents(
            @PathVariable("id") String id,
            @RequestParam(value = "numberOfEvents", required = false) Integer numberOfEvents,
            // if you specify types[] they must be comma-separated
            @RequestParam(value = "types[]", required = false) String[] types
            ) {
        if (types == null) {
            return service
                    .getEvents(id, numberOfEvents)
                    .flatMapMany(json -> service.toFlux(json))
                    .collectList()
                    .map(ResponseEntity::ok)
                    .defaultIfEmpty(ResponseEntity.notFound().build());
        } else {
            return service
                    .getEvents(id, types)
                    .collectList()
                    .map(ResponseEntity::ok)
                    .defaultIfEmpty(ResponseEntity.notFound().build());
        }
    }

}


================================================
File: src/main/java/org/cftoolsuite/cfapp/controller/OnDemandPolicyTriggerController.java
================================================
package org.cftoolsuite.cfapp.controller;

import org.cftoolsuite.cfapp.service.PoliciesService;
import org.cftoolsuite.cfapp.task.PolicyExecutorTask;
import org.springframework.beans.factory.BeanFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Profile;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RestController;

import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

@Profile("on-demand")
@RestController
public class OnDemandPolicyTriggerController {

    private BeanFactory factory;
    private PoliciesService service;

    @Autowired
    public OnDemandPolicyTriggerController(BeanFactory factory, PoliciesService service) {
        this.factory = factory;
        this.service = service;
    }

    @PostMapping("/policies/execute")
    public Mono<ResponseEntity<Void>> triggerPolicyExecution() {
        return service.getTaskMap()
            .flatMapMany(taskTypeMap ->
                Flux.fromIterable(taskTypeMap.entrySet())
                    .flatMap(entry -> {
                        String policyId = entry.getKey();
                        Class<? extends PolicyExecutorTask> taskClass = entry.getValue();
                        PolicyExecutorTask task = factory.getBean(taskClass);
                        return Mono.fromRunnable(() -> task.execute(policyId));
                    }))
            .then(Mono.just(ResponseEntity.accepted().build()));
    }

}


================================================
File: src/main/java/org/cftoolsuite/cfapp/controller/OnDemandResourceMetadataController.java
================================================
package org.cftoolsuite.cfapp.controller;

import org.cftoolsuite.cfapp.domain.Metadata;
import org.cftoolsuite.cfapp.domain.Resource;
import org.cftoolsuite.cfapp.domain.Resources;
import org.cftoolsuite.cfapp.service.ResourceMetadataService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Profile;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PatchMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

import reactor.core.publisher.Mono;

@Profile("on-demand")
@RestController
public class OnDemandResourceMetadataController {

    private final ResourceMetadataService service;


    @Autowired
    public OnDemandResourceMetadataController(
            ResourceMetadataService service
            ) {
        this.service = service;
    }

    @GetMapping("/metadata/{type}")
    public Mono<ResponseEntity<Resources>> getResourcesMetadata(
    @PathVariable("type") String type,
    @RequestParam(value = "label_selector", required = false) String labelSelector,
    @RequestParam(value = "page", required = false) Integer page,
    @RequestParam(value = "per_page", required = false) Integer perPage
    ) {
        if (labelSelector != null){
            return service.getResources(type,labelSelector,page,perPage)
            .map(r -> ResponseEntity.ok(r))
            .defaultIfEmpty(ResponseEntity.notFound().build());
        }
        return service.getResources(type)
                        .map(r -> ResponseEntity.ok(r))
                        .defaultIfEmpty(ResponseEntity.notFound().build());
    }

    @GetMapping("/metadata/{type}/{id}")
    public Mono<ResponseEntity<Resource>> getResourceMetadata(
            @PathVariable("type") String type,
            @PathVariable("id") String id
            ) {
        return service.getResource(type, id)
                .map(ResponseEntity::ok)
                .defaultIfEmpty(ResponseEntity.notFound().build());
    }

    @PatchMapping("/metadata/{type}/{id}")
    public Mono<ResponseEntity<Metadata>> updateResourceMetadata(
            @PathVariable("type") String type,
            @PathVariable("id") String id,
            @RequestBody Metadata metadata
            ) {
        return service.updateResource(type, id, metadata)
                .map(ResponseEntity::ok)
                .defaultIfEmpty(ResponseEntity.notFound().build());
    }
}


================================================
File: src/main/java/org/cftoolsuite/cfapp/controller/OpsmanController.java
================================================
package org.cftoolsuite.cfapp.controller;

import java.util.List;

import org.cftoolsuite.cfapp.client.OpsmanClient;
import org.cftoolsuite.cfapp.domain.product.DeployedProduct;
import org.cftoolsuite.cfapp.domain.product.OmInfo;
import org.cftoolsuite.cfapp.domain.product.StemcellAssignments;
import org.cftoolsuite.cfapp.domain.product.StemcellAssociations;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

import reactor.core.publisher.Mono;

@RestController
@ConditionalOnProperty(name = "om.enabled", havingValue = "true")
public class OpsmanController {

    private final OpsmanClient client;

    @Autowired
    public OpsmanController(
            OpsmanClient client
            ) {
        this.client = client;
    }

    @GetMapping("/products/deployed")
    public Mono<ResponseEntity<List<DeployedProduct>>> getDeployedProducts() {
        return client
                .getDeployedProducts()
                .map(ResponseEntity::ok)
                .defaultIfEmpty(ResponseEntity.notFound().build());
    }

    @GetMapping("/products/om/info")
    public Mono<ResponseEntity<OmInfo>> getOmInfo() {
        return client
                .getOmInfo()
                .map(ResponseEntity::ok)
                .defaultIfEmpty(ResponseEntity.notFound().build());
    }

    @GetMapping("/products/stemcell/assignments")
    public Mono<ResponseEntity<StemcellAssignments>> getStemcellAssignments() {
        return client
                .getStemcellAssignments()
                .map(ResponseEntity::ok)
                .defaultIfEmpty(ResponseEntity.notFound().build());
    }

    @GetMapping("/products/stemcell/associations")
    public Mono<ResponseEntity<StemcellAssociations>> getStemcellAssociations() {
        return client
                .getStemcellAssociations()
                .map(ResponseEntity::ok)
                .defaultIfEmpty(ResponseEntity.notFound().build());
    }

}


================================================
File: src/main/java/org/cftoolsuite/cfapp/controller/OrganizationController.java
================================================
package org.cftoolsuite.cfapp.controller;

import java.util.List;

import org.cftoolsuite.cfapp.domain.Organization;
import org.cftoolsuite.cfapp.service.OrganizationService;
import org.cftoolsuite.cfapp.service.TimeKeeperService;
import org.cftoolsuite.cfapp.service.TkServiceUtil;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

import reactor.core.publisher.Mono;


@RestController
public class OrganizationController {

    private final OrganizationService organizationService;
    private final TkServiceUtil util;

    @Autowired
    public OrganizationController(
            OrganizationService organizationService,
            TimeKeeperService tkService) {
        this.organizationService = organizationService;
        this.util = new TkServiceUtil(tkService);
    }

    @GetMapping("/snapshot/organizations")
    public Mono<ResponseEntity<List<Organization>>> listAllOrganizations() {
        return util.getHeaders()
                .flatMap(h -> organizationService
                        .findAll()
                        .collectList()
                        .map(orgs -> new ResponseEntity<>(orgs, h, HttpStatus.OK)))
                .defaultIfEmpty(ResponseEntity.notFound().build());
    }

    @GetMapping("/snapshot/organizations/count")
    public Mono<ResponseEntity<Long>> organizationsCount() {
        return util.getHeaders()
                .flatMap(h -> organizationService
                        .findAll()
                        .count()
                        .map(count -> new ResponseEntity<>(count, h, HttpStatus.OK)))
                .defaultIfEmpty(ResponseEntity.ok(0L));
    }


}


================================================
File: src/main/java/org/cftoolsuite/cfapp/controller/PivnetController.java
================================================
package org.cftoolsuite.cfapp.controller;

import java.time.LocalDate;
import java.util.List;
import java.util.stream.Collectors;

import org.cftoolsuite.cfapp.domain.product.PivnetCache;
import org.cftoolsuite.cfapp.domain.product.Products;
import org.cftoolsuite.cfapp.domain.product.Release;
import org.cftoolsuite.cfapp.service.TimeKeeperService;
import org.cftoolsuite.cfapp.service.TkServiceUtil;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

import reactor.core.publisher.Mono;

@RestController
@ConditionalOnProperty(name = "pivnet.enabled", havingValue = "true")
public class PivnetController {

    private final PivnetCache cache;
    private final TkServiceUtil util;

    @Autowired
    public PivnetController(
            PivnetCache cache,
            TimeKeeperService tkService) {
        this.cache = cache;
        this.util = new TkServiceUtil(tkService);
    }

    @GetMapping("/store/product/releases")
    public Mono<ResponseEntity<List<Release>>> getLatestAvailableProductReleases(
            @RequestParam(name = "q", defaultValue = "latest") String option) {
        if (option.equalsIgnoreCase("latest")) {
            return util.getHeaders()
                    .map(h -> new ResponseEntity<>(cache.getLatestProductReleases(), h, HttpStatus.OK))
                    .defaultIfEmpty(ResponseEntity.notFound().build());
        } else if (option.equalsIgnoreCase("all")) {
            return util.getHeaders()
                    .map(h -> new ResponseEntity<>(cache.getAllProductReleases(), h, HttpStatus.OK))
                    .defaultIfEmpty(ResponseEntity.notFound().build());
        } else if (option.equalsIgnoreCase("recent")) {
            List<Release> recentReleases = cache
                    .getAllProductReleases()
                    .stream()
                    .filter(r -> r.getReleaseDate().isAfter(LocalDate.now().minusDays(7)))
                    .collect(Collectors.toList());
            return util.getHeaders()
                    .map(h -> new ResponseEntity<>(recentReleases, h, HttpStatus.OK))
                    .defaultIfEmpty(ResponseEntity.notFound().build());
        } else {
            return Mono.just(ResponseEntity.badRequest().build());
        }
    }

    @GetMapping("/store/product/catalog")
    public Mono<ResponseEntity<Products>> getProductList() {
        return util.getHeaders()
                .map(h -> new ResponseEntity<>(cache.getProducts(), h, HttpStatus.OK))
                .defaultIfEmpty(ResponseEntity.notFound().build());
    }

}


================================================
File: src/main/java/org/cftoolsuite/cfapp/controller/PoliciesController.java
================================================
package org.cftoolsuite.cfapp.controller;

import org.cftoolsuite.cfapp.domain.Policies;
import org.cftoolsuite.cfapp.service.PoliciesService;
import org.cftoolsuite.cfapp.task.PoliciesLoader;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RestController;

import reactor.core.publisher.Mono;

@RestController
public class PoliciesController {

    private final PoliciesService policiesService;
    private final PoliciesLoader policiesLoader;

    public PoliciesController(
            PoliciesService policiesService,
            @Autowired(required = false) PoliciesLoader policiesLoader
            ) {
        this.policiesService = policiesService;
        this.policiesLoader = policiesLoader;
    }

    @GetMapping(value = { "/policies" }, produces = MediaType.APPLICATION_JSON_VALUE)
    public Mono<ResponseEntity<Policies>> listAllPolicies() {
        return policiesService.findAll()
                .map(ResponseEntity::ok)
                .defaultIfEmpty(ResponseEntity.notFound().build());
    }

    @GetMapping(value = { "/policies/application/{id}" }, produces = MediaType.APPLICATION_JSON_VALUE)
    public Mono<ResponseEntity<Policies>> obtainApplicationPolicy(@PathVariable String id) {
        return policiesService.findApplicationPolicyById(id)
                .map(ResponseEntity::ok)
                .defaultIfEmpty(ResponseEntity.notFound().build());
    }

    @GetMapping(value = { "/policies/endpoint/{id}" }, produces = MediaType.APPLICATION_JSON_VALUE)
    public Mono<ResponseEntity<Policies>> obtainEndpointPolicy(@PathVariable String id) {
        return policiesService.findEndpointPolicyById(id)
                .map(ResponseEntity::ok)
                .defaultIfEmpty(ResponseEntity.notFound().build());
    }

    @GetMapping(value = { "/policies/hygiene/{id}" }, produces = MediaType.APPLICATION_JSON_VALUE)
    public Mono<ResponseEntity<Policies>> obtainHygienePolicy(@PathVariable String id) {
        return policiesService.findHygienePolicyById(id)
                .map(ResponseEntity::ok)
                .defaultIfEmpty(ResponseEntity.notFound().build());
    }

    @GetMapping(value = { "/policies/legacy/{id}" }, produces = MediaType.APPLICATION_JSON_VALUE)
    public Mono<ResponseEntity<Policies>> obtainLegacyPolicy(@PathVariable String id) {
        return policiesService.findLegacyPolicyById(id)
                .map(ResponseEntity::ok)
                .defaultIfEmpty(ResponseEntity.notFound().build());
    }

    @GetMapping(value = { "/policies/query/{id}" }, produces = MediaType.APPLICATION_JSON_VALUE)
    public Mono<ResponseEntity<Policies>> obtainQueryPolicy(@PathVariable String id) {
        return policiesService.findQueryPolicyById(id)
                .map(ResponseEntity::ok)
                .defaultIfEmpty(ResponseEntity.notFound().build());
    }

    @GetMapping(value = { "/policies/serviceInstance/{id}" }, produces = MediaType.APPLICATION_JSON_VALUE)
    public Mono<ResponseEntity<Policies>> obtainServiceInstancePolicy(@PathVariable String id) {
        return policiesService.findServiceInstancePolicyById(id)
                .map(ResponseEntity::ok)
                .defaultIfEmpty(ResponseEntity.notFound().build());
    }

    @PostMapping("policies/refresh")
    public Mono<ResponseEntity<Void>> refreshPolicies() {
        if (policiesLoader != null) {
            policiesLoader.load();
            return Mono.just(ResponseEntity.accepted().build());
        } else {
            return Mono.just(ResponseEntity.notFound().build());
        }
    }

}


================================================
File: src/main/java/org/cftoolsuite/cfapp/controller/PomFileExportController.java
================================================
package org.cftoolsuite.cfapp.controller;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.List;

import org.apache.commons.compress.archivers.tar.TarArchiveEntry;
import org.apache.commons.compress.archivers.tar.TarArchiveOutputStream;
import org.cftoolsuite.cfapp.domain.JavaAppDetail;
import org.cftoolsuite.cfapp.service.JavaAppDetailService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
import org.springframework.core.io.buffer.DataBuffer;
import org.springframework.core.io.buffer.DefaultDataBufferFactory;
import org.springframework.http.HttpHeaders;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

import lombok.extern.slf4j.Slf4j;
import reactor.core.publisher.Flux;


@Slf4j
@RestController
@ConditionalOnProperty(prefix = "java.artifacts.fetch", name= "mode", havingValue="unpack-pom-contents-in-droplet")
public class PomFileExportController {

    private JavaAppDetailService service;

    @Autowired
    public PomFileExportController(JavaAppDetailService service) {
        this.service = service;
    }

    @GetMapping("/download/pomfiles")
    public ResponseEntity<Flux<DataBuffer>> downloadDependenciesTarball() {
        String filename =
            String.format("%s-%s.tar.gz", "java-application-maven-pom-files", DateTimeFormatter.ofPattern("yyyy-MM-dd-HH-mm-ss").format(LocalDateTime.now()));
        Flux<DataBuffer> tarball =
            service
                .findAll()
                .collectList()
                .flatMapMany(list -> createTarGz(list));
        return
            ResponseEntity
                .ok()
                .header(HttpHeaders.CONTENT_DISPOSITION, "attachment; filename=\"" + filename + "\"")
                .contentType(MediaType.APPLICATION_OCTET_STREAM)
                .body(tarball);
    }

    private static Flux<DataBuffer> createTarGz(List<JavaAppDetail> appDetails) {
        Flux<DataBuffer> result = Flux.empty();
        try (
            ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();
            TarArchiveOutputStream tarOutput = new TarArchiveOutputStream(byteArrayOutputStream)) {
            for (JavaAppDetail appDetail : appDetails) {
                if (appDetail.getPomContents() != null && !appDetail.getPomContents().isEmpty()) {
                    String dirPath = String.format("%s/%s/%s", appDetail.getOrganization(), appDetail.getSpace(), appDetail.getAppName());
                    Path entryPath = Paths.get(dirPath, "pom.xml");
                    TarArchiveEntry entry = new TarArchiveEntry(entryPath.toString());
                    byte[] contentBytes = appDetail.getPomContents().getBytes();
                    entry.setSize(contentBytes.length);
                    tarOutput.putArchiveEntry(entry);
                    tarOutput.write(contentBytes);
                    tarOutput.closeArchiveEntry();
                }
            }
            tarOutput.finish();
            byte[] tarBytes = byteArrayOutputStream.toByteArray();
            DefaultDataBufferFactory factory = new DefaultDataBufferFactory();
            DataBuffer db = factory.wrap(tarBytes);
            result = Flux.just(db);
        } catch (IOException ioe) {
            log.error("Could not create Flux<DataBuffer>", ioe);
        }
        return result;
    }
}


================================================
File: src/main/java/org/cftoolsuite/cfapp/controller/ProductMetricsController.java
================================================
package org.cftoolsuite.cfapp.controller;

import org.cftoolsuite.cfapp.domain.product.ProductMetrics;
import org.cftoolsuite.cfapp.service.ProductMetricsService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.autoconfigure.condition.ConditionalOnExpression;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

import reactor.core.publisher.Mono;

@RestController
@ConditionalOnExpression(
        "${om.enabled:false} and ${pivnet.enabled:false}"
        )
public class ProductMetricsController {

    private final ProductMetricsService service;

    @Autowired
    public ProductMetricsController(ProductMetricsService service) {
        this.service = service;
    }

    @GetMapping("/products/metrics")
    public Mono<ResponseEntity<ProductMetrics>> getProductMetrics() {
        return service
                .getProductMetrics()
                .map(ResponseEntity::ok)
                .defaultIfEmpty(ResponseEntity.notFound().build());
    }

}


================================================
File: src/main/java/org/cftoolsuite/cfapp/controller/SnapshotController.java
================================================
package org.cftoolsuite.cfapp.controller;

import org.cftoolsuite.cfapp.domain.SnapshotDetail;
import org.cftoolsuite.cfapp.domain.SnapshotSummary;
import org.cftoolsuite.cfapp.service.SnapshotService;
import org.cftoolsuite.cfapp.service.TimeKeeperService;
import org.cftoolsuite.cfapp.service.TkServiceUtil;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

import reactor.core.publisher.Mono;

@RestController
public class SnapshotController {

    private final SnapshotService snapshotService;
    private final TkServiceUtil util;

    @Autowired
    public SnapshotController(
            SnapshotService snapshotService,
            TimeKeeperService tkService
            ) {
        this.snapshotService = snapshotService;
        this.util = new TkServiceUtil(tkService);
    }

    @GetMapping(value = { "/snapshot/detail/ai" }, produces = MediaType.TEXT_PLAIN_VALUE )
    public Mono<ResponseEntity<String>> getApplicationInstanceCsvReport() {
        return util.getTimeCollected()
                .flatMap(tc -> snapshotService
                        .assembleCsvAIReport(tc)
                        .map(ResponseEntity::ok))
                .defaultIfEmpty(ResponseEntity.notFound().build());
    }

    @GetMapping(value = { "/snapshot/detail/relations" }, produces = MediaType.TEXT_PLAIN_VALUE )
    public Mono<ResponseEntity<String>> getApplicationRelationshipsCsvReport() {
        return util.getTimeCollected()
                .flatMap(tc -> snapshotService
                        .assembleCsvRelationshipsReport(tc)
                        .map(ResponseEntity::ok))
                .defaultIfEmpty(ResponseEntity.notFound().build());
    }

    @GetMapping("/snapshot/detail")
    public Mono<ResponseEntity<SnapshotDetail>> getDetail() {
        return util.getHeaders()
                .flatMap(h -> snapshotService
                        .assembleSnapshotDetail()
                        .map(detail -> new ResponseEntity<SnapshotDetail>(detail, h, HttpStatus.OK)))
                .defaultIfEmpty(ResponseEntity.notFound().build());
    }

    @GetMapping(value = { "/snapshot/detail/si" }, produces = MediaType.TEXT_PLAIN_VALUE )
    public Mono<ResponseEntity<String>> getServiceInstanceCsvReport() {
        return util.getTimeCollected()
                .flatMap(tc -> snapshotService
                        .assembleCsvSIReport(tc)
                        .map(ResponseEntity::ok))
                .defaultIfEmpty(ResponseEntity.notFound().build());
    }

    @GetMapping("/snapshot/summary")
    public Mono<ResponseEntity<SnapshotSummary>> getSummary() {
        return util.getHeaders()
                .flatMap(h -> snapshotService
                        .assembleSnapshotSummary()
                        .map(summary -> new ResponseEntity<SnapshotSummary>(summary, h, HttpStatus.OK)))
                .defaultIfEmpty(ResponseEntity.notFound().build());
    }

    @GetMapping(value = { "/snapshot/detail/users" }, produces = MediaType.TEXT_PLAIN_VALUE )
    public Mono<ResponseEntity<String>> getUserAccountCsvReport() {
        return util.getTimeCollected()
                .flatMap(tc -> snapshotService
                        .assembleCsvUserAccountReport(tc)
                        .map(ResponseEntity::ok))
                .defaultIfEmpty(ResponseEntity.notFound().build());
    }
}


================================================
File: src/main/java/org/cftoolsuite/cfapp/controller/SpaceController.java
================================================
package org.cftoolsuite.cfapp.controller;

import java.util.List;

import org.cftoolsuite.cfapp.domain.Space;
import org.cftoolsuite.cfapp.service.SpaceService;
import org.cftoolsuite.cfapp.service.TimeKeeperService;
import org.cftoolsuite.cfapp.service.TkServiceUtil;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

import reactor.core.publisher.Mono;


@RestController
public class SpaceController {

    private final SpaceService spaceService;
    private final TkServiceUtil util;

    @Autowired
    public SpaceController(
            SpaceService spaceService,
            TimeKeeperService tkService) {
        this.spaceService = spaceService;
        this.util = new TkServiceUtil(tkService);
    }

    @GetMapping("/snapshot/spaces")
    public Mono<ResponseEntity<List<Space>>> listAllSpaces() {
        return util.getHeaders()
                .flatMap(h -> spaceService
                        .findAll()
                        .collectList()
                        .map(orgs -> new ResponseEntity<>(orgs, h, HttpStatus.OK)))
                .defaultIfEmpty(ResponseEntity.notFound().build());
    }

    @GetMapping("/snapshot/spaces/count")
    public Mono<ResponseEntity<Long>> spacesCount() {
        return util.getHeaders()
                .flatMap(h -> spaceService
                        .findAll()
                        .count()
                        .map(count -> new ResponseEntity<>(count, h, HttpStatus.OK)))
                .defaultIfEmpty(ResponseEntity.ok(0L));
    }


}


================================================
File: src/main/java/org/cftoolsuite/cfapp/controller/SpaceUsersController.java
================================================
package org.cftoolsuite.cfapp.controller;

import java.util.List;

import org.cftoolsuite.cfapp.domain.SpaceUsers;
import org.cftoolsuite.cfapp.service.SpaceUsersService;
import org.cftoolsuite.cfapp.service.TimeKeeperService;
import org.cftoolsuite.cfapp.service.TkServiceUtil;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RestController;

import reactor.core.publisher.Mono;

@RestController
public class SpaceUsersController {

    private final SpaceUsersService service;
    private final TkServiceUtil util;

    @Autowired
    public SpaceUsersController(
            SpaceUsersService service,
            TimeKeeperService tkService) {
        this.service = service;
        this.util = new TkServiceUtil(tkService);
    }

    @GetMapping("/snapshot/users")
    public Mono<ResponseEntity<List<String>>> allAccountNames() {
        return util.getHeaders()
                .flatMap(h -> service.obtainAccountNames()
                        .collectList()
                        .map(names -> new ResponseEntity<>(names, h, HttpStatus.OK)))
                .defaultIfEmpty(ResponseEntity.notFound().build());
    }

    @GetMapping(value = { "/snapshot/spaces/users" })
    public Mono<ResponseEntity<List<SpaceUsers>>> getAllSpaceUsers() {
        return util.getHeaders()
                .flatMap(h -> service
                        .findAll()
                        .collectList()
                        .map(users -> new ResponseEntity<>(users, h, HttpStatus.OK)))
                .defaultIfEmpty(ResponseEntity.notFound().build());
    }

    @GetMapping("/snapshot/{organization}/{space}/users")
    public Mono<ResponseEntity<SpaceUsers>> getUsersInOrganizationAndSpace(
            @PathVariable("organization") String organization,
            @PathVariable("space") String space) {
        return util.getHeaders()
                .flatMap(h -> service
                        .findByOrganizationAndSpace(organization, space)
                        .map(users -> new ResponseEntity<>(users, h, HttpStatus.OK)))
                .defaultIfEmpty(ResponseEntity.notFound().build());
    }

    @GetMapping("/snapshot/users/count")
    public Mono<ResponseEntity<Long>> totalAccounts() {
        return util.getHeaders()
                .flatMap(h -> service
                        .obtainAccountNames()
                        .count()
                        .map(c -> new ResponseEntity<>(c, h, HttpStatus.OK)))
                .defaultIfEmpty(ResponseEntity.ok(0L));
    }

}


================================================
File: src/main/java/org/cftoolsuite/cfapp/controller/TimeKeeperController.java
================================================
package org.cftoolsuite.cfapp.controller;

import java.time.format.DateTimeFormatter;

import org.cftoolsuite.cfapp.service.TimeKeeperService;
import org.cftoolsuite.cfapp.service.TkServiceUtil;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

import reactor.core.publisher.Mono;

@RestController
public class TimeKeeperController {

    private final TkServiceUtil util;

    @Autowired
    public TimeKeeperController(
            TimeKeeperService tkService
            ) {
        this.util = new TkServiceUtil(tkService);
    }

    @GetMapping(value = { "/collect" }, produces = MediaType.TEXT_PLAIN_VALUE )
    public Mono<ResponseEntity<String>> getCollectionTime() {
        return util.getTimeCollected()
                .map(r -> ResponseEntity.ok(DateTimeFormatter.ISO_LOCAL_DATE_TIME.format(r)))
                .defaultIfEmpty(ResponseEntity.notFound().build());
    }
}

================================================
File: src/main/java/org/cftoolsuite/cfapp/controller/UsageController.java
================================================
package org.cftoolsuite.cfapp.controller;

import java.time.LocalDate;

import org.cftoolsuite.cfapp.domain.accounting.application.AppUsageReport;
import org.cftoolsuite.cfapp.domain.accounting.service.ServiceUsageReport;
import org.cftoolsuite.cfapp.domain.accounting.task.TaskUsageReport;
import org.cftoolsuite.cfapp.service.UsageCache;
import org.cftoolsuite.cfapp.service.UsageService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.format.annotation.DateTimeFormat;
import org.springframework.format.annotation.DateTimeFormat.ISO;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RestController;

import reactor.core.publisher.Mono;

@RestController
public class UsageController {

    private final UsageCache cache;
    private final UsageService service;

    @Autowired
    public UsageController(
            UsageCache cache,
            UsageService service) {
        this.cache = cache;
        this.service = service;
    }

    @GetMapping(value = "/accounting/applications/{orgName}/{startDate}/{endDate}")
    public Mono<ResponseEntity<String>> getOrganizationApplicationUsageReport(
            @PathVariable("orgName") String organizationName,
            @DateTimeFormat(iso = ISO.DATE) @PathVariable("startDate") LocalDate startDate,
            @DateTimeFormat(iso = ISO.DATE) @PathVariable("endDate") LocalDate endDate
            ) {
        return service.getApplicationUsage(organizationName, startDate, endDate)
                .map(ResponseEntity::ok)
                .defaultIfEmpty(ResponseEntity.notFound().build());
    }

    @GetMapping(value = "/accounting/services/{orgName}/{startDate}/{endDate}")
    public Mono<ResponseEntity<String>> getOrganizationServiceUsageReport(
            @PathVariable("orgName") String organizationName,
            @DateTimeFormat(iso = ISO.DATE) @PathVariable("startDate") LocalDate startDate,
            @DateTimeFormat(iso = ISO.DATE) @PathVariable("endDate") LocalDate endDate
            ) {
        return service.getServiceUsage(organizationName, startDate, endDate)
                .map(ResponseEntity::ok)
                .defaultIfEmpty(ResponseEntity.notFound().build());
    }

    @GetMapping(value = "/accounting/tasks/{orgName}/{startDate}/{endDate}")
    public Mono<ResponseEntity<String>> getOrganizationTaskUsageReport(
            @PathVariable("orgName") String organizationName,
            @DateTimeFormat(iso = ISO.DATE) @PathVariable("startDate") LocalDate startDate,
            @DateTimeFormat(iso = ISO.DATE) @PathVariable("endDate") LocalDate endDate
            ) {
        return service.getTaskUsage(organizationName, startDate, endDate)
                .map(ResponseEntity::ok)
                .defaultIfEmpty(ResponseEntity.notFound().build());
    }

    @GetMapping(value = "/accounting/applications")
    public Mono<ResponseEntity<AppUsageReport>> getSystemWideApplicationUsageReport() {
        return Mono.justOrEmpty(cache.getApplicationReport())
                .map(ResponseEntity::ok)
                .defaultIfEmpty(ResponseEntity.notFound().build());
    }

    @GetMapping(value = "/accounting/services")
    public Mono<ResponseEntity<ServiceUsageReport>> getSystemWideServiceUsageReport() {
        return Mono.justOrEmpty(cache.getServiceReport())
                .map(ResponseEntity::ok)
                .defaultIfEmpty(ResponseEntity.notFound().build());
    }

    @GetMapping(value = "/accounting/tasks")
    public Mono<ResponseEntity<TaskUsageReport>> getSystemWideTaskUsageReport() {
        return Mono.justOrEmpty(cache.getTaskReport())
                .map(ResponseEntity::ok)
                .defaultIfEmpty(ResponseEntity.notFound().build());
    }

}


================================================
File: src/main/java/org/cftoolsuite/cfapp/controller/UserSpacesController.java
================================================
package org.cftoolsuite.cfapp.controller;

import org.cftoolsuite.cfapp.domain.UserSpaces;
import org.cftoolsuite.cfapp.service.TimeKeeperService;
import org.cftoolsuite.cfapp.service.TkServiceUtil;
import org.cftoolsuite.cfapp.service.UserSpacesService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RestController;

import reactor.core.publisher.Mono;

@RestController
public class UserSpacesController {

    private final UserSpacesService service;
    private final TkServiceUtil util;

    @Autowired
    public UserSpacesController(
            UserSpacesService service,
            TimeKeeperService tkService) {
        this.service = service;
        this.util = new TkServiceUtil(tkService);
    }

    @GetMapping(value = { "/snapshot/spaces/users/{name}" })
    public Mono<ResponseEntity<UserSpaces>> getSpacesForAccountName(@PathVariable("name") String name) {
        return util.getHeaders()
                .flatMap(h -> service
                        .getUserSpaces(name)
                        .map(userSpaces -> new ResponseEntity<>(userSpaces, h, HttpStatus.OK)))
                .defaultIfEmpty(ResponseEntity.notFound().build());
    }
}


================================================
File: src/main/java/org/cftoolsuite/cfapp/deser/RelaxedLocalDateDeserializer.java
================================================
package org.cftoolsuite.cfapp.deser;

import java.io.IOException;
import java.time.LocalDate;
import java.time.format.DateTimeParseException;

import org.apache.commons.lang3.StringUtils;

import com.fasterxml.jackson.core.JsonParser;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.DeserializationContext;
import com.fasterxml.jackson.databind.JsonDeserializer;
import com.fasterxml.jackson.databind.exc.InvalidFormatException;
import com.fasterxml.jackson.datatype.jsr310.deser.LocalDateDeserializer;

public class RelaxedLocalDateDeserializer extends JsonDeserializer<LocalDate> {

    private LocalDateDeserializer conformingDeserializer = LocalDateDeserializer.INSTANCE;

    @Override
    public LocalDate deserialize(JsonParser p, DeserializationContext ctxt) throws IOException, JsonProcessingException {
        try {
            return conformingDeserializer.deserialize(p, ctxt);
        } catch (InvalidFormatException | DateTimeParseException e) {
            String date = p.getText();
            String[] iso8601DateParts = date.split("-");
            if (StringUtils.isNotBlank(iso8601DateParts[0]) && iso8601DateParts[0].length() > 4) {
                return LocalDate.MAX;
            }
            throw new RuntimeException(e);
        }
    }
}


================================================
File: src/main/java/org/cftoolsuite/cfapp/domain/AppDetail.java
================================================
package org.cftoolsuite.cfapp.domain;

import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

import org.apache.commons.lang3.StringUtils;
import org.springframework.data.annotation.Id;
import org.springframework.data.relational.core.mapping.Table;

import com.fasterxml.jackson.annotation.JsonIgnore;

import lombok.Builder;
import lombok.Builder.Default;
import lombok.EqualsAndHashCode;
import lombok.Getter;
import lombok.ToString;

@Builder
@Getter
@EqualsAndHashCode
@ToString
@Table("application_detail")
public class AppDetail {

    @Id
    @JsonIgnore
    private Long pk;
    private String organization;
    private String space;
    private String appId;
    private String appName;
    private String buildpack;
    private String buildpackVersion;
    private String image;
    private String stack;
    private Integer runningInstances;
    private Integer totalInstances;
    private Long memoryUsed;
    private Long diskUsed;
    private Long memoryQuota;
    private Long diskQuota;
    private LocalDateTime lastPushed;
    private String lastEvent;
    private String lastEventActor;
    private LocalDateTime lastEventTime;
    private String requestedState;
    private String buildpackReleaseType;
    private LocalDateTime buildpackReleaseDate;
    private String buildpackLatestVersion;
    private String buildpackLatestUrl;
    @Default
    private List<String> urls = new ArrayList<>();

    public static AppDetailBuilder from(AppDetail detail) {
        return AppDetail
                .builder()
                .pk(detail.getPk())
                .organization(detail.getOrganization())
                .space(detail.getSpace())
                .appId(detail.getAppId())
                .appName(detail.getAppName())
                .buildpack(detail.getBuildpack())
                .buildpackVersion(detail.getBuildpackVersion())
                .image(detail.getImage())
                .stack(detail.getStack())
                .runningInstances(detail.getRunningInstances())
                .totalInstances(detail.getTotalInstances())
                .memoryUsed(detail.getMemoryUsed())
                .memoryQuota(detail.getMemoryQuota())
                .diskUsed(detail.getDiskUsed())
                .diskQuota(detail.getDiskQuota())
                .urls(detail.getUrls())
                .lastPushed(detail.getLastPushed())
                .lastEvent(detail.getLastEvent())
                .lastEventActor(detail.getLastEventActor())
                .lastEventTime(detail.getLastEventTime())
                .requestedState(detail.getRequestedState())
                .buildpackReleaseType(detail.getBuildpackReleaseType())
                .buildpackReleaseDate(detail.getBuildpackReleaseDate())
                .buildpackLatestVersion(detail.getBuildpackLatestVersion())
                .buildpackLatestUrl(detail.getBuildpackLatestUrl());
    }

    public static String headers() {
        return String.join(",", "organization", "space", "application id", "application name", "buildpack", "buildpack version", "image",
                "stack", "running instances", "total instances", "memory used (in gb)", "memory quota (in gb)", "disk used (in gb)", "disk quota (in gb)", "urls", "last pushed", "last event",
                "last event actor", "last event time", "requested state",
                "latest buildpack release type", "latest buildpack release date", "latest buildpack version", "latest buildpack Url" );
    }

    private static String wrap(String value) {
        return value != null ? StringUtils.wrap(value, '"') : StringUtils.wrap("", '"');
    }

    public String toCsv() {
        return String.join(",", wrap(getOrganization()), wrap(getSpace()), wrap(getAppId()), wrap(getAppName()),
                wrap(getBuildpack()), wrap(getBuildpackVersion()), wrap(getImage()), wrap(getStack()), wrap(String.valueOf(getRunningInstances())),
                wrap(String.valueOf(getTotalInstances())), wrap(Double.toString(toGigabytes(getMemoryUsed()))), wrap(Double.toString(toGigabytes(getMemoryQuota()))),
                wrap(Double.toString(toGigabytes(getDiskUsed()))), wrap(Double.toString(toGigabytes(getDiskQuota()))),
                (wrap(String.join(",", getUrls() != null ? getUrls(): Collections.emptyList()))),
                wrap(getLastPushed() != null ? getLastPushed().toString() : ""), wrap(getLastEvent()),
                wrap(getLastEventActor()), wrap(getLastEventTime() != null ? getLastEventTime().toString() : ""),
                wrap(getRequestedState()),
                wrap(getBuildpackReleaseType()),
                wrap(getBuildpackReleaseDate() != null ? getBuildpackReleaseDate().toString() : ""),
                wrap(getBuildpackLatestVersion()),
                wrap(getBuildpackLatestUrl()));
    }

    private Double toGigabytes(Long input) {
        return Double.valueOf(input / Math.pow(1024, 3));
    }
}


================================================
File: src/main/java/org/cftoolsuite/cfapp/domain/AppDetailReadConverter.java
================================================
package org.cftoolsuite.cfapp.domain;

import java.time.LocalDateTime;

import org.springframework.core.convert.converter.Converter;
import org.springframework.data.convert.ReadingConverter;
import org.springframework.stereotype.Indexed;

import io.r2dbc.spi.Row;

@Indexed
@ReadingConverter
public class AppDetailReadConverter implements Converter<Row, AppDetail> {

    @Override
    public AppDetail convert(Row source) {
        return
                AppDetail
                .builder()
                .pk(source.get("pk", Long.class))
                .organization(Defaults.getColumnValue(source, "organization", String.class))
                .space(Defaults.getColumnValue(source, "space", String.class))
                .appId(Defaults.getColumnValue(source, "app_id", String.class))
                .appName(Defaults.getColumnValue(source, "app_name", String.class))
                .buildpack(Defaults.getColumnValue(source, "buildpack", String.class))
                .buildpackVersion(Defaults.getColumnValue(source, "buildpack_version", String.class))
                .runningInstances(Defaults.getColumnValueOrDefault(source, "running_instances", Integer.class, 0))
                .totalInstances(Defaults.getColumnValueOrDefault(source, "total_instances", Integer.class, 0))
                .memoryUsed(Defaults.getColumnValueOrDefault(source, "memory_used", Long.class, 0L))
                .diskUsed(Defaults.getColumnValueOrDefault(source, "disk_used", Long.class, 0L))
                .memoryQuota(Defaults.getColumnValueOrDefault(source, "memory_quota", Long.class, 0L))
                .diskQuota(Defaults.getColumnValueOrDefault(source, "disk_quota", Long.class, 0L))
                .image(Defaults.getColumnValue(source, "image", String.class))
                .stack(Defaults.getColumnValue(source, "stack", String.class))
                .urls(Defaults.getColumnListOfStringValue(source, "urls"))
                .lastPushed(Defaults.getColumnValue(source, "last_pushed", LocalDateTime.class))
                .lastEventTime(Defaults.getColumnValue(source, "last_event_time", LocalDateTime.class))
                .lastEvent(Defaults.getColumnValue(source, "last_event", String.class))
                .lastEventActor(Defaults.getColumnValue(source, "last_event_actor", String.class))
                .requestedState(Defaults.getColumnValue(source, "requested_state", String.class))
                .buildpackReleaseType(Defaults.getColumnValue(source, "buildpack_release_type", String.class))
                .buildpackReleaseDate(Defaults.getColumnValue(source, "buildpack_release_date", LocalDateTime.class))
                .buildpackLatestVersion(Defaults.getColumnValue(source, "buildpack_latest_version", String.class))
                .buildpackLatestUrl(Defaults.getColumnValue(source, "buildpack_latest_url", String.class))
                .build();
    }
}



================================================
File: src/main/java/org/cftoolsuite/cfapp/domain/AppDetailWriteConverter.java
================================================
package org.cftoolsuite.cfapp.domain;

import java.time.LocalDateTime;
import java.util.stream.Collectors;

import org.apache.commons.lang3.StringUtils;
import org.springframework.core.convert.converter.Converter;
import org.springframework.data.convert.WritingConverter;
import org.springframework.data.r2dbc.mapping.OutboundRow;
import org.springframework.r2dbc.core.Parameter;
import org.springframework.stereotype.Indexed;

@Indexed
@WritingConverter
public class AppDetailWriteConverter implements Converter<AppDetail, OutboundRow> {

    @Override
    public OutboundRow convert(AppDetail source) {
        OutboundRow row = new OutboundRow();
        row.put("organization", Parameter.fromOrEmpty(source.getOrganization(), String.class));
        row.put("space", Parameter.fromOrEmpty(source.getSpace(), String.class));
        row.put("app_id", Parameter.fromOrEmpty(source.getAppId(), String.class));
        row.put("app_name", Parameter.fromOrEmpty(source.getAppName(), String.class));
        row.put("buildpack", Parameter.fromOrEmpty(source.getBuildpack(), String.class));
        row.put("buildpack_version", Parameter.fromOrEmpty(source.getBuildpackVersion(), String.class));
        row.put("running_instances", Parameter.fromOrEmpty(source.getRunningInstances(), Integer.class));
        row.put("total_instances", Parameter.fromOrEmpty(source.getTotalInstances(), Integer.class));
        row.put("memory_used", Parameter.fromOrEmpty(source.getMemoryUsed(), Long.class));
        row.put("disk_used", Parameter.fromOrEmpty(source.getDiskUsed(), Long.class));
        row.put("memory_quota", Parameter.fromOrEmpty(source.getMemoryQuota(), Long.class));
        row.put("disk_quota", Parameter.fromOrEmpty(source.getDiskQuota(), Long.class));
        row.put("image", Parameter.fromOrEmpty(source.getImage(), String.class));
        row.put("stack", Parameter.fromOrEmpty(source.getStack(), String.class));
        row.put("urls", Parameter.fromOrEmpty(source.getUrls().stream().filter(StringUtils::isNotBlank).collect(Collectors.joining(",")), String.class));
        row.put("last_pushed", Parameter.fromOrEmpty(source.getLastPushed(), LocalDateTime.class));
        row.put("last_event_time", Parameter.fromOrEmpty(source.getLastEventTime(), LocalDateTime.class));
        row.put("last_event", Parameter.fromOrEmpty(source.getLastEvent(), String.class));
        row.put("last_event_actor", Parameter.fromOrEmpty(source.getLastEventActor(), String.class));
        row.put("requested_state", Parameter.fromOrEmpty(source.getRequestedState(), String.class));
        row.put("buildpack_release_type", Parameter.fromOrEmpty(source.getBuildpackReleaseType(), String.class));
        row.put("buildpack_release_date", Parameter.fromOrEmpty(source.getBuildpackReleaseDate(), String.class));
        row.put("buildpack_latest_version", Parameter.fromOrEmpty(source.getBuildpackLatestVersion(), String.class));
        row.put("buildpack_latest_url", Parameter.fromOrEmpty(source.getBuildpackLatestUrl(), String.class));
        return row;
    }

}


================================================
File: src/main/java/org/cftoolsuite/cfapp/domain/AppRelationship.java
================================================
package org.cftoolsuite.cfapp.domain;

import org.apache.commons.lang3.StringUtils;
import org.springframework.data.annotation.Id;
import org.springframework.data.relational.core.mapping.Table;

import com.fasterxml.jackson.annotation.JsonIgnore;

import lombok.Builder;
import lombok.EqualsAndHashCode;
import lombok.Getter;
import lombok.ToString;

@Builder
@Getter
@EqualsAndHashCode
@ToString
@Table("application_relationship")
public class AppRelationship {

    public static String headers() {
        return String.join(",", "organization", "space", "application id",
                "application name", "service instance id", "service name", "service offering", "service plan", "service type");
    }
    private static String wrap(String value) {
        return value != null ? StringUtils.wrap(value, '"') : StringUtils.wrap("", '"');
    }
    @Id
    @JsonIgnore
    private Long pk;
    private String organization;
    private String space;
    private String appId;
    private String appName;
    private String serviceInstanceId;
    private String serviceName;
    private String serviceOffering;

    private String servicePlan;

    private String serviceType;

    public String toCsv() {
        return String.join(",", wrap(getOrganization()), wrap(getSpace()), wrap(getAppId()), wrap(getAppName()),
                wrap(getServiceInstanceId()), wrap(getServiceName()), wrap(getServiceOffering()), wrap(getServicePlan()), wrap(getServiceType()));
    }

}


================================================
File: src/main/java/org/cftoolsuite/cfapp/domain/AppRelationshipRequest.java
================================================
package org.cftoolsuite.cfapp.domain;

import java.util.ArrayList;
import java.util.List;

import lombok.Builder;
import lombok.Getter;

@Builder
@Getter
public class AppRelationshipRequest {

    public static List<AppRelationshipRequest> listOf(ServiceInstanceDetail detail) {
        List<AppRelationshipRequest> result = new ArrayList<>();
        detail.getApplications().forEach(a -> {
            result.add(AppRelationshipRequest
                    .builder()
                    .organization(detail.getOrganization())
                    .space(detail.getSpace())
                    .applicationName(a)
                    .serviceInstanceId(detail.getServiceInstanceId())
                    .serviceName(detail.getName())
                    .serviceOffering(detail.getService())
                    .serviceType(detail.getType())
                    .servicePlan(detail.getPlan())
                    .build());
        });
        return result;
    }
    private String organization;
    private String space;
    private String serviceInstanceId;
    private String serviceName;
    private String serviceOffering;
    private String applicationId;
    private String applicationName;
    private String serviceType;

    private String servicePlan;
}


================================================
File: src/main/java/org/cftoolsuite/cfapp/domain/ApplicationCounts.java
================================================
package org.cftoolsuite.cfapp.domain;

import java.util.HashMap;
import java.util.Map;

import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;

import lombok.Builder;
import lombok.Builder.Default;
import lombok.Getter;
import lombok.ToString;

@Builder
@Getter
@ToString
@JsonPropertyOrder({ "by-organization", "by-buildpack", "by-stack", "by-dockerimage", "by-status",
    "total-applications", "total-running-application-instances", "total-stopped-application-instances", "total-crashed-application-instances",
    "total-application-instances", "total-memory-used-in-gb", "total-disk-used-in-gb", "velocity"})
public class ApplicationCounts {

    @Default
    @JsonProperty("by-organization")
    private Map<String, Long> byOrganization = new HashMap<>();

    @Default
    @JsonProperty("by-buildpack")
    private Map<String, Long> byBuildpack = new HashMap<>();

    @Default
    @JsonProperty("by-stack")
    private Map<String, Long> byStack = new HashMap<>();

    @Default
    @JsonProperty("by-dockerimage")
    private Map<String, Long> byDockerImage = new HashMap<>();

    @Default
    @JsonProperty("by-status")
    private Map<String, Long> byStatus = new HashMap<>();

    @Default
    @JsonProperty("total-applications")
    private Long totalApplications = 0L;

    @Default
    @JsonProperty("total-running-application-instances")
    private Long totalRunningApplicationInstances = 0L;

    @Default
    @JsonProperty("total-stopped-application-instances")
    private Long totalStoppedApplicationInstances = 0L;

    @Default
    @JsonProperty("total-crashed-application-instances")
    private Long totalCrashedApplicationInstances = 0L;

    @Default
    @JsonProperty("total-application-instances")
    private Long totalApplicationInstances = 0L;

    @Default
    @JsonProperty("total-memory-used-in-gb")
    private Double totalMemoryUsed = 0.0;

    @Default
    @JsonProperty("total-disk-used-in-gb")
    private Double totalDiskUsed = 0.0;

    @Default
    @JsonProperty("velocity")
    private Map<String, Long> velocity = new HashMap<>();
}


================================================
File: src/main/java/org/cftoolsuite/cfapp/domain/ApplicationOperation.java
================================================
package org.cftoolsuite.cfapp.domain;

import java.util.Arrays;
import java.util.EnumMap;
import java.util.Map;
import java.util.stream.Collectors;

import org.cftoolsuite.cfapp.task.DeleteAppPolicyExecutorTask;
import org.cftoolsuite.cfapp.task.PolicyExecutorTask;
import org.cftoolsuite.cfapp.task.ScaleAppInstancesPolicyExecutorTask;
import org.cftoolsuite.cfapp.task.StackChangeAppInstancesPolicyExecutorTask;
import org.cftoolsuite.cfapp.task.StopAppPolicyExecutorTask;
import org.springframework.util.Assert;

import com.fasterxml.jackson.annotation.JsonValue;

public enum ApplicationOperation {

    DELETE("delete"),
    SCALE_INSTANCES("scale-instances"),
    STOP("stop"),
    CHANGE_STACK("change-stack");

    private final String name;

    ApplicationOperation(String name) {
        this.name = name;
    }

    static final Map<ApplicationOperation, Class<? extends PolicyExecutorTask>> operationTaskMap = new EnumMap<>(ApplicationOperation.class);
    static {
        operationTaskMap.put(ApplicationOperation.DELETE, DeleteAppPolicyExecutorTask.class);
        operationTaskMap.put(ApplicationOperation.SCALE_INSTANCES, ScaleAppInstancesPolicyExecutorTask.class);
        operationTaskMap.put(ApplicationOperation.STOP, StopAppPolicyExecutorTask.class);
        operationTaskMap.put(ApplicationOperation.CHANGE_STACK, StackChangeAppInstancesPolicyExecutorTask.class);
    }

    public static ApplicationOperation from(String name) {
        Assert.hasText(name, "ApplicationOperation must not be null or empty");
        ApplicationOperation result = Arrays.asList(ApplicationOperation.values()).stream().filter(s -> s.getName().equalsIgnoreCase(name)).collect(Collectors.toList()).get(0);
        Assert.notNull(result, String.format("Invalid ApplicationOperation, name=%s", name));
        return result;
    }

    public static Class<? extends PolicyExecutorTask> getTaskType(String op) {
        return operationTaskMap.get(from(op));
    }

    @JsonValue
    public String getName() {
        return name;
    }

}


================================================
File: src/main/java/org/cftoolsuite/cfapp/domain/ApplicationPolicy.java
================================================
package org.cftoolsuite.cfapp.domain;

import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;

import org.apache.commons.lang3.StringUtils;
import org.springframework.data.annotation.Id;
import org.springframework.data.relational.core.mapping.Column;
import org.springframework.data.relational.core.mapping.Table;
import org.springframework.util.Assert;
import org.springframework.util.CollectionUtils;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;
import com.fasterxml.uuid.Generators;

import lombok.Builder;
import lombok.Builder.Default;
import lombok.Getter;
import lombok.ToString;

@Builder
@JsonInclude(JsonInclude.Include.NON_NULL)
@JsonPropertyOrder({ "id", "git-commit", "operation", "description", "state", "options", "organization-whitelist", "cron-expression" })
@Getter
@ToString
@Table("application_policy")
public class ApplicationPolicy implements HasOrganizationWhiteList, Policy {

    public static ApplicationPolicy seed(ApplicationPolicy policy) {
        return ApplicationPolicy
                .builder()
                .cronExpression(policy.getCronExpression())
                .description(policy.getDescription())
                .operation(policy.getOperation())
                .options(policy.getOptions())
                .organizationWhiteList(policy.getOrganizationWhiteList())
                .state(policy.getState())
                .build();
    }

    public static ApplicationPolicy seedWith(ApplicationPolicy policy, String gitCommit) {
        return ApplicationPolicy
                .builder()
                .gitCommit(gitCommit)
                .cronExpression(policy.getCronExpression())
                .description(policy.getDescription())
                .operation(policy.getOperation())
                .options(policy.getOptions())
                .organizationWhiteList(policy.getOrganizationWhiteList())
                .state(policy.getState())
                .build();
    }

    @Id
    @JsonIgnore
    private Long pk;

    @Default
    @JsonProperty("id")
    private String id = Generators.timeBasedGenerator().generate().toString();

    @JsonProperty("git-commit")
    @Column("git_commit")
    private String gitCommit;

    @JsonProperty("operation")
    private String operation;

    @JsonProperty("description")
    private String description;

    @JsonProperty("state")
    private String state;

    @Default
    @JsonProperty("options")
    private Map<String, Object> options = new HashMap<>();

    @Default
    @JsonProperty("organization-whitelist")
    @Column("organization_whitelist")
    private Set<String> organizationWhiteList = new HashSet<>();

    @JsonProperty("cron-expression")
    @Column("cron_expression")
    private String cronExpression;

    @JsonCreator
    ApplicationPolicy(
            @JsonProperty("pk") Long pk,
            @JsonProperty("id") String id,
            @JsonProperty("git-commit") String gitCommit,
            @JsonProperty("operation") String operation,
            @JsonProperty("description") String description,
            @JsonProperty("state") String state,
            @JsonProperty("options") Map<String, Object> options,
            @JsonProperty("organization-whitelist") Set<String> organizationWhiteList,
            @JsonProperty("cron-expression") String cronExpression) {
        this.pk = pk;
        this.id = id;
        this.gitCommit = gitCommit;
        this.operation = operation;
        this.description = description;
        this.state = state;
        this.options = options;
        this.organizationWhiteList = organizationWhiteList;
        this.cronExpression = cronExpression;
    }

    @JsonIgnore
    public <T> T getOption(String key, Class<T> type) {
        Assert.isTrue(StringUtils.isNotBlank(key), "Option key must not be blank.");
        Object value = options.get(key);
        if (value == null) {
            return null;
        }
        return type.cast(value);
    }

    public String getCronExpression() {
        return StringUtils.isBlank(cronExpression) ? defaultCronExpression(): cronExpression;
    }

    public Map<String, Object> getOptions() {
        return CollectionUtils.isEmpty(options) ? new HashMap<>(): Collections.unmodifiableMap(options);
    }

    public Set<String> getOrganizationWhiteList() {
        return CollectionUtils.isEmpty(organizationWhiteList) ? new HashSet<>() : Collections.unmodifiableSet(organizationWhiteList);
    }

    @JsonIgnore
    public Long getPk() {
        return pk;
    }

}


================================================
File: src/main/java/org/cftoolsuite/cfapp/domain/ApplicationPolicyReadConverter.java
================================================
package org.cftoolsuite.cfapp.domain;

import java.io.IOException;
import java.util.Map;

import org.cftoolsuite.cfapp.util.CsvUtil;
import org.springframework.core.convert.converter.Converter;
import org.springframework.data.convert.ReadingConverter;
import org.springframework.stereotype.Indexed;

import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;

import io.r2dbc.spi.Row;

@Indexed
@ReadingConverter
public class ApplicationPolicyReadConverter implements Converter<Row, ApplicationPolicy> {

    private ObjectMapper mapper = new ObjectMapper();

    @Override
    public ApplicationPolicy convert(Row source) {
        return
                ApplicationPolicy
                .builder()
                .pk(source.get("pk", Long.class))
                .id(source.get("id", String.class))
                .gitCommit(source.get("git_commit", String.class))
                .operation(source.get("operation", String.class))
                .description(source.get("description", String.class))
                .options(readOptions(source.get("options", String.class) == null ? "{}" : source.get("options", String.class)))
                .organizationWhiteList(CsvUtil.parse(source.get("organization_whitelist", String.class)))
                .cronExpression(source.get("cron_expression", String.class))
                .state(source.get("state", String.class))
                .build();
    }

    private Map<String, Object> readOptions(String value) {
        try {
            return mapper.readValue(value, new TypeReference<Map<String, Object>>() {});
        } catch (IOException ioe) {
            throw new RuntimeException("Problem reading options", ioe);
        }
    }
}



================================================
File: src/main/java/org/cftoolsuite/cfapp/domain/ApplicationPolicyWriteConverter.java
================================================
package org.cftoolsuite.cfapp.domain;

import java.util.stream.Collectors;

import org.apache.commons.lang3.StringUtils;
import org.springframework.core.convert.converter.Converter;
import org.springframework.data.convert.WritingConverter;
import org.springframework.data.r2dbc.mapping.OutboundRow;
import org.springframework.r2dbc.core.Parameter;
import org.springframework.stereotype.Indexed;
import org.springframework.util.CollectionUtils;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;

@Indexed
@WritingConverter
public class ApplicationPolicyWriteConverter implements Converter<ApplicationPolicy, OutboundRow> {

    private ObjectMapper mapper = new ObjectMapper();

    @Override
    public OutboundRow convert(ApplicationPolicy source) {
        OutboundRow row = new OutboundRow();
        row.put("id", Parameter.fromOrEmpty(source.getId(), String.class));
        row.put("git_commit", Parameter.fromOrEmpty(source.getGitCommit(), String.class));
        row.put("operation", Parameter.fromOrEmpty(source.getOperation(), String.class));
        row.put("description", Parameter.fromOrEmpty(source.getDescription(), String.class));
        row.put("state", Parameter.fromOrEmpty(source.getState(), String.class));
        row.put("organization_whitelist", Parameter.fromOrEmpty(source.getOrganizationWhiteList().stream().filter(StringUtils::isNotBlank).collect(Collectors.joining(",")), String.class));
        row.put("cron_expression", Parameter.fromOrEmpty(source.getCronExpression(), String.class));
        row.put("options", Parameter.fromOrEmpty(CollectionUtils.isEmpty(source.getOptions()) ? null : writeOptions(source.getOptions()), String.class));
        return row;
    }

    private String writeOptions(Object value) {
        try {
            return mapper.writeValueAsString(value);
        } catch (JsonProcessingException jpe) {
            throw new RuntimeException("Problem writing options", jpe);
        }
    }
}


================================================
File: src/main/java/org/cftoolsuite/cfapp/domain/ApplicationState.java
================================================
package org.cftoolsuite.cfapp.domain;

import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;

import org.springframework.util.Assert;

import com.fasterxml.jackson.annotation.JsonValue;

public enum ApplicationState {

    STARTED("started"),
    STOPPED("stopped");

    public static ApplicationState from(String name) {
        Assert.hasText(name, "ApplicationState must not be null or empty");
        List<ApplicationState> states = Arrays.asList(ApplicationState.values());
        ApplicationState result = states.stream().filter(s -> s.getName().equalsIgnoreCase(name)).collect(Collectors.toList()).get(0);
        Assert.notNull(result, String.format("Invalid ApplicationState, name=%s", name));
        return result;
    }

    private String name;

    ApplicationState(String name) {
        this.name = name;
    }

    @JsonValue
    public String getName() {
        return name;
    }
}


================================================
File: src/main/java/org/cftoolsuite/cfapp/domain/Buildpack.java
================================================
package org.cftoolsuite.cfapp.domain;

import lombok.Builder;
import lombok.Getter;
import lombok.ToString;

@Builder
@Getter
@ToString
public class Buildpack {

    private String id;
    private String name;
    private Integer position;
    private Boolean enabled;
    private Boolean locked;
    private String filename;
    private String stack;

    public String getVersion() {
        String version = null;
        int versionPosition = filename.lastIndexOf('v');
        if (versionPosition >= 0) {
            version = filename.substring(versionPosition).replace(".zip", "");
        }
        return version;
    }
}


================================================
File: src/main/java/org/cftoolsuite/cfapp/domain/CustomConverters.java
================================================
package org.cftoolsuite.cfapp.domain;

import java.util.List;

public class CustomConverters {

    public static List<Object> get() {
        return List.of(
            new AppDetailReadConverter(),
            new AppDetailWriteConverter(),
            new ApplicationPolicyReadConverter(),
            new ApplicationPolicyWriteConverter(),
            new EndpointPolicyReadConverter(),
            new EndpointPolicyWriteConverter(),
            new HygienePolicyReadConverter(),
            new HygienePolicyWriteConverter(),
            new LegacyPolicyReadConverter(),
            new LegacyPolicyWriteConverter(),
            new QueryPolicyReadConverter(),
            new QueryPolicyWriteConverter(),
            new ResourceNotificationPolicyReadConverter(),
            new ResourceNotificationPolicyWriteConverter(),
            new ServiceInstanceDetailReadConverter(),
            new ServiceInstanceDetailWriteConverter(),
            new ServiceInstancePolicyReadConverter(),
            new ServiceInstancePolicyWriteConverter(),
            new SpaceUsersReadConverter(),
            new SpaceUsersWriteConverter()
        );
    }
}


================================================
File: src/main/java/org/cftoolsuite/cfapp/domain/Defaults.java
================================================
package org.cftoolsuite.cfapp.domain;

import java.util.ArrayList;
import java.util.List;

import org.cftoolsuite.cfapp.util.CsvUtil;

import io.r2dbc.spi.Row;

public class Defaults {

    public static List<String> getColumnListOfStringValue(Row row, String columnName) {
        String csv = Defaults.getColumnValue(row, columnName, String.class);
        return new ArrayList<>(CsvUtil.parse(csv));
    }

    public static <T> T getColumnValue(Row row, String columnName, Class<T> columnType) {
        try {
            return row.get(columnName, columnType);
        } catch (ClassCastException cce) {
            return null;
        }
    }

    public static <T> T getColumnValueOrDefault(Row row, String columnName, Class<T> columnType, T defaultValue) {
        try {
            T value = row.get(columnName, columnType);
            return value == null ? defaultValue : value;
        } catch (ClassCastException cce) {
            return defaultValue;
        }
    }

    public static Object getColumnValueOrDefault(Row row, String columnName, Object defaultValue) {
        try {
            Object value = row.get(columnName);
            return value == null ? defaultValue : value;
        } catch (Exception cce) {
            return defaultValue;
        }
    }
}


================================================
File: src/main/java/org/cftoolsuite/cfapp/domain/Demographics.java
================================================
package org.cftoolsuite.cfapp.domain;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;

import lombok.Builder;
import lombok.Builder.Default;
import lombok.Getter;

@Builder
@Getter
@JsonPropertyOrder({ "total-organizations", "total-spaces", "total-user-accounts", "total-service-accounts" })
public class Demographics {

    @Default
    @JsonProperty("total-organizations")
    private Long organizations = 0L;

    @Default
    @JsonProperty("total-spaces")
    private Long spaces = 0L;

    @Default
    @JsonProperty("total-user-accounts")
    private Long userAccounts = 0L;

    @Default
    @JsonProperty("total-service-accounts")
    private Long serviceAccounts = 0L;

    @JsonCreator
    public Demographics(
            @JsonProperty("total-organizations") Long organizations,
            @JsonProperty("total-spaces") Long spaces,
            @JsonProperty("total-user-accounts") Long userAccounts,
            @JsonProperty("total-service-accounts") Long serviceAccounts
            ) {
        this.organizations = organizations;
        this.spaces = spaces;
        this.userAccounts = userAccounts;
        this.serviceAccounts = serviceAccounts;
    }
}


================================================
File: src/main/java/org/cftoolsuite/cfapp/domain/EmailAttachment.java
================================================
package org.cftoolsuite.cfapp.domain;

import org.apache.commons.lang3.StringUtils;

import lombok.Builder;
import lombok.Getter;

@Builder
@Getter
public class EmailAttachment {

    private final String headers;
    private final String content;
    private final String filename;
    private final String mimeType;
    private final String extension;

    public String getHeadedContent() {
        StringBuilder result = new StringBuilder();
        if (hasHeaders()) {
            result.append(getHeaders());
            result.append(System.getProperty("line.separator"));
        }
        if (hasContent()) {
            result.append(getContent());
        }
        return result.toString();
    }

    public boolean hasContent() {
        return StringUtils.isNotBlank(getContent());
    }

    public boolean hasHeaders() {
        return StringUtils.isNotBlank(getHeaders());
    }

}


================================================
File: src/main/java/org/cftoolsuite/cfapp/domain/EmailNotificationTemplate.java
================================================
package org.cftoolsuite.cfapp.domain;

import java.util.HashSet;
import java.util.Set;

import org.apache.commons.lang3.StringUtils;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;

import lombok.Builder;
import lombok.Builder.Default;
import lombok.Getter;

@Builder
@JsonInclude(JsonInclude.Include.NON_NULL)
@JsonPropertyOrder({ "from", "to", "cc", "bcc", "subject", "body" })
@Getter
public class EmailNotificationTemplate {

    private static boolean areRecipientsValid(Set<String> recipients) {
        boolean result = true;
        if (!ObjectUtils.isEmpty(recipients)) {
            for (String recipient: recipients) {
                if (!EmailValidator.isValid(recipient)) {
                    result = false;
                    break;
                }
            }
        }
        return result;
    }

    @JsonProperty("from")
    private String from;

    @Default
    @JsonProperty("to")
    private Set<String> to = new HashSet<>();

    @Default
    @JsonProperty("cc")
    private Set<String> cc = new HashSet<>();

    @Default
    @JsonProperty("bcc")
    private Set<String> bcc = new HashSet<>();

    @JsonProperty("subject")
    private String subject;

    @JsonProperty("body")
    private String body;

    @JsonCreator
    public EmailNotificationTemplate(
            @JsonProperty("from") String from,
            @JsonProperty("to") Set<String> to,
            @JsonProperty("cc") Set<String> cc,
            @JsonProperty("bcc") Set<String> bcc,
            @JsonProperty("subject") String subject,
            @JsonProperty("body") String body
            ) {
        this.from = from;
        this.to = to;
        this.cc = cc;
        this.bcc = bcc;
        this.subject = subject;
        this.body = body;
    }

    @JsonIgnore
    public boolean isValid() {
        return EmailValidator.isValid(from)
                && areRecipientsValid(to)
                && areRecipientsValid(cc)
                && areRecipientsValid(bcc)
                && StringUtils.isNotBlank(subject)
                && StringUtils.isNotBlank(body);
    }
}


================================================
File: src/main/java/org/cftoolsuite/cfapp/domain/EmailValidator.java
================================================
package org.cftoolsuite.cfapp.domain;

import com.sanctionco.jmail.JMail;

public class EmailValidator {

    public static boolean isValid(String email) {
        return JMail.isValid(email);
    }
}


================================================
File: src/main/java/org/cftoolsuite/cfapp/domain/EmbeddedMetadata.java
================================================
package org.cftoolsuite.cfapp.domain;

import java.util.Collections;
import java.util.Map;
import java.util.Set;
import java.util.stream.Collectors;

import org.springframework.util.CollectionUtils;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;

import lombok.Builder;
import lombok.Getter;
import lombok.Singular;

@Builder
@Getter
@JsonPropertyOrder({ "labels", "annotations" })
// @see https://docs.vmware.com/en/VMware-Tanzu-Application-Service/3.0/tas-for-vms/metadata.html
public class EmbeddedMetadata {

    private static final String ALPHANUMERIC_REGEX = "^[a-zA-Z0-9.-]*$";
    private static final String ALPHANUMERIC_REGEX_AND_UNDERSCORE = "^[a-zA-Z0-9._-]*$";

    private static boolean isValidAnnotationValue(String value) {
        if (value == null) {
            return false;
        }
        return value.length() >= 0 && value.length() <= 5000;
    }

    private static boolean isValidKey(String key) {
        if (key == null) {
            return false;
        }
        if (key.contains("/")) {
            String[] keyParts = key.split("/");
            return
                    keyParts[0].length() >= 0 && keyParts[0].length() <= 253
                    && patternAdherent(keyParts[0], ALPHANUMERIC_REGEX)
                    && keyParts[1].length() >= 1 && keyParts[1].length() <= 63
                    && patternAdherent(keyParts[1], ALPHANUMERIC_REGEX_AND_UNDERSCORE);
        } else {
            return
                    key.length() >= 1 && key.length() <= 63
                    && patternAdherent(key, ALPHANUMERIC_REGEX_AND_UNDERSCORE);
        }
    }

    private static boolean isValidLabelValue(String value) {
        if (value == null) {
            return false;
        }
        return
                value.length() >= 0 && value.length() <= 63
                && patternAdherent(value, ALPHANUMERIC_REGEX_AND_UNDERSCORE);
    }

    private static boolean patternAdherent(String value, String pattern) {
        if (value == null) {
            return false;
        }
        return value.matches(pattern);
    }

    @Singular
    @JsonProperty("labels")
    private Map<String, String> labels;

    @Singular
    @JsonProperty("annotations")
    private Map<String, String> annotations;

    @JsonCreator
    public EmbeddedMetadata(
            @JsonProperty("labels") Map<String, String> labels,
            @JsonProperty("annotations") Map<String, String> annotations
            ) {
        this.labels = labels;
        this.annotations = annotations;
    }

    public String annotationsToString() {
        return annotations.keySet().stream().map(k -> k + "=" + annotations.get(k)).collect(Collectors.joining("; "));
    }

    @JsonIgnore
    public boolean isValid() {
        Set<String> filteredLabelKeys = CollectionUtils.isEmpty(getLabels()) ? Collections.emptySet(): getLabels().keySet().stream().filter(EmbeddedMetadata::isValidKey).collect(Collectors.toSet());
        Set<String> filteredAnnotationKeys = CollectionUtils.isEmpty(getAnnotations()) ? Collections.emptySet(): getAnnotations().keySet().stream().filter(EmbeddedMetadata::isValidKey).collect(Collectors.toSet());
        Set<String> filteredLabelValues = CollectionUtils.isEmpty(getLabels()) ? Collections.emptySet(): getLabels().values().stream().filter(EmbeddedMetadata::isValidLabelValue).collect(Collectors.toSet());
        Set<String> filteredAnnotationValues = CollectionUtils.isEmpty(getAnnotations()) ? Collections.emptySet(): getAnnotations().values().stream().filter(EmbeddedMetadata::isValidAnnotationValue).collect(Collectors.toSet());
        boolean labelKeysAreValid = false;
        boolean annotationKeysAreValid = false;
        boolean labelValuesAreValid = false;
        boolean annotationValuesAreValid = false;
        if (getLabels() == null && getAnnotations() == null) {
            return true;
        }
        if (getLabels() != null) {
            labelKeysAreValid = filteredLabelKeys.size() == (getLabels().keySet() == null ? 0: getLabels().keySet().size());
            labelValuesAreValid = filteredLabelValues.size() == (getLabels().values() == null ? 0: getLabels().values().size());
        }
        if (getAnnotations() != null) {
            annotationKeysAreValid = filteredAnnotationKeys.size() == (getAnnotations().keySet() == null ? 0: getAnnotations().keySet().size());
            annotationValuesAreValid = filteredAnnotationValues.size() == (getAnnotations().values() == null ? 0: getAnnotations().values().size());
        }
        return labelKeysAreValid && annotationKeysAreValid && labelValuesAreValid && annotationValuesAreValid;
    }

    public String labelsToString() {
        return labels.keySet().stream().map(k -> k + "=" + labels.get(k)).collect(Collectors.joining("; "));
    }
}


================================================
File: src/main/java/org/cftoolsuite/cfapp/domain/EndpointPolicy.java
================================================
package org.cftoolsuite.cfapp.domain;

import java.util.Collections;
import java.util.HashSet;
import java.util.Set;

import org.apache.commons.lang3.StringUtils;
import org.springframework.data.annotation.Id;
import org.springframework.data.relational.core.mapping.Column;
import org.springframework.data.relational.core.mapping.Table;
import org.springframework.util.CollectionUtils;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;
import com.fasterxml.uuid.Generators;

import lombok.Builder;
import lombok.Builder.Default;
import lombok.Getter;
import lombok.ToString;

@Builder
@JsonInclude(JsonInclude.Include.NON_NULL)
@JsonPropertyOrder({ "id", "git-commit", "description", "endpoint-requests", "email-notification-template", "cron-expression" })
@Getter
@ToString
@Table("endpoint_policy")
public class EndpointPolicy implements Policy {

    public static EndpointPolicy seed(EndpointPolicy policy) {
        return EndpointPolicy
                .builder()
                .cronExpression(policy.getCronExpression())
                .description(policy.getDescription())
                .endpointRequests(policy.getEndpointRequests())
                .emailNotificationTemplate(policy.getEmailNotificationTemplate())
                .build();
    }

    public static EndpointPolicy seedWith(EndpointPolicy policy, String gitCommit) {
        return EndpointPolicy
                .builder()
                .gitCommit(gitCommit)
                .cronExpression(policy.getCronExpression())
                .description(policy.getDescription())
                .endpointRequests(policy.getEndpointRequests())
                .emailNotificationTemplate(policy.getEmailNotificationTemplate())
                .build();
    }

    @Id
    @JsonIgnore
    private Long pk;

    @Default
    @JsonProperty("id")
    private String id = Generators.timeBasedGenerator().generate().toString();

    @JsonProperty("git-commit")
    @Column("git_commit")
    private String gitCommit;

    @JsonProperty("description")
    private String description;

    @Default
    @Column("endpoint_requests")
    @JsonProperty("endpoint-requests")
    private Set<EndpointRequest> endpointRequests = new HashSet<>();

    @JsonProperty("email-notification-template")
    private EmailNotificationTemplate emailNotificationTemplate;

    @JsonProperty("cron-expression")
    @Column("cron_expression")
    private String cronExpression;

    @JsonCreator
    EndpointPolicy(
            @JsonProperty("pk") Long pk,
            @JsonProperty("id") String id,
            @JsonProperty("git-commit") String gitCommit,
            @JsonProperty("description") String description,
            @JsonProperty("endpoint-requests") Set<EndpointRequest> endpointRequests,
            @JsonProperty("email-notification-template") EmailNotificationTemplate emailNotificationTemplate,
            @JsonProperty("cron-expression") String cronExpression) {
        this.pk = pk;
        this.id = id;
        this.gitCommit = gitCommit;
        this.description = description;
        this.endpointRequests = endpointRequests;
        this.emailNotificationTemplate = emailNotificationTemplate;
        this.cronExpression = cronExpression;
    }

    public String getCronExpression() {
        return StringUtils.isBlank(cronExpression) ? defaultCronExpression(): cronExpression;
    }

    public Set<EndpointRequest> getEndpointRequests() {
        return CollectionUtils.isEmpty(endpointRequests) ? new HashSet<>(): Collections.unmodifiableSet(endpointRequests);
    }

    @JsonIgnore
    public Long getPk() {
        return pk;
    }

}


================================================
File: src/main/java/org/cftoolsuite/cfapp/domain/EndpointPolicyReadConverter.java
================================================
package org.cftoolsuite.cfapp.domain;

import java.io.IOException;
import java.util.Set;

import org.cftoolsuite.cfapp.domain.EndpointRequest;
import org.springframework.core.convert.converter.Converter;
import org.springframework.data.convert.ReadingConverter;
import org.springframework.stereotype.Indexed;

import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;

import io.r2dbc.spi.Row;

@Indexed
@ReadingConverter
public class EndpointPolicyReadConverter implements Converter<Row, EndpointPolicy> {

    private ObjectMapper mapper = new ObjectMapper();

    @Override
    public EndpointPolicy convert(Row source) {
        return
                EndpointPolicy
                .builder()
                .pk(source.get("pk", Long.class))
                .id(source.get("id", String.class))
                .description(source.get("description", String.class))
                .endpointRequests(readEndpointRequests(source.get("endpoint_requests", String.class) == null ? "[]" : source.get("endpoint_requests", String.class)))
                .emailNotificationTemplate(
                        readEmailNotificationTemplate(
                                source.get("email_notification_template", String.class) == null
                                ? "{}"
                                        : source.get("email_notification_template", String.class)))
                .cronExpression(source.get("cron_expression", String.class))
                .build();
    }

    private EmailNotificationTemplate readEmailNotificationTemplate(String value) {
        try {
            return mapper.readValue(value, EmailNotificationTemplate.class);
        } catch (IOException ioe) {
            throw new RuntimeException("Problem reading email notification template", ioe);
        }
    }

    private Set<EndpointRequest> readEndpointRequests(String value) {
        try {
            return mapper.readValue(value, new TypeReference<Set<EndpointRequest>>() {});
        } catch (IOException ioe) {
            throw new RuntimeException("Problem reading endpoint requests", ioe);
        }
    }
}



================================================
File: src/main/java/org/cftoolsuite/cfapp/domain/EndpointPolicyWriteConverter.java
================================================
package org.cftoolsuite.cfapp.domain;

import java.util.Set;

import org.cftoolsuite.cfapp.domain.EndpointRequest;
import org.springframework.core.convert.converter.Converter;
import org.springframework.data.convert.WritingConverter;
import org.springframework.data.r2dbc.mapping.OutboundRow;
import org.springframework.r2dbc.core.Parameter;
import org.springframework.stereotype.Indexed;
import org.springframework.util.CollectionUtils;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;

@Indexed
@WritingConverter
public class EndpointPolicyWriteConverter implements Converter<EndpointPolicy, OutboundRow> {

    private ObjectMapper mapper = new ObjectMapper();

    @Override
    public OutboundRow convert(EndpointPolicy source) {
        OutboundRow row = new OutboundRow();
        row.put("id", Parameter.fromOrEmpty(source.getId(), String.class));
        row.put("git_commit", Parameter.fromOrEmpty(source.getGitCommit(), String.class));
        row.put("description", Parameter.fromOrEmpty(source.getDescription(), String.class));
        row.put("endpoint_requests", Parameter.fromOrEmpty(CollectionUtils.isEmpty(source.getEndpointRequests()) ? null : writeEndpointRequests(source.getEndpointRequests()), String.class));
        row.put("email_notification_template", Parameter.fromOrEmpty(source.getEmailNotificationTemplate() != null ? writeEmailNotificationTemplate(source.getEmailNotificationTemplate()) : null, String.class));
        row.put("cron_expression", Parameter.fromOrEmpty(source.getCronExpression(), String.class));
        return row;
    }

    private String writeEmailNotificationTemplate(EmailNotificationTemplate value) {
        try {
            return mapper.writeValueAsString(value);
        } catch (JsonProcessingException jpe) {
            throw new RuntimeException("Problem writing email notification template", jpe);
        }
    }

    private String writeEndpointRequests(Set<EndpointRequest> value) {
        try {
            return mapper.writeValueAsString(value);
        } catch (JsonProcessingException jpe) {
            throw new RuntimeException("Problem writing endpoint requests", jpe);
        }
    }
}


================================================
File: src/main/java/org/cftoolsuite/cfapp/domain/EndpointRequest.java
================================================
package org.cftoolsuite.cfapp.domain;

import java.util.Collections;
import java.util.HashSet;
import java.util.Set;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;

import lombok.Builder;
import lombok.Getter;
import lombok.ToString;

@Builder
@JsonInclude(JsonInclude.Include.NON_NULL)
@JsonPropertyOrder({ "endpoint", "json-path-expression", "apply-json-to-csv-converter" })
@Getter
@ToString
public class EndpointRequest {

    @JsonProperty("endpoint")
    private String endpoint;

    @JsonProperty("json-path-expression")
    private String jsonPathExpression;

    @JsonProperty("apply-json-to-csv-converter")
    private boolean applyJsonToCsvConverter;

    @JsonCreator
    public EndpointRequest(
        @JsonProperty("endpoint") String endpoint,
        @JsonProperty("json-path-expression") String jsonPathExpression,
        @JsonProperty("apply-json-to-csv-converter") boolean applyJsonToCsvConverter
    ) {
        this.endpoint = endpoint;
        this.jsonPathExpression = jsonPathExpression;
        this.applyJsonToCsvConverter = applyJsonToCsvConverter;
    }

}

================================================
File: src/main/java/org/cftoolsuite/cfapp/domain/Event.java
================================================
package org.cftoolsuite.cfapp.domain;

import java.time.LocalDateTime;

import lombok.Builder;
import lombok.Getter;

@Builder
@Getter
public class Event {

    private String type;
    private String actee;
    private String actor;
    private LocalDateTime time;
}


================================================
File: src/main/java/org/cftoolsuite/cfapp/domain/HasCronExpression.java
================================================
package org.cftoolsuite.cfapp.domain;

public interface HasCronExpression {
    String getCronExpression();

    default String defaultCronExpression() {
        return "0 0 2 * * MON";
    }
}


================================================
File: src/main/java/org/cftoolsuite/cfapp/domain/HasIdentifier.java
================================================
package org.cftoolsuite.cfapp.domain;

public interface HasIdentifier {
    String getId();
}


================================================
File: src/main/java/org/cftoolsuite/cfapp/domain/HasOrganizationWhiteList.java
================================================
package org.cftoolsuite.cfapp.domain;

import java.util.Set;

public interface HasOrganizationWhiteList {
    Set<String> getOrganizationWhiteList();
}


================================================
File: src/main/java/org/cftoolsuite/cfapp/domain/HistoricalRecord.java
================================================
package org.cftoolsuite.cfapp.domain;

import java.time.LocalDateTime;

import org.apache.commons.lang3.StringUtils;
import org.springframework.data.annotation.Id;
import org.springframework.data.relational.core.mapping.Table;

import com.fasterxml.jackson.annotation.JsonIgnore;

import lombok.Builder;
import lombok.EqualsAndHashCode;
import lombok.Getter;

@Builder
@Getter
@EqualsAndHashCode
@Table("historical_record")
public class HistoricalRecord {

    public static String headers() {
        return String.join(",", "transaction date/time", "action taken", "organization", "space",
                "application id", "service instance id", "type", "name");
    }
    private static String wrap(String value) {
        return value != null ? StringUtils.wrap(value, '"') : StringUtils.wrap("", '"');
    }
    @Id
    @JsonIgnore
    private Long pk;
    private LocalDateTime transactionDateTime;
    private String actionTaken;
    private String organization;
    private String space;
    private String appId;
    private String serviceInstanceId;

    private String type;

    private String name;

    public String toCsv() {
        return String.join(",",
                wrap(getTransactionDateTime() != null ? getTransactionDateTime().toString() : ""),
                wrap(getActionTaken()), wrap(getOrganization()), wrap(getSpace()), wrap(getAppId()),
                wrap(getServiceInstanceId()), wrap(getType()), wrap(getName()));
    }

}


================================================
File: src/main/java/org/cftoolsuite/cfapp/domain/Href.java
================================================
package org.cftoolsuite.cfapp.domain;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;

import lombok.Builder;
import lombok.Getter;

@Builder
@Getter
@JsonPropertyOrder({
    "href"
})
public class Href {

    @JsonProperty("href")
    private String href;

    @JsonCreator
    public Href(@JsonProperty("href") String href) {
        this.href = href;
    }

}

================================================
File: src/main/java/org/cftoolsuite/cfapp/domain/HygienePolicy.java
================================================
package org.cftoolsuite.cfapp.domain;

import java.util.Collections;
import java.util.HashSet;
import java.util.Set;

import org.apache.commons.lang3.StringUtils;
import org.springframework.data.annotation.Id;
import org.springframework.data.relational.core.mapping.Column;
import org.springframework.data.relational.core.mapping.Table;
import org.springframework.util.CollectionUtils;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;
import com.fasterxml.uuid.Generators;

import lombok.Builder;
import lombok.Builder.Default;
import lombok.Getter;

@Builder
@JsonInclude(JsonInclude.Include.NON_NULL)
@JsonPropertyOrder({
    "id", "git-commit", "days-since-last-update", "operator-email-template", "notifyee-email-template", "organization-whitelist", "cron-expression", "include-applications", "include-service-instances"
})
@Getter
@Table("hygiene_policy")
public class HygienePolicy implements HasOrganizationWhiteList, Policy {

    public static HygienePolicy seed(HygienePolicy policy) {
        return HygienePolicy
                .builder()
                .daysSinceLastUpdate(policy.getDaysSinceLastUpdate())
                .operatorTemplate(policy.getOperatorTemplate())
                .notifyeeTemplate(policy.getNotifyeeTemplate())
                .organizationWhiteList(policy.getOrganizationWhiteList())
                .cronExpression(policy.getCronExpression())
                .includeApplications(policy.isIncludeApplications())
                .includeServiceInstances(policy.isIncludeServiceInstances())
                .build();
    }

    public static HygienePolicy seedWith(HygienePolicy policy, String gitCommit) {
        return HygienePolicy
                .builder()
                .gitCommit(gitCommit)
                .daysSinceLastUpdate(policy.getDaysSinceLastUpdate())
                .operatorTemplate(policy.getOperatorTemplate())
                .notifyeeTemplate(policy.getNotifyeeTemplate())
                .organizationWhiteList(policy.getOrganizationWhiteList())
                .cronExpression(policy.getCronExpression())
                .includeApplications(policy.isIncludeApplications())
                .includeServiceInstances(policy.isIncludeServiceInstances())
                .build();
    }

    @Id
    @JsonIgnore
    private Long pk;

    @Default
    @JsonProperty("id")
    private String id = Generators.timeBasedGenerator().generate().toString();

    @JsonProperty("git-commit")
    @Column("git_commit")
    private String gitCommit;

    @Default
    @JsonProperty("days-since-last-update")
    private Integer daysSinceLastUpdate = 180;

    @JsonProperty("operator-email-template")
    @Column("operator_email_template")
    private EmailNotificationTemplate operatorTemplate;

    @JsonProperty("notifyee-email-template")
    @Column("notifyee_email_template")
    private EmailNotificationTemplate notifyeeTemplate;

    @Default
    @JsonProperty("organization-whitelist")
    @Column("organization_whitelist")
    private Set<String> organizationWhiteList = new HashSet<>();

    @JsonProperty("cron-expression")
    @Column("cron_expression")
    private String cronExpression;

    @Default
    @JsonProperty("include-applications")
    @Column("include_applications")
    private boolean includeApplications = true;

    @Default
    @JsonProperty("include-service-instances")
    @Column("include_service_instances")
    private boolean includeServiceInstances = true;

    @JsonCreator
    public HygienePolicy(
            @JsonProperty("pk") Long pk,
            @JsonProperty("id") String id,
            @JsonProperty("git-commit") String gitCommit,
            @JsonProperty("days-since-last-update") Integer daysSinceLastUpdate,
            @JsonProperty("operator-email-template") EmailNotificationTemplate operatorTemplate,
            @JsonProperty("notifyee-email-template") EmailNotificationTemplate notifyeeTemplate,
            @JsonProperty("organization-whitelist") Set<String> organizationWhiteList,
            @JsonProperty("cron-expression") String cronExpression,
            @JsonProperty("include-applications") boolean includeApplications,
            @JsonProperty("include-service-instances") boolean includeServiceInstances
            ) {
        this.pk = pk;
        this.id = id;
        this.gitCommit = gitCommit;
        this.daysSinceLastUpdate = daysSinceLastUpdate;
        this.operatorTemplate = operatorTemplate;
        this.notifyeeTemplate = notifyeeTemplate;
        this.organizationWhiteList = organizationWhiteList;
        this.cronExpression = cronExpression;
        this.includeApplications = includeApplications;
        this.includeServiceInstances = includeServiceInstances;
    }

    public String getCronExpression() {
        return StringUtils.isBlank(cronExpression) ? defaultCronExpression(): cronExpression;
    }

    public Set<String> getOrganizationWhiteList() {
        return CollectionUtils.isEmpty(organizationWhiteList) ? new HashSet<>() : Collections.unmodifiableSet(organizationWhiteList);
    }

    @JsonIgnore
    public Long getPk() {
        return pk;
    }
}


================================================
File: src/main/java/org/cftoolsuite/cfapp/domain/HygienePolicyReadConverter.java
================================================
package org.cftoolsuite.cfapp.domain;

import java.io.IOException;

import org.cftoolsuite.cfapp.util.CsvUtil;
import org.springframework.core.convert.converter.Converter;
import org.springframework.data.convert.ReadingConverter;
import org.springframework.stereotype.Indexed;

import com.fasterxml.jackson.databind.ObjectMapper;

import io.r2dbc.spi.Row;

@Indexed
@ReadingConverter
public class HygienePolicyReadConverter implements Converter<Row, HygienePolicy> {

    private ObjectMapper mapper = new ObjectMapper();

    @Override
    public HygienePolicy convert(Row source) {
        return
                HygienePolicy
                .builder()
                .pk(source.get("pk", Long.class))
                .id(source.get("id", String.class))
                .gitCommit(source.get("git_commit", String.class))
                .daysSinceLastUpdate(source.get("days_since_last_update", Integer.class))
                .operatorTemplate(readEmailNotificationTemplate(source.get("operator_email_template", String.class) == null ? "{}": source.get("operator_email_template", String.class)))
                .notifyeeTemplate(readEmailNotificationTemplate(source.get("notifyee_email_template", String.class) == null ? "{}": source.get("notifyee_email_template", String.class)))
                .organizationWhiteList(CsvUtil.parse(source.get("organization_whitelist", String.class)))
                .cronExpression(source.get("cron_expression", String.class))
                .build();
    }

    private EmailNotificationTemplate readEmailNotificationTemplate(String value) {
        try {
            return mapper.readValue(value, EmailNotificationTemplate.class);
        } catch (IOException ioe) {
            throw new RuntimeException("Problem reading email notification template", ioe);
        }
    }
}



================================================
File: src/main/java/org/cftoolsuite/cfapp/domain/HygienePolicyWriteConverter.java
================================================
package org.cftoolsuite.cfapp.domain;

import java.util.stream.Collectors;

import org.apache.commons.lang3.StringUtils;
import org.springframework.core.convert.converter.Converter;
import org.springframework.data.convert.WritingConverter;
import org.springframework.data.r2dbc.mapping.OutboundRow;
import org.springframework.r2dbc.core.Parameter;
import org.springframework.stereotype.Indexed;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;

@Indexed
@WritingConverter
public class HygienePolicyWriteConverter implements Converter<HygienePolicy, OutboundRow> {

    private ObjectMapper mapper = new ObjectMapper();

    @Override
    public OutboundRow convert(HygienePolicy source) {
        OutboundRow row = new OutboundRow();
        row.put("id", Parameter.fromOrEmpty(source.getId(), String.class));
        row.put("git_commit", Parameter.fromOrEmpty(source.getGitCommit(), String.class));
        row.put("days_since_last_update", Parameter.fromOrEmpty(source.getDaysSinceLastUpdate(), Integer.class));
        row.put("operator_email_template", Parameter.fromOrEmpty(source.getOperatorTemplate() != null ? writeEmailNotificationTemplate(source.getOperatorTemplate()) : null, String.class));
        row.put("notifyee_email_template", Parameter.fromOrEmpty(source.getNotifyeeTemplate() != null ? writeEmailNotificationTemplate(source.getNotifyeeTemplate()) : null, String.class));
        row.put("organization_whitelist", Parameter.fromOrEmpty(source.getOrganizationWhiteList().stream().filter(StringUtils::isNotBlank).collect(Collectors.joining(",")), String.class));
        row.put("cron_expression", Parameter.fromOrEmpty(source.getCronExpression(), String.class));
        return row;
    }

    private String writeEmailNotificationTemplate(EmailNotificationTemplate value) {
        try {
            return mapper.writeValueAsString(value);
        } catch (JsonProcessingException jpe) {
            throw new RuntimeException("Problem writing email notification template", jpe);
        }
    }
}


================================================
File: src/main/java/org/cftoolsuite/cfapp/domain/JavaAppDetail.java
================================================
package org.cftoolsuite.cfapp.domain;

import org.apache.commons.lang3.StringUtils;
import org.springframework.data.annotation.Id;
import org.springframework.data.relational.core.mapping.Table;

import com.fasterxml.jackson.annotation.JsonIgnore;

import lombok.Builder;
import lombok.EqualsAndHashCode;
import lombok.Getter;
import lombok.ToString;

@Builder
@Getter
@EqualsAndHashCode
@ToString
@Table("java_application_detail")
public class JavaAppDetail {

    @Id
    @JsonIgnore
    private Long pk;
    private String organization;
    private String space;
    private String appId;
    private String appName;
    private String dropletId;
    private Integer buildJdkSpec;
    private String pomContents;
    private String jars;
    private String springDependencies;

    public static JavaAppDetailBuilder from(JavaAppDetail detail) {
        return JavaAppDetail
                .builder()
                .pk(detail.getPk())
                .organization(detail.getOrganization())
                .space(detail.getSpace())
                .appId(detail.getAppId())
                .appName(detail.getAppName())
                .dropletId(detail.getDropletId())
                .buildJdkSpec(detail.getBuildJdkSpec())
                .pomContents(detail.getPomContents())
                .jars(detail.getJars())
                .springDependencies(detail.getSpringDependencies());
    }

    public static JavaAppDetailBuilder from(AppDetail detail) {
        return JavaAppDetail
                .builder()
                .pk(detail.getPk())
                .organization(detail.getOrganization())
                .space(detail.getSpace())
                .appId(detail.getAppId())
                .appName(detail.getAppName());
    }

    public static String headers() {
        return String.join(",", "organization", "space", "application id", "application name", "droplet id", "build jdk spec", "pom contents", "jars", "spring dependencies" );
    }

    private static String wrap(String value) {
        return value != null ? StringUtils.wrap(value, '"') : StringUtils.wrap("", '"');
    }

    private static String wrap(Integer value) {
        return value != null ? StringUtils.wrap(String.valueOf(value), '"') : StringUtils.wrap("", '"');
    }

    public String toCsv() {
        return String.join(",", wrap(getOrganization()), wrap(getSpace()), wrap(getAppId()), wrap(getAppName()),
                wrap(getDropletId()), wrap(getBuildJdkSpec()), wrap(getPomContents()), wrap(getJars()), wrap(getSpringDependencies()));
    }

}


================================================
File: src/main/java/org/cftoolsuite/cfapp/domain/LegacyPolicy.java
================================================
package org.cftoolsuite.cfapp.domain;

import java.util.Collections;
import java.util.HashSet;
import java.util.Set;

import org.apache.commons.lang3.StringUtils;
import org.springframework.data.annotation.Id;
import org.springframework.data.relational.core.mapping.Column;
import org.springframework.data.relational.core.mapping.Table;
import org.springframework.util.CollectionUtils;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;
import com.fasterxml.uuid.Generators;

import lombok.Builder;
import lombok.Builder.Default;
import lombok.Getter;

@Builder
@JsonInclude(JsonInclude.Include.NON_NULL)
@JsonPropertyOrder({ "id", "git-commit", "stacks", "service-offerings", "operator-email-template", "notifyee-email-template", "organization-whitelist", "cron-expression" })
@Getter
@Table("legacy_policy")
public class LegacyPolicy implements HasOrganizationWhiteList, Policy {

    public static LegacyPolicy seed(LegacyPolicy policy) {
        return LegacyPolicy
                .builder()
                .stacks(policy.getStacks())
                .serviceOfferings(policy.getServiceOfferings())
                .operatorTemplate(policy.getOperatorTemplate())
                .notifyeeTemplate(policy.getNotifyeeTemplate())
                .organizationWhiteList(policy.getOrganizationWhiteList())
                .cronExpression(policy.getCronExpression())
                .build();
    }

    public static LegacyPolicy seedWith(LegacyPolicy policy, String gitCommit) {
        return LegacyPolicy
                .builder()
                .gitCommit(gitCommit)
                .stacks(policy.getStacks())
                .serviceOfferings(policy.getServiceOfferings())
                .operatorTemplate(policy.getOperatorTemplate())
                .notifyeeTemplate(policy.getNotifyeeTemplate())
                .organizationWhiteList(policy.getOrganizationWhiteList())
                .cronExpression(policy.getCronExpression())
                .build();
    }

    @Id
    @JsonIgnore
    private Long pk;

    @Default
    @JsonProperty("id")
    private String id = Generators.timeBasedGenerator().generate().toString();

    @JsonProperty("git-commit")
    @Column("git_commit")
    private String gitCommit;

    @Default
    @JsonProperty("stacks")
    private Set<String> stacks = new HashSet<>();

    @Default
    @JsonProperty("service-offerings")
    private Set<String> serviceOfferings = new HashSet<>();

    @JsonProperty("operator-email-template")
    @Column("operator_email_template")
    private EmailNotificationTemplate operatorTemplate;

    @JsonProperty("notifyee-email-template")
    @Column("notifyee_email_template")
    private EmailNotificationTemplate notifyeeTemplate;

    @Default
    @JsonProperty("organization-whitelist")
    @Column("organization_whitelist")
    private Set<String> organizationWhiteList = new HashSet<>();

    @JsonProperty("cron-expression")
    @Column("cron_expression")
    private String cronExpression;

    @JsonCreator
    public LegacyPolicy(
            @JsonProperty("pk") Long pk,
            @JsonProperty("id") String id,
            @JsonProperty("git-commit") String gitCommit,
            @JsonProperty("stacks") Set<String> stacks,
            @JsonProperty("service-offerings") Set<String> serviceOfferings,
            @JsonProperty("operator-email-template") EmailNotificationTemplate operatorTemplate,
            @JsonProperty("notifyee-email-template") EmailNotificationTemplate notifyeeTemplate,
            @JsonProperty("organization-whitelist") Set<String> organizationWhiteList,
            @JsonProperty("cron-expression") String cronExpression
            ) {
        this.pk = pk;
        this.id = id;
        this.gitCommit = gitCommit;
        this.stacks = stacks;
        this.serviceOfferings = serviceOfferings;
        this.operatorTemplate = operatorTemplate;
        this.notifyeeTemplate = notifyeeTemplate;
        this.organizationWhiteList = organizationWhiteList;
        this.cronExpression = cronExpression;
    }

    public String getCronExpression() {
        return StringUtils.isBlank(cronExpression) ? defaultCronExpression(): cronExpression;
    }

    public Set<String> getOrganizationWhiteList() {
        return CollectionUtils.isEmpty(organizationWhiteList) ? new HashSet<>() : Collections.unmodifiableSet(organizationWhiteList);
    }

    @JsonIgnore
    public Long getPk() {
        return pk;
    }

    public Set<String> getServiceOfferings() {
        return CollectionUtils.isEmpty(serviceOfferings) ? new HashSet<>() : Collections.unmodifiableSet(serviceOfferings);
    }

    public Set<String> getStacks() {
        return CollectionUtils.isEmpty(stacks) ? new HashSet<>() : Collections.unmodifiableSet(stacks);
    }
}


================================================
File: src/main/java/org/cftoolsuite/cfapp/domain/LegacyPolicyReadConverter.java
================================================
package org.cftoolsuite.cfapp.domain;

import java.io.IOException;

import org.cftoolsuite.cfapp.util.CsvUtil;
import org.springframework.core.convert.converter.Converter;
import org.springframework.data.convert.ReadingConverter;
import org.springframework.stereotype.Indexed;

import com.fasterxml.jackson.databind.ObjectMapper;

import io.r2dbc.spi.Row;

@Indexed
@ReadingConverter
public class LegacyPolicyReadConverter implements Converter<Row, LegacyPolicy> {

    private ObjectMapper mapper = new ObjectMapper();

    @Override
    public LegacyPolicy convert(Row source) {
        return
            LegacyPolicy
                .builder()
                    .pk(source.get("pk", Long.class))
                    .id(source.get("id", String.class))
                    .gitCommit(source.get("git_commit", String.class))
                    .stacks(CsvUtil.parse(source.get("stacks", String.class)))
                    .serviceOfferings(CsvUtil.parse(source.get("service_offerings", String.class)))
                    .operatorTemplate(readEmailNotificationTemplate(source.get("operator_email_template", String.class) == null ? "{}": source.get("operator_email_template", String.class)))
                    .notifyeeTemplate(readEmailNotificationTemplate(source.get("notifyee_email_template", String.class) == null ? "{}": source.get("notifyee_email_template", String.class)))
                    .organizationWhiteList(CsvUtil.parse(source.get("organization_whitelist", String.class)))
                    .cronExpression(source.get("cron_expression", String.class))
                    .build();
    }

    private EmailNotificationTemplate readEmailNotificationTemplate(String value) {
        try {
            return mapper.readValue(value, EmailNotificationTemplate.class);
        } catch (IOException ioe) {
            throw new RuntimeException("Problem reading email notification template", ioe);
        }
    }
}



================================================
File: src/main/java/org/cftoolsuite/cfapp/domain/LegacyPolicyWriteConverter.java
================================================
package org.cftoolsuite.cfapp.domain;

import java.util.stream.Collectors;

import org.apache.commons.lang3.StringUtils;
import org.springframework.core.convert.converter.Converter;
import org.springframework.data.convert.WritingConverter;
import org.springframework.data.r2dbc.mapping.OutboundRow;
import org.springframework.r2dbc.core.Parameter;
import org.springframework.stereotype.Indexed;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;

@Indexed
@WritingConverter
public class LegacyPolicyWriteConverter implements Converter<LegacyPolicy, OutboundRow> {

    private ObjectMapper mapper = new ObjectMapper();

    @Override
    public OutboundRow convert(LegacyPolicy source) {
        OutboundRow row = new OutboundRow();
        row.put("id", Parameter.fromOrEmpty(source.getId(), String.class));
        row.put("git_commit", Parameter.fromOrEmpty(source.getGitCommit(), String.class));
        row.put("stacks", Parameter.fromOrEmpty(source.getStacks().stream().filter(StringUtils::isNotBlank).collect(Collectors.joining(",")), String.class));
        row.put("service_offerings", Parameter.fromOrEmpty(source.getServiceOfferings().stream().filter(StringUtils::isNotBlank).collect(Collectors.joining(",")), String.class));
        row.put("operator_email_template", Parameter.fromOrEmpty(source.getOperatorTemplate() != null ? writeEmailNotificationTemplate(source.getOperatorTemplate()) : null, String.class));
        row.put("notifyee_email_template", Parameter.fromOrEmpty(source.getNotifyeeTemplate() != null ? writeEmailNotificationTemplate(source.getNotifyeeTemplate()) : null, String.class));
        row.put("organization_whitelist", Parameter.fromOrEmpty(source.getOrganizationWhiteList().stream().filter(StringUtils::isNotBlank).collect(Collectors.joining(",")), String.class));
        row.put("cron_expression", Parameter.fromOrEmpty(source.getCronExpression(), String.class));
        return row;
    }

    private String writeEmailNotificationTemplate(EmailNotificationTemplate value) {
        try {
            return mapper.writeValueAsString(value);
        } catch (JsonProcessingException jpe) {
            throw new RuntimeException("Problem writing email notification template", jpe);
        }
    }
}


================================================
File: src/main/java/org/cftoolsuite/cfapp/domain/Metadata.java
================================================
package org.cftoolsuite.cfapp.domain;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonProperty;

import lombok.Builder;
import lombok.Getter;

@Builder
@Getter
public class Metadata {

    @JsonProperty("metadata")
    private EmbeddedMetadata metadata;

    @JsonCreator
    public Metadata(
            @JsonProperty("metadata") EmbeddedMetadata metadata
            ) {
        this.metadata = metadata;
    }

    @JsonIgnore
    public boolean isValid() {
        if (metadata == null) {
            return true;
        } else {
            return metadata.isValid();
        }


    }
}


================================================
File: src/main/java/org/cftoolsuite/cfapp/domain/ObjectUtils.java
================================================
package org.cftoolsuite.cfapp.domain;

import java.util.Collection;

public class ObjectUtils {

    public static boolean isEmpty(Object[] array) {
        return array == null || array.length == 0;
    }

    public static boolean isEmpty(Collection<?> collection) {
        return collection == null || collection.isEmpty();
    }
}


================================================
File: src/main/java/org/cftoolsuite/cfapp/domain/Organization.java
================================================
package org.cftoolsuite.cfapp.domain;

import org.springframework.data.annotation.Id;
import org.springframework.data.annotation.PersistenceCreator;
import org.springframework.data.relational.core.mapping.Column;
import org.springframework.data.relational.core.mapping.Table;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;

import lombok.EqualsAndHashCode;
import lombok.Getter;
import lombok.ToString;

@Getter
@EqualsAndHashCode
@JsonPropertyOrder({ "id", "name"})
@ToString
@Table("organizations")
public class Organization {

    @Id
    @JsonProperty("id")
    private final String id;

    @Column("org_name")
    @JsonProperty("name")
    private final String name;


    @JsonCreator
    @PersistenceCreator
    public Organization(
            @JsonProperty("id") String id,
            @JsonProperty("name") String name) {
        this.id = id;
        this.name = name;
    }

}


================================================
File: src/main/java/org/cftoolsuite/cfapp/domain/OwnerNotificationTemplate.java
================================================
package org.cftoolsuite.cfapp.domain;

import org.apache.commons.lang3.StringUtils;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;

import lombok.Builder;
import lombok.Getter;

@Builder
@JsonInclude(JsonInclude.Include.NON_NULL)
@JsonPropertyOrder({ "from", "subject", "body" })
@Getter
public class OwnerNotificationTemplate {

    @JsonProperty("from")
    private String from;

    @JsonProperty("subject")
    private String subject;

    @JsonProperty("body")
    private String body;

    @JsonCreator
    public OwnerNotificationTemplate(
            @JsonProperty("from") String from,
            @JsonProperty("subject") String subject,
            @JsonProperty("body") String body
            ) {
        this.from = from;
        this.subject = subject;
        this.body = body;
    }

    @JsonIgnore
    public boolean isValid() {
        return EmailValidator.isValid(from)
                && StringUtils.isNotBlank(subject)
                && StringUtils.isNotBlank(body);
    }
}


================================================
File: src/main/java/org/cftoolsuite/cfapp/domain/Pagination.java
================================================
package org.cftoolsuite.cfapp.domain;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;

import lombok.Builder;
import lombok.Getter;

@Builder
@Getter
@JsonPropertyOrder({ "pagination"})
public class Pagination {    


    @JsonProperty("total_results")
    private Integer totalResult;

    @JsonProperty("total_pages")
    private Integer totalPages;


    @JsonProperty("next")
    private Href next;


    @JsonProperty("previous")
    private Href previous;


    @JsonProperty("first")
    private Href first;


    @JsonProperty("last")
    private Href last;

    @JsonCreator
    public Pagination(@JsonProperty("total_results") Integer totalResult,
    @JsonProperty("total_pages") Integer totalPages,
    @JsonProperty("previous") Href previous,
    @JsonProperty("next") Href next,
    @JsonProperty("first") Href first,
    @JsonProperty("last") Href last
    ) {
        this.totalResult = totalResult;
        this.totalPages = totalPages;
        this.previous = previous;
        this.next = next;
        this.first = first;
        this.last = last;
    }
}

================================================
File: src/main/java/org/cftoolsuite/cfapp/domain/Policies.java
================================================
package org.cftoolsuite.cfapp.domain;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;

import lombok.Builder;

@Builder
@JsonInclude(JsonInclude.Include.NON_EMPTY)
@JsonPropertyOrder({ "application-policies", "service-instance-policies", "endpoint-policies", "query-policies", "hygiene-policies", "legacy-policies","resource-notification-policies" })
public class Policies {

    @JsonProperty("application-policies")
    private List<ApplicationPolicy> applicationPolicies;

    @JsonProperty("service-instance-policies")
    private List<ServiceInstancePolicy> serviceInstancePolicies;

    @JsonProperty("endpoint-policies")
    private List<EndpointPolicy> endpointPolicies;

    @JsonProperty("query-policies")
    private List<QueryPolicy> queryPolicies;

    @JsonProperty("hygiene-policies")
    private List<HygienePolicy> hygienePolicies;

    @JsonProperty("legacy-policies")
    private List<LegacyPolicy> legacyPolicies;

    @JsonProperty("resource-notification-policies")
    private List<ResourceNotificationPolicy> resourceNotificationPolicies;

    @JsonCreator
    Policies(
            @JsonProperty("application-policies") List<ApplicationPolicy> applicationPolicies,
            @JsonProperty("service-instance-policies") List<ServiceInstancePolicy> serviceInstancePolicies,
            @JsonProperty("endpoint-policies") List<EndpointPolicy> endpointPolicies,
            @JsonProperty("query-policies") List<QueryPolicy> queryPolicies,
            @JsonProperty("hygiene-policies") List<HygienePolicy> hygienePolicies,
            @JsonProperty("legacy-policies") List<LegacyPolicy> legacyPolicies,
            @JsonProperty("resource-notification-policies") List<ResourceNotificationPolicy> resourceNotificationPolicies) {
        this.applicationPolicies = applicationPolicies;
        this.serviceInstancePolicies = serviceInstancePolicies;
        this.endpointPolicies = endpointPolicies;
        this.queryPolicies = queryPolicies;
        this.hygienePolicies = hygienePolicies;
        this.legacyPolicies = legacyPolicies;
        this.resourceNotificationPolicies = resourceNotificationPolicies;

    }

    public List<ApplicationPolicy> getApplicationPolicies() {
        return applicationPolicies != null ? applicationPolicies: Collections.emptyList();
    }

    public List<EndpointPolicy> getEndpointPolicies() {
        return endpointPolicies != null ? endpointPolicies: Collections.emptyList();
    }

    public List<HygienePolicy> getHygienePolicies() {
        return hygienePolicies != null ? hygienePolicies: Collections.emptyList();
    }

    public List<LegacyPolicy> getLegacyPolicies() {
        return legacyPolicies != null ? legacyPolicies: Collections.emptyList();
    }

    public List<QueryPolicy> getQueryPolicies() {
        return queryPolicies != null ? queryPolicies: Collections.emptyList();
    }

    public List<ServiceInstancePolicy> getServiceInstancePolicies() {
        return serviceInstancePolicies != null ? serviceInstancePolicies: Collections.emptyList();
    }

    public List<ResourceNotificationPolicy> getResourceNotificationPolicies() {
        return resourceNotificationPolicies != null ? resourceNotificationPolicies: Collections.emptyList();
    }

    public List<Policy> all() {
        List<Policy> policies = new ArrayList<>();
        policies.addAll(getApplicationPolicies());
        policies.addAll(getEndpointPolicies());
        policies.addAll(getHygienePolicies());
        policies.addAll(getLegacyPolicies());
        policies.addAll(getQueryPolicies());
        policies.addAll(getResourceNotificationPolicies());
        policies.addAll(getServiceInstancePolicies());
        return policies;
    }

    public Policy getById(String policyId) {
        return all()
                .stream()
                .filter(policy -> policy.getId().equals(policyId))
                .findFirst()
                .orElse(null);
    }

    @JsonIgnore
    public boolean isEmpty() {
        return getApplicationPolicies().isEmpty()
                && getServiceInstancePolicies().isEmpty()
                && getEndpointPolicies().isEmpty()
                && getQueryPolicies().isEmpty()
                && getHygienePolicies().isEmpty()
                && getLegacyPolicies().isEmpty()
                && getResourceNotificationPolicies().isEmpty();
    }

}


================================================
File: src/main/java/org/cftoolsuite/cfapp/domain/PoliciesValidator.java
================================================
package org.cftoolsuite.cfapp.domain;

import java.time.Duration;
import java.time.LocalDateTime;
import java.time.format.DateTimeParseException;
import java.util.Optional;

import org.apache.commons.lang3.StringUtils;
import org.cftoolsuite.cfapp.service.StacksCache;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import com.jayway.jsonpath.InvalidPathException;
import com.jayway.jsonpath.JsonPath;

import lombok.extern.slf4j.Slf4j;
@Slf4j
@Component
public class PoliciesValidator {

    private static final String REQUIRED_PROPERTIES_REJECTED_MESSAGE = "-- {} was rejected because required properties failed validation.";
    private static final String SCALE_INSTANCES_REJECTED_MESSAGE = "-- {} was rejected because instances-from and/or instances-to in options failed validation.";
    private static final String CHANGE_STACK_REJECTED_MESSAGE = "-- {} was rejected because stack-from and/or stack-to in options failed validation.";
    private static final String PARSING_REJECTED_MESSAGE = "-- {} was rejected because one or more of its properties could be parsed successfully. {}";
    private static final String DUAL_TIME_CONSTRAINTS_REJECTED_MESSAGE = "-- {} was rejected because it contained both from-datetime and from-duration in options. Choose only one time constraint.";
    private static final String HYGIENE_REJECTED_MESSAGE = "{} was rejected because days-since-last-update must be > 0 or equal to -1";
    private static final String LEGACY_REJECTED_MESSAGE = "{} was rejected because stacks must not be empty and must be a valid/installed stack";
    private static final String ENDPOINT_REJECTED_MESSAGE = "{} was rejected because endpoint must not be empty and must start with a /";
    private static final String JSONPATH_EXPRESSION_REJECTED_MESSAGE = "{} was rejected because a JSON path expression for endpoint is invalid";
    private static final String QUERY_REJECTED_MESSAGE = "-- {} was rejected because either name or sql was blank or sql did not start with SELECT.";
    private static final String EMAIL_NOTIFICATION_TEMPLATE_REJECTED_MESSAGE = "-- {} was rejected because either the email template did not contain valid email addresses for from/to or the subject/body was blank.";
    private static final String LEGACY_FILTER_REJECTED_MESSAGE = "-- {} was rejected because it must have only one filter. Choose either stacks or service-offerings filter.";
    private static final String RESOURCE_EMAIL_METADATA_REJECTED_MESSAGE = "-- {} was rejected because either the metadata template did not contain valid resource type or the labels/domain was blank.";


    private final StacksCache stacksCache;

    @Autowired
    public PoliciesValidator(StacksCache stacksCache) {
        this.stacksCache = stacksCache;
    }

    public boolean validate(ApplicationPolicy policy) {
        boolean hasId = Optional.ofNullable(policy.getId()).isPresent();
        boolean hasOperation = Optional.ofNullable(policy.getOperation()).isPresent();
        boolean hasState = Optional.ofNullable(policy.getState()).isPresent();
        boolean hasFromDateTime = Optional.ofNullable(policy.getOption("from-datetime", LocalDateTime.class)).isPresent();
        boolean hasFromDuration = Optional.ofNullable(policy.getOption("from-duration", String.class)).isPresent();
        boolean valid = !hasId && hasOperation && hasState;
        if (hasOperation) {
            try {
                ApplicationOperation op = ApplicationOperation.from(policy.getOperation());
                if (op.equals(ApplicationOperation.SCALE_INSTANCES)) {
                    Integer instancesFrom = policy.getOption("instances-from", Integer.class);
                    Integer instancesTo = policy.getOption("instances-to", Integer.class);
                    if (instancesFrom == null || instancesTo == null || instancesFrom < 1 || instancesTo < 1 || instancesFrom.equals(instancesTo)) {
                        valid = false;
                        log.warn(SCALE_INSTANCES_REJECTED_MESSAGE, policy.toString());
                    }
                }
                if (op.equals(ApplicationOperation.CHANGE_STACK)) {
                    String stackFrom = policy.getOption("stack-from", String.class);
                    String stackTo = policy.getOption("stack-to", String.class);
                    if (!stacksCache.contains(stackFrom) || !stacksCache.contains(stackTo) || stackFrom.equalsIgnoreCase(stackTo)) {
                        valid = false;
                        log.warn(CHANGE_STACK_REJECTED_MESSAGE, policy.toString());
                    }
                }
            } catch (IllegalArgumentException iae) {
                valid = false;
                log.warn(PARSING_REJECTED_MESSAGE, policy.toString(), iae.getMessage());
            }
        }
        if (hasState) {
            try {
                ApplicationState.from(policy.getState());
            } catch (IllegalArgumentException iae) {
                valid = false;
                log.warn(PARSING_REJECTED_MESSAGE, policy.toString(), iae.getMessage());
            }
        }
        if (hasFromDateTime && hasFromDuration) {
            valid = false;
            log.warn(DUAL_TIME_CONSTRAINTS_REJECTED_MESSAGE, policy.toString());
        }
        if (hasFromDuration) {
            try {
                Duration.parse(policy.getOption("from-duration", String.class));
            } catch (DateTimeParseException dtpe) {
                valid = false;
                log.warn(PARSING_REJECTED_MESSAGE, policy.toString(), dtpe.getMessage());
            }
        }
        if (valid == false) {
            log.warn(REQUIRED_PROPERTIES_REJECTED_MESSAGE, policy.toString());
        }
        return valid;
    }

    public boolean validate(EndpointPolicy policy) {
        boolean hasId = Optional.ofNullable(policy.getId()).isPresent();
        boolean hasEndpointRequests = Optional.ofNullable(policy.getEndpointRequests()).isPresent();
        boolean hasEmailNotificationTemplate = Optional.ofNullable(policy.getEmailNotificationTemplate()).isPresent();
        boolean valid = !hasId && hasEndpointRequests && hasEmailNotificationTemplate;
        if (hasEndpointRequests) {
            if (ObjectUtils.isEmpty(policy.getEndpointRequests())) {
                valid = false;
            } else {
                for (EndpointRequest er: policy.getEndpointRequests()) {
                    if (StringUtils.isBlank(er.getEndpoint()) || !er.getEndpoint().startsWith("/")) {
                        valid = false;
                        log.warn(ENDPOINT_REJECTED_MESSAGE, policy.toString());
                        break;
                    }
                    if (StringUtils.isNotBlank(er.getJsonPathExpression())) {
                        try {
                            JsonPath.compile(er.getJsonPathExpression());
                        } catch (InvalidPathException e) {
                            valid = false;
                            log.warn(JSONPATH_EXPRESSION_REJECTED_MESSAGE, policy.toString());
                            break;
                        }
                    }
                }
            }
        }
        if (hasEmailNotificationTemplate) {
            if (!policy.getEmailNotificationTemplate().isValid()) {
                valid = false;
                log.warn(EMAIL_NOTIFICATION_TEMPLATE_REJECTED_MESSAGE, policy.toString());
            }
        }
        if (valid == false) {
            log.warn(REQUIRED_PROPERTIES_REJECTED_MESSAGE, policy.toString());
        }
        return valid;
    }

    public boolean validate(HygienePolicy policy) {
        boolean hasId = Optional.ofNullable(policy.getId()).isPresent();
        boolean hasDaysSinceLastUpdate = Optional.ofNullable(policy.getDaysSinceLastUpdate()).isPresent();
        boolean hasOperatorTemplate = Optional.ofNullable(policy.getOperatorTemplate()).isPresent();
        boolean hasNotifyeeTemplate = Optional.ofNullable(policy.getNotifyeeTemplate()).isPresent();
        boolean valid = !hasId && hasDaysSinceLastUpdate && hasOperatorTemplate;
        if (hasDaysSinceLastUpdate) {
            if (policy.getDaysSinceLastUpdate() == 0 || policy.getDaysSinceLastUpdate() < -1) {
                valid = false;
                log.warn(HYGIENE_REJECTED_MESSAGE, policy.toString());
            }
        }
        if (hasOperatorTemplate) {
            if (!policy.getOperatorTemplate().isValid()) {
                valid = false;
                log.warn(EMAIL_NOTIFICATION_TEMPLATE_REJECTED_MESSAGE, policy.toString());
            }
        }
        if (hasNotifyeeTemplate) {
            if (!policy.getNotifyeeTemplate().isValid()) {
                valid = false;
                log.warn(EMAIL_NOTIFICATION_TEMPLATE_REJECTED_MESSAGE, policy.toString());
            }
        }
        if (valid == false) {
            log.warn(REQUIRED_PROPERTIES_REJECTED_MESSAGE, policy.toString());
        }
        return valid;
    }

    public boolean validate(ResourceNotificationPolicy policy) {
        boolean hasId = Optional.ofNullable(policy.getId()).isPresent();
        boolean hasResourceEmailTemplate = Optional.ofNullable(policy.getResourceEmailTemplate()).isPresent();
        boolean hasResourceEmailMetadata = Optional.ofNullable(policy.getResourceEmailMetadata()).isPresent();

        boolean valid = !hasId && hasResourceEmailTemplate && hasResourceEmailMetadata;
        if (hasResourceEmailTemplate) {
            if (!policy.getResourceEmailTemplate().isValid()) {
                valid = false;
                log.warn(EMAIL_NOTIFICATION_TEMPLATE_REJECTED_MESSAGE, policy.toString());
            }
        }
        if (hasResourceEmailMetadata) {
            if (!policy.getResourceEmailMetadata().isValid()) {
                valid = false;
                log.warn(RESOURCE_EMAIL_METADATA_REJECTED_MESSAGE, policy.toString());
            }
        }
        if (valid == false) {
            log.warn(REQUIRED_PROPERTIES_REJECTED_MESSAGE, policy.toString());
        }
        return valid;
    }

    public boolean validate(LegacyPolicy policy) {
        boolean hasId = Optional.ofNullable(policy.getId()).isPresent();
        boolean hasOperatorTemplate = Optional.ofNullable(policy.getOperatorTemplate()).isPresent();
        boolean hasNotifyeeTemplate = Optional.ofNullable(policy.getNotifyeeTemplate()).isPresent();
        boolean valid = !hasId && hasOperatorTemplate;
        if (policy.getStacks().isEmpty() == policy.getServiceOfferings().isEmpty()) {
            valid = false;
            log.warn(LEGACY_FILTER_REJECTED_MESSAGE,policy.toString());
        } else if (!policy.getStacks().isEmpty()) {
            for (String stack: policy.getStacks()) {
                if (!stacksCache.contains(stack) ) {
                    valid = false;
                    log.warn(LEGACY_REJECTED_MESSAGE, policy.toString());
                    break;
                }
            }
        }
        if (hasOperatorTemplate) {
            if (!policy.getOperatorTemplate().isValid()) {
                valid = false;
                log.warn(EMAIL_NOTIFICATION_TEMPLATE_REJECTED_MESSAGE, policy.toString());
            }
        }
        if (hasNotifyeeTemplate) {
            if (!policy.getNotifyeeTemplate().isValid()) {
                valid = false;
                log.warn(EMAIL_NOTIFICATION_TEMPLATE_REJECTED_MESSAGE, policy.toString());
            }
        }
        if (valid == false) {
            log.warn(REQUIRED_PROPERTIES_REJECTED_MESSAGE, policy.toString());
        }
        return valid;
    }

    public boolean validate(QueryPolicy policy) {
        boolean hasId = Optional.ofNullable(policy.getId()).isPresent();
        boolean hasQueries = Optional.ofNullable(policy.getQueries()).isPresent();
        boolean hasEmailNotificationTemplate = Optional.ofNullable(policy.getEmailNotificationTemplate()).isPresent();
        boolean valid = !hasId && hasQueries && hasEmailNotificationTemplate;
        if (hasQueries) {
            if (ObjectUtils.isEmpty(policy.getQueries())) {
                valid = false;
            } else {
                for (Query q: policy.getQueries()) {
                    if (!q.isValid()) {
                        valid = false;
                        log.warn(QUERY_REJECTED_MESSAGE, policy.toString());
                        break;
                    }
                }
            }
        }
        if (hasEmailNotificationTemplate) {
            if (!policy.getEmailNotificationTemplate().isValid()) {
                valid = false;
                log.warn(EMAIL_NOTIFICATION_TEMPLATE_REJECTED_MESSAGE, policy.toString());
            }
        }
        if (valid == false) {
            log.warn(REQUIRED_PROPERTIES_REJECTED_MESSAGE, policy.toString());
        }
        return valid;
    }

    public boolean validate(ServiceInstancePolicy policy) {
        boolean hasId = Optional.ofNullable(policy.getId()).isPresent();
        boolean hasOperation = Optional.ofNullable(policy.getOperation()).isPresent();
        boolean hasFromDateTime = Optional.ofNullable(policy.getOption("from-datetime", LocalDateTime.class)).isPresent();
        boolean hasFromDuration = Optional.ofNullable(policy.getOption("from-duration", String.class)).isPresent();
        boolean valid = !hasId && hasOperation;
        if (hasOperation) {
            try {
                ServiceInstanceOperation.from(policy.getOperation());
            } catch (IllegalArgumentException iae) {
                valid = false;
                log.warn(PARSING_REJECTED_MESSAGE, policy.toString(), iae.getMessage());
            }
        }
        if (hasFromDateTime && hasFromDuration) {
            valid = false;
            log.warn(DUAL_TIME_CONSTRAINTS_REJECTED_MESSAGE, policy.toString());
        }
        if (hasFromDuration) {
            try {
                Duration.parse(policy.getOption("from-duration", String.class));
            } catch (DateTimeParseException dtpe) {
                valid = false;
                log.warn(PARSING_REJECTED_MESSAGE, policy.toString(), dtpe.getMessage());
            }
        }
        if (valid == false) {
            log.warn(REQUIRED_PROPERTIES_REJECTED_MESSAGE, policy.toString());
        }
        return valid;
    }
}


================================================
File: src/main/java/org/cftoolsuite/cfapp/domain/Policy.java
================================================
package org.cftoolsuite.cfapp.domain;

public interface Policy extends HasIdentifier, HasCronExpression {}


================================================
File: src/main/java/org/cftoolsuite/cfapp/domain/Query.java
================================================
package org.cftoolsuite.cfapp.domain;

import org.apache.commons.lang3.StringUtils;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;

import lombok.Builder;
import lombok.Getter;

@Builder
@JsonInclude(JsonInclude.Include.NON_NULL)
@JsonPropertyOrder({ "name", "description", "sql" })
@Getter
public class Query {

    @JsonProperty("name")
    private String name;

    @JsonProperty("description")
    private String description;

    @JsonProperty("sql")
    private String sql;

    @JsonCreator
    public Query(
            @JsonProperty("name") String name,
            @JsonProperty("description") String description,
            @JsonProperty("sql") String sql
            ) {
        this.name = name;
        this.description = description;
        this.sql = sql;
    }

    @JsonIgnore
    public boolean isValid() {
        return StringUtils.isNotBlank(name)
                && StringUtils.isNotBlank(sql)
                && sql.toLowerCase().startsWith("select");
    }
}


================================================
File: src/main/java/org/cftoolsuite/cfapp/domain/QueryPolicy.java
================================================
package org.cftoolsuite.cfapp.domain;

import java.util.Collections;
import java.util.HashSet;
import java.util.Set;

import org.apache.commons.lang3.StringUtils;
import org.springframework.data.annotation.Id;
import org.springframework.data.relational.core.mapping.Column;
import org.springframework.data.relational.core.mapping.Table;
import org.springframework.util.CollectionUtils;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;
import com.fasterxml.uuid.Generators;

import lombok.Builder;
import lombok.Builder.Default;
import lombok.Getter;
import lombok.ToString;

@Builder
@JsonInclude(JsonInclude.Include.NON_NULL)
@JsonPropertyOrder({ "id", "git-commit", "description", "queries", "email-notification-template", "cron-expression" })
@Getter
@ToString
@Table("query_policy")
public class QueryPolicy implements Policy {

    public static QueryPolicy seed(QueryPolicy policy) {
        return QueryPolicy
                .builder()
                .description(policy.getDescription())
                .queries(policy.getQueries())
                .emailNotificationTemplate(policy.getEmailNotificationTemplate())
                .cronExpression(policy.getCronExpression())
                .build();
    }

    public static QueryPolicy seedWith(QueryPolicy policy, String gitCommit) {
        return QueryPolicy
                .builder()
                .gitCommit(gitCommit)
                .description(policy.getDescription())
                .queries(policy.getQueries())
                .emailNotificationTemplate(policy.getEmailNotificationTemplate())
                .cronExpression(policy.getCronExpression())
                .build();
    }

    @Id
    @JsonIgnore
    private Long pk;

    @Default
    @JsonProperty("id")
    private String id = Generators.timeBasedGenerator().generate().toString();

    @JsonProperty("git-commit")
    @Column("git_commit")
    private String gitCommit;

    @JsonProperty("description")
    private String description;

    @Default
    @JsonProperty("queries")
    private Set<Query> queries = new HashSet<>();

    @JsonProperty("email-notification-template")
    private EmailNotificationTemplate emailNotificationTemplate;

    @JsonProperty("cron-expression")
    @Column("cron_expression")
    private String cronExpression;

    @JsonCreator
    QueryPolicy(
            @JsonProperty("pk") Long pk,
            @JsonProperty("id") String id,
            @JsonProperty("git-commit") String gitCommit,
            @JsonProperty("description") String description,
            @JsonProperty("queries") Set<Query> queries,
            @JsonProperty("email-notification-template") EmailNotificationTemplate emailNotificationTemplate,
            @JsonProperty("cron-expression") String cronExpression) {
        this.pk = pk;
        this.id = id;
        this.gitCommit = gitCommit;
        this.description = description;
        this.queries = queries;
        this.emailNotificationTemplate = emailNotificationTemplate;
        this.cronExpression = cronExpression;
    }

    public String getCronExpression() {
        return StringUtils.isBlank(cronExpression) ? defaultCronExpression(): cronExpression;
    }

    @JsonIgnore
    public Long getPk() {
        return pk;
    }

    public Set<Query> getQueries() {
        return CollectionUtils.isEmpty(queries) ? new HashSet<>(): Collections.unmodifiableSet(queries);
    }

}


================================================
File: src/main/java/org/cftoolsuite/cfapp/domain/QueryPolicyReadConverter.java
================================================
package org.cftoolsuite.cfapp.domain;

import java.io.IOException;
import java.util.Set;

import org.springframework.core.convert.converter.Converter;
import org.springframework.data.convert.ReadingConverter;
import org.springframework.stereotype.Indexed;

import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;

import io.r2dbc.spi.Row;

@Indexed
@ReadingConverter
public class QueryPolicyReadConverter implements Converter<Row, QueryPolicy> {

    private ObjectMapper mapper = new ObjectMapper();

    @Override
    public QueryPolicy convert(Row source) {
        return
                QueryPolicy
                .builder()
                .pk(source.get("pk", Long.class))
                .id(source.get("id", String.class))
                .gitCommit(source.get("git_commit", String.class))
                .description(source.get("description", String.class))
                .queries(readQueries(source.get("queries", String.class) == null ? "[]" : source.get("queries", String.class)))
                .emailNotificationTemplate(
                        readEmailNotificationTemplate(
                                source.get("email_notification_template", String.class) == null
                                ? "{}"
                                        : source.get("email_notification_template", String.class)))
                .cronExpression(source.get("cron_expression", String.class))
                .build();
    }

    private EmailNotificationTemplate readEmailNotificationTemplate(String value) {
        try {
            return mapper.readValue(value, EmailNotificationTemplate.class);
        } catch (IOException ioe) {
            throw new RuntimeException("Problem reading email notification template", ioe);
        }
    }

    private Set<Query> readQueries(String value) {
        try {
            return mapper.readValue(value, new TypeReference<Set<Query>>() {});
        } catch (IOException ioe) {
            throw new RuntimeException("Problem reading queries", ioe);
        }
    }
}



================================================
File: src/main/java/org/cftoolsuite/cfapp/domain/QueryPolicyWriteConverter.java
================================================
package org.cftoolsuite.cfapp.domain;

import java.util.Set;

import org.springframework.core.convert.converter.Converter;
import org.springframework.data.convert.WritingConverter;
import org.springframework.data.r2dbc.mapping.OutboundRow;
import org.springframework.r2dbc.core.Parameter;
import org.springframework.stereotype.Indexed;
import org.springframework.util.CollectionUtils;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;

@Indexed
@WritingConverter
public class QueryPolicyWriteConverter implements Converter<QueryPolicy, OutboundRow> {

    private ObjectMapper mapper = new ObjectMapper();

    @Override
    public OutboundRow convert(QueryPolicy source) {
        OutboundRow row = new OutboundRow();
        row.put("id", Parameter.fromOrEmpty(source.getId(), String.class));
        row.put("git_commit", Parameter.fromOrEmpty(source.getGitCommit(), String.class));
        row.put("description", Parameter.fromOrEmpty(source.getDescription(), String.class));
        row.put("queries", Parameter.fromOrEmpty(CollectionUtils.isEmpty(source.getQueries()) ? null : writeQueries(source.getQueries()), String.class));
        row.put("email_notification_template", Parameter.fromOrEmpty(source.getEmailNotificationTemplate() != null ? writeEmailNotificationTemplate(source.getEmailNotificationTemplate()) : null, String.class));
        row.put("cron_expression", Parameter.fromOrEmpty(source.getCronExpression(), String.class));
        return row;
    }

    private String writeEmailNotificationTemplate(EmailNotificationTemplate value) {
        try {
            return mapper.writeValueAsString(value);
        } catch (JsonProcessingException jpe) {
            throw new RuntimeException("Problem writing email notification template", jpe);
        }
    }

    private String writeQueries(Set<Query> value) {
        try {
            return mapper.writeValueAsString(value);
        } catch (JsonProcessingException jpe) {
            throw new RuntimeException("Problem writing queries", jpe);
        }
    }
}


================================================
File: src/main/java/org/cftoolsuite/cfapp/domain/Resource.java
================================================
package org.cftoolsuite.cfapp.domain;

import java.time.Instant;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;

import lombok.Builder;
import lombok.Getter;

@Builder
@Getter
@JsonPropertyOrder({ "guid","name","created_at", "updated_at", "metadata" })
public class Resource {

    @JsonProperty("guid")
    private String guid;

    @JsonProperty("name")
    private String name;

    @JsonProperty("created_at")
    private Instant createdAt;

    @JsonProperty("updated_at")
    private Instant updatedAt;

    @JsonProperty("metadata")
    private EmbeddedMetadata metadata;

    @JsonCreator
    public Resource(

        @JsonProperty("guid") String guid,
        @JsonProperty("name") String name,
        @JsonProperty("created_at") Instant createdAt,
        @JsonProperty("updated_at") Instant updatedAt,
        @JsonProperty("metadata") EmbeddedMetadata metadata) {

        this.guid = guid;
        this.name = name;
        this.createdAt = createdAt;
        this.updatedAt = updatedAt;
        this.metadata = metadata;
    }

}


================================================
File: src/main/java/org/cftoolsuite/cfapp/domain/ResourceEmailMetadata.java
================================================
package org.cftoolsuite.cfapp.domain;

import java.util.ArrayList;
import java.util.List;

import org.apache.commons.lang3.StringUtils;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;

import lombok.Builder;
import lombok.Builder.Default;
import lombok.Getter;

@Builder
@JsonInclude(JsonInclude.Include.NON_NULL)
@JsonPropertyOrder({ "resource", "labels", "email-domain" })
@Getter
public class ResourceEmailMetadata {

    @JsonProperty("resource")
    private String resource;

    @Default
    @JsonProperty("labels")
    private List<String> labels = new ArrayList<>();

    @JsonProperty("email-domain")
    private String emailDomain;


    @JsonCreator
    public ResourceEmailMetadata(
            @JsonProperty("resource") String resource,
            @JsonProperty("labels") List<String> labels,
            @JsonProperty("email-domain") String emailDomain
            ) {
        this.resource = resource;
        this.labels = labels;
        this.emailDomain = emailDomain;
    }

    @JsonIgnore
    public boolean isValid() {
        return isValidResource(resource)
                && !ObjectUtils.isEmpty(labels)
                && StringUtils.isNotBlank(emailDomain);
    }

    private static boolean isValidResource(String resource) {
        ResourceType[] resourceTypes = ResourceType.values();
        for (ResourceType resourceType : resourceTypes)
            if (resourceType.getId().equals(resource))
                return true;
        return false;
    }

}


================================================
File: src/main/java/org/cftoolsuite/cfapp/domain/ResourceNotificationPolicy.java
================================================
package org.cftoolsuite.cfapp.domain;

import java.util.Collections;
import java.util.HashSet;
import java.util.Set;

import org.apache.commons.lang3.StringUtils;
import org.springframework.data.annotation.Id;
import org.springframework.data.relational.core.mapping.Column;
import org.springframework.data.relational.core.mapping.Table;
import org.springframework.util.CollectionUtils;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;
import com.fasterxml.uuid.Generators;

import lombok.Builder;
import lombok.Builder.Default;
import lombok.Getter;

@Builder
@JsonInclude(JsonInclude.Include.NON_NULL)
@JsonPropertyOrder({ "id", "git-commit", "resource-email-template", "resource-email-metadata", "resource-whitelist", "resource-blacklist", "cron-expression" })
@Getter
@Table("resource_notification_policy")
public class ResourceNotificationPolicy implements Policy {

    public static ResourceNotificationPolicy seed(ResourceNotificationPolicy policy) {
        return ResourceNotificationPolicy
                .builder()
                .resourceEmailTemplate(policy.getResourceEmailTemplate())
                .resourceEmailMetadata(policy.getResourceEmailMetadata())
                .resourceWhiteList(policy.getResourceWhiteList())
                .resourceBlackList(policy.getResourceBlackList())
                .cronExpression(policy.getCronExpression())
                .build();
    }

    public static ResourceNotificationPolicy seedWith(ResourceNotificationPolicy policy, String gitCommit) {
        return ResourceNotificationPolicy
                .builder()
                .gitCommit(gitCommit)
                .resourceEmailTemplate(policy.getResourceEmailTemplate())
                .resourceEmailMetadata(policy.getResourceEmailMetadata())
                .resourceWhiteList(policy.getResourceWhiteList())
                .resourceBlackList(policy.getResourceBlackList())
                .cronExpression(policy.getCronExpression())
                .build();
    }

    @Id
    @JsonIgnore
    private Long pk;

    @Default
    @JsonProperty("id")
    private String id = Generators.timeBasedGenerator().generate().toString();

    @JsonProperty("git-commit")
    @Column("git_commit")
    private String gitCommit;

    @JsonProperty("resource-email-template")
    @Column("resource_email_template")
    private EmailNotificationTemplate resourceEmailTemplate;


    @JsonProperty("resource-email-metadata")
    @Column("resource_email_metadata")
    private ResourceEmailMetadata resourceEmailMetadata;

    @Default
    @JsonProperty("resource-whitelist")
    @Column("resource_whitelist")
    private Set<String> resourceWhiteList = new HashSet<>();

    @Default
    @JsonProperty("resource-blacklist")
    @Column("resource_blacklist")
    private Set<String> resourceBlackList = new HashSet<>();

    @JsonProperty("cron-expression")
    @Column("cron_expression")
    private String cronExpression;

    @JsonCreator
    public ResourceNotificationPolicy(
            @JsonProperty("pk") Long pk,
            @JsonProperty("id") String id,
            @JsonProperty("git-commit") String gitCommit,
            @JsonProperty("resource-email-template") EmailNotificationTemplate resourceEmailTemplate,
            @JsonProperty("resource-email-metadata") ResourceEmailMetadata resourceEmailMetadata,
            @JsonProperty("resource-whitelist") Set<String> resourceWhiteList,
            @JsonProperty("resource-blacklist") Set<String> resourceBlackList,
            @JsonProperty("cron-expression") String cronExpression
            ) {
        this.pk = pk;
        this.id = id;
        this.gitCommit = gitCommit;
        this.resourceEmailTemplate = resourceEmailTemplate;
        this.resourceEmailMetadata = resourceEmailMetadata;
        this.resourceWhiteList = resourceWhiteList;
        this.resourceBlackList = resourceBlackList;
        this.cronExpression = cronExpression;
    }

    public String getCronExpression() {
        return StringUtils.isBlank(cronExpression) ? defaultCronExpression(): cronExpression;
    }

    @JsonIgnore
    public Long getPk() {
        return pk;
    }

    public Set<String> getResourceWhiteList() {
        return CollectionUtils.isEmpty(resourceWhiteList) ? new HashSet<>() : Collections.unmodifiableSet(resourceWhiteList);
    }

    public Set<String> getResourceBlackList() {
        return CollectionUtils.isEmpty(resourceBlackList) ? new HashSet<>() : Collections.unmodifiableSet(resourceBlackList);
    }

}


================================================
File: src/main/java/org/cftoolsuite/cfapp/domain/ResourceNotificationPolicyReadConverter.java
================================================
package org.cftoolsuite.cfapp.domain;

import java.io.IOException;

import org.cftoolsuite.cfapp.util.CsvUtil;
import org.springframework.core.convert.converter.Converter;
import org.springframework.data.convert.ReadingConverter;
import org.springframework.stereotype.Indexed;

import com.fasterxml.jackson.databind.ObjectMapper;

import io.r2dbc.spi.Row;

@Indexed
@ReadingConverter
public class ResourceNotificationPolicyReadConverter implements Converter<Row, ResourceNotificationPolicy> {

    private ObjectMapper mapper = new ObjectMapper();

    @Override
    public ResourceNotificationPolicy convert(Row source) {
        return
                ResourceNotificationPolicy
                .builder()
                .pk(source.get("pk", Long.class))
                .id(source.get("id", String.class))
                .gitCommit(source.get("git_commit", String.class))
                .resourceEmailTemplate(readEmailNotificationTemplate(source.get("resource_email_template", String.class) == null ? "{}": source.get("resource_email_template", String.class)))
                .resourceEmailMetadata(readResourceEmailMetadata(source.get("resource_email_metadata", String.class) == null ? "{}": source.get("resource_email_metadata", String.class)))
                .resourceWhiteList(CsvUtil.parse(source.get("resource_whitelist", String.class)))
                .resourceBlackList(CsvUtil.parse(source.get("resource_blacklist", String.class)))
                .cronExpression(source.get("cron_expression", String.class))
                .build();
    }

    private EmailNotificationTemplate readEmailNotificationTemplate(String value) {
        try {
            return mapper.readValue(value, EmailNotificationTemplate.class);
        } catch (IOException ioe) {
            throw new RuntimeException("Problem reading email notification template", ioe);
        }
    }

    private ResourceEmailMetadata readResourceEmailMetadata(String value) {
        try {
            return mapper.readValue(value, ResourceEmailMetadata.class);
        } catch (IOException ioe) {
            throw new RuntimeException("Problem reading email notification template", ioe);
        }
    }


}



================================================
File: src/main/java/org/cftoolsuite/cfapp/domain/ResourceNotificationPolicyWriteConverter.java
================================================
package org.cftoolsuite.cfapp.domain;

import java.util.stream.Collectors;

import org.apache.commons.lang3.StringUtils;
import org.springframework.core.convert.converter.Converter;
import org.springframework.data.convert.WritingConverter;
import org.springframework.data.r2dbc.mapping.OutboundRow;
import org.springframework.r2dbc.core.Parameter;
import org.springframework.stereotype.Indexed;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;

@Indexed
@WritingConverter
public class ResourceNotificationPolicyWriteConverter implements Converter<ResourceNotificationPolicy, OutboundRow> {

    private ObjectMapper mapper = new ObjectMapper();

    @Override
    public OutboundRow convert(ResourceNotificationPolicy source) {
        OutboundRow row = new OutboundRow();
        row.put("id", Parameter.fromOrEmpty(source.getId(), String.class));
        row.put("git_commit", Parameter.fromOrEmpty(source.getGitCommit(), String.class));
        row.put("resource_email_template", Parameter.fromOrEmpty(source.getResourceEmailTemplate() != null ? writeEmailNotificationTemplate(source.getResourceEmailTemplate()) : null, String.class));
        row.put("resource_email_metadata", Parameter.fromOrEmpty(source.getResourceEmailMetadata() != null ? writeResourceEmailMetadata(source.getResourceEmailMetadata()) : null, String.class));
        row.put("resource_whitelist", Parameter.fromOrEmpty(source.getResourceWhiteList().stream().filter(StringUtils::isNotBlank).collect(Collectors.joining(",")), String.class));
        row.put("resource_blacklist", Parameter.fromOrEmpty(source.getResourceBlackList().stream().filter(StringUtils::isNotBlank).collect(Collectors.joining(",")), String.class));
        row.put("cron_expression", Parameter.fromOrEmpty(source.getCronExpression(), String.class));
        return row;
    }

    private String writeEmailNotificationTemplate(EmailNotificationTemplate value) {
        try {
            return mapper.writeValueAsString(value);
        } catch (JsonProcessingException jpe) {
            throw new RuntimeException("Problem writing email notification template", jpe);
        }
    }

    private String writeResourceEmailMetadata(ResourceEmailMetadata value) {
        try {
            return mapper.writeValueAsString(value);
        } catch (JsonProcessingException jpe) {
            throw new RuntimeException("Problem writing email notification template", jpe);
        }
    }
}


================================================
File: src/main/java/org/cftoolsuite/cfapp/domain/ResourceType.java
================================================
package org.cftoolsuite.cfapp.domain;

import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;

import org.springframework.util.Assert;

import com.fasterxml.jackson.annotation.JsonValue;

// @see https://v3-apidocs.cloudfoundry.org/version/3.82.0/index.html#resources
// A subset of the available resources accessed via cf v3 api
public enum ResourceType {

    APPS("apps"),
    BUILDS("builds"),
    BUILDPACKS("buildpacks"),
    DEPLOYMENTS("deployments"),
    DOMAINS("domains"),
    DROPLETS("droplets"),
    ISOLATION_SEGMENTS("isolation_segments"),
    ORGS("organizations"),
    PACKAGES("packages"),
    PROCESSES("processes"),
    SPACES("spaces"),
    STACKS("stacks"),
    TASKS("tasks"),

    // experimental resources
    REVISIONS("revisions"),
    SECURITY_GROUPS("security_groups"),
    SERVICE_BINDINGS("service_bindings"),
    SERVICE_BROKERS("service_brokers"),
    SERVICE_OFFERINGS("service_offerings"),
    SERVICE_PLANS("service_plans");


    public static ResourceType from(String id) {
        ResourceType result = null;
        List<ResourceType> candidates = Arrays.asList(ResourceType.values()).stream().filter(et -> et.getId().equalsIgnoreCase(id)).collect(Collectors.toList());
        if (candidates != null && candidates.size() == 1) {
            result = candidates.get(0);
        }
        Assert.isTrue(result != null, "Not a valid resource type identifier");
        return result;
    }

    private String id;

    ResourceType(String id) {
        this.id = id;
    }

    @JsonValue
    public String getId() {
        return id;
    }
}


================================================
File: src/main/java/org/cftoolsuite/cfapp/domain/Resources.java
================================================
package org.cftoolsuite.cfapp.domain;


import java.util.ArrayList;
import java.util.List;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;

import lombok.Builder;
import lombok.Getter;
import lombok.Builder.Default;

@Builder
@Getter
@JsonPropertyOrder({ "resources"})
public class Resources {

    @Default
    @JsonProperty("resources")
    private List<Resource> resources = new ArrayList<>();

    @JsonProperty("pagination")
    private Pagination pagination;

    @JsonCreator
    public Resources(   @JsonProperty("resources") List<Resource> resources,
                        @JsonProperty("pagination") Pagination pagination
    ) {
        this.resources = resources;
        this.pagination = pagination;
    }
}

================================================
File: src/main/java/org/cftoolsuite/cfapp/domain/ServiceInstanceCounts.java
================================================
package org.cftoolsuite.cfapp.domain;

import java.util.HashMap;
import java.util.Map;

import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;

import lombok.Builder;
import lombok.Builder.Default;
import lombok.Getter;
import lombok.ToString;

@Builder
@Getter
@ToString
@JsonPropertyOrder({ "by-organization", "by-service", "by-service-and-plan", "total-service-instances", "velocity" })
public class ServiceInstanceCounts {

    @Default
    @JsonProperty("by-organization")
    private Map<String, Long> byOrganization = new HashMap<>();

    @Default
    @JsonProperty("by-service")
    private Map<String, Long> byService = new HashMap<>();

    @Default
    @JsonProperty("by-service-and-plan")
    private Map<String, Long> byServiceAndPlan = new HashMap<>();

    @Default
    @JsonProperty("total-service-instances")
    private Long totalServiceInstances = 0L;

    @Default
    @JsonProperty("velocity")
    private Map<String, Long> velocity = new HashMap<>();
}


================================================
File: src/main/java/org/cftoolsuite/cfapp/domain/ServiceInstanceDetail.java
================================================
package org.cftoolsuite.cfapp.domain;

import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

import org.apache.commons.lang3.StringUtils;
import org.springframework.data.annotation.Id;
import org.springframework.data.relational.core.mapping.Column;
import org.springframework.data.relational.core.mapping.Table;

import com.fasterxml.jackson.annotation.JsonIgnore;

import lombok.Builder;
import lombok.Builder.Default;
import lombok.EqualsAndHashCode;
import lombok.Getter;
import lombok.ToString;

@Builder
@Getter
@EqualsAndHashCode
@ToString
@Table("service_instance_detail")
public class ServiceInstanceDetail {

    @Id
    @JsonIgnore
    private Long pk;
    private String organization;
    private String space;
    private String serviceInstanceId;
    @Column("service_name")
    private String name;
    private String service;

    private String description;

    private String plan;
    private String type;
    @Default
    @Column("bound_applications")
    private List<String> applications = new ArrayList<>();
    private String lastOperation;

    private LocalDateTime lastUpdated;

    private String dashboardUrl;

    private String requestedState;

    public static ServiceInstanceDetailBuilder from(ServiceInstanceDetail detail) {
        return ServiceInstanceDetail
                .builder()
                .pk(detail.getPk())
                .organization(detail.getOrganization())
                .space(detail.getSpace())
                .serviceInstanceId(detail.getServiceInstanceId())
                .name(detail.getName())
                .service(detail.getService())
                .description(detail.getDescription())
                .plan(detail.getPlan())
                .type(detail.getType())
                .applications(detail.getApplications())
                .lastOperation(detail.getLastOperation())
                .lastUpdated(detail.getLastUpdated())
                .dashboardUrl(detail.getDashboardUrl())
                .requestedState(detail.getRequestedState());
    }

    public static String headers() {
        return String.join(",", "organization", "space", "service instance id",
                "name", "service", "description", "plan", "type", "bound applications", "last operation", "last updated", "dashboard url", "requested state");
    }

    private static String wrap(String value) {
        return value != null ? StringUtils.wrap(value, '"') : StringUtils.wrap("", '"');
    }

    public String toCsv() {
        return String.join(",", wrap(getOrganization()), wrap(getSpace()), wrap(getServiceInstanceId()), wrap(getName()),
                wrap(getService()), wrap(getDescription()), wrap(getPlan()), wrap(getType()),
                wrap(String.join(",", getApplications() != null ? getApplications(): Collections.emptyList())), wrap(getLastOperation()),
                wrap(getLastUpdated() != null ? getLastUpdated().toString() : ""), wrap(getDashboardUrl()),
                wrap(getRequestedState()));
    }

}


================================================
File: src/main/java/org/cftoolsuite/cfapp/domain/ServiceInstanceDetailReadConverter.java
================================================
package org.cftoolsuite.cfapp.domain;

import java.time.LocalDateTime;

import org.springframework.core.convert.converter.Converter;
import org.springframework.data.convert.ReadingConverter;
import org.springframework.stereotype.Indexed;

import io.r2dbc.spi.Row;

@Indexed
@ReadingConverter
public class ServiceInstanceDetailReadConverter implements Converter<Row, ServiceInstanceDetail> {

    @Override
    public ServiceInstanceDetail convert(Row source) {
        return
                ServiceInstanceDetail
                .builder()
                .pk(source.get("pk", Long.class))
                .organization(Defaults.getColumnValue(source, "organization", String.class))
                .space(Defaults.getColumnValue(source, "space", String.class))
                .serviceInstanceId(Defaults.getColumnValue(source, "service_instance_id", String.class))
                .name(Defaults.getColumnValue(source, "service_name", String.class))
                .service(Defaults.getColumnValue(source, "service", String.class))
                .description(Defaults.getColumnValue(source, "description", String.class))
                .type(Defaults.getColumnValue(source, "type", String.class))
                .plan(Defaults.getColumnValue(source, "plan", String.class))
                .applications(
                        Defaults.getColumnListOfStringValue(source, "bound_applications"))
                .lastOperation(Defaults.getColumnValue(source, "last_operation", String.class))
                .dashboardUrl(Defaults.getColumnValue(source, "dashboard_url", String.class))
                .lastUpdated(Defaults.getColumnValue(source, "last_updated", LocalDateTime.class))
                .requestedState(Defaults.getColumnValue(source, "requested_state", String.class))
                .build();
    }
}



================================================
File: src/main/java/org/cftoolsuite/cfapp/domain/ServiceInstanceDetailWriteConverter.java
================================================
package org.cftoolsuite.cfapp.domain;

import java.time.LocalDateTime;
import java.util.stream.Collectors;

import org.apache.commons.lang3.StringUtils;
import org.springframework.core.convert.converter.Converter;
import org.springframework.data.convert.WritingConverter;
import org.springframework.data.r2dbc.mapping.OutboundRow;
import org.springframework.r2dbc.core.Parameter;
import org.springframework.stereotype.Indexed;

@Indexed
@WritingConverter
public class ServiceInstanceDetailWriteConverter implements Converter<ServiceInstanceDetail, OutboundRow> {

    @Override
    public OutboundRow convert(ServiceInstanceDetail source) {
        OutboundRow row = new OutboundRow();
        row.put("organization", Parameter.fromOrEmpty(source.getOrganization(), String.class));
        row.put("space", Parameter.fromOrEmpty(source.getSpace(), String.class));
        row.put("service_instance_id", Parameter.fromOrEmpty(source.getServiceInstanceId(), String.class));
        row.put("service_name", Parameter.fromOrEmpty(source.getName(), String.class));
        row.put("service", Parameter.fromOrEmpty(source.getService(), String.class));
        row.put("description", Parameter.fromOrEmpty(source.getDescription(), String.class));
        row.put("plan", Parameter.fromOrEmpty(source.getPlan(), String.class));
        row.put("type", Parameter.fromOrEmpty(source.getType(), String.class));
        row.put("bound_applications", Parameter.fromOrEmpty(source.getApplications().stream().filter(StringUtils::isNotBlank).collect(Collectors.joining(",")), String.class));
        row.put("last_operation", Parameter.fromOrEmpty(source.getLastOperation(), String.class));
        row.put("dashboard_url", Parameter.fromOrEmpty(source.getDashboardUrl(), String.class));
        row.put("requested_state", Parameter.fromOrEmpty(source.getRequestedState(), String.class));
        row.put("last_updated", Parameter.fromOrEmpty(source.getLastUpdated(), LocalDateTime.class));
        return row;
    }

}


================================================
File: src/main/java/org/cftoolsuite/cfapp/domain/ServiceInstanceOperation.java
================================================
package org.cftoolsuite.cfapp.domain;

import java.util.Arrays;
import java.util.EnumMap;
import java.util.Map;
import java.util.stream.Collectors;

import org.cftoolsuite.cfapp.task.DeleteServiceInstancePolicyExecutorTask;
import org.cftoolsuite.cfapp.task.PolicyExecutorTask;
import org.springframework.util.Assert;

import com.fasterxml.jackson.annotation.JsonValue;

public enum ServiceInstanceOperation {

    DELETE("delete");

    private final String name;

    ServiceInstanceOperation(String name) {
        this.name = name;
    }

    static final Map<ServiceInstanceOperation, Class<? extends PolicyExecutorTask>> operationTaskMap = new EnumMap<>(ServiceInstanceOperation.class);
    static {
        operationTaskMap.put(ServiceInstanceOperation.DELETE, DeleteServiceInstancePolicyExecutorTask.class);
    }

    public static ServiceInstanceOperation from(String name) {
        Assert.hasText(name, "ServiceInstanceOperation must not be null or empty");
        ServiceInstanceOperation result = Arrays.asList(ServiceInstanceOperation.values()).stream().filter(s -> s.getName().equalsIgnoreCase(name)).collect(Collectors.toList()).get(0);
        Assert.notNull(result, String.format("Invalid ServiceInstanceOperation, name=%s", name));
        return result;
    }

    public static Class<? extends PolicyExecutorTask> getTaskType(String op) {
        return operationTaskMap.get(from(op));
    }

    @JsonValue
    public String getName() {
        return name;
    }
}


================================================
File: src/main/java/org/cftoolsuite/cfapp/domain/ServiceInstancePolicy.java
================================================
package org.cftoolsuite.cfapp.domain;

import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;

import org.apache.commons.lang3.StringUtils;
import org.springframework.data.annotation.Id;
import org.springframework.data.relational.core.mapping.Column;
import org.springframework.util.Assert;
import org.springframework.util.CollectionUtils;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;
import com.fasterxml.uuid.Generators;

import lombok.Builder;
import lombok.Builder.Default;
import lombok.Getter;
import lombok.ToString;

@Builder
@JsonInclude(JsonInclude.Include.NON_NULL)
@JsonPropertyOrder({ "id", "git-commit", "operation", "description", "options", "organization-whitelist", "cron-expression" })
@Getter
@ToString
public class ServiceInstancePolicy implements HasOrganizationWhiteList, Policy {

    public static ServiceInstancePolicy seed(ServiceInstancePolicy policy) {
        return ServiceInstancePolicy
                .builder()
                .description(policy.getDescription())
                .operation(policy.getOperation())
                .options(policy.getOptions())
                .organizationWhiteList(policy.getOrganizationWhiteList())
                .cronExpression(policy.getCronExpression())
                .build();
    }

    public static ServiceInstancePolicy seedWith(ServiceInstancePolicy policy, String gitCommit) {
        return ServiceInstancePolicy
                .builder()
                .gitCommit(gitCommit)
                .description(policy.getDescription())
                .operation(policy.getOperation())
                .options(policy.getOptions())
                .organizationWhiteList(policy.getOrganizationWhiteList())
                .cronExpression(policy.getCronExpression())
                .build();
    }

    public static String tableName() {
        return "service_instance_policy";
    }

    @Id
    @JsonIgnore
    private Long pk;

    @Default
    @JsonProperty("id")
    private String id = Generators.timeBasedGenerator().generate().toString();

    @JsonProperty("git-commit")
    @Column("git_commit")
    private String gitCommit;

    @JsonProperty("operation")
    private String operation;

    @JsonProperty("description")
    private String description;

    @Default
    @JsonProperty("options")
    private Map<String, Object> options = new HashMap<>();

    @Default
    @JsonProperty("organization-whitelist")
    private Set<String> organizationWhiteList = new HashSet<>();

    @JsonProperty("cron-expression")
    @Column("cron_expression")
    private String cronExpression;

    @JsonCreator
    ServiceInstancePolicy(
            @JsonProperty("pk") Long pk,
            @JsonProperty("id") String id,
            @JsonProperty("git-commit") String gitCommit,
            @JsonProperty("operation") String operation,
            @JsonProperty("description") String description,
            @JsonProperty("options") Map<String, Object> options,
            @JsonProperty("organization-whitelist") Set<String> organizationWhiteList,
            @JsonProperty("cron-expression") String cronExpression) {
        this.pk = pk;
        this.id = id;
        this.gitCommit = gitCommit;
        this.operation = operation;
        this.description = description;
        this.options = options;
        this.organizationWhiteList = organizationWhiteList;
        this.cronExpression = cronExpression;
    }

    public String getCronExpression() {
        return StringUtils.isBlank(cronExpression) ? defaultCronExpression(): cronExpression;
    }

    @JsonIgnore
    public <T> T getOption(String key, Class<T> type) {
        Assert.isTrue(StringUtils.isNotBlank(key), "Option key must not be blank.");
        Object value = options.get(key);
        if (value == null) {
            return null;
        }
        return type.cast(value);
    }

    public Map<String, Object> getOptions() {
        return CollectionUtils.isEmpty(options) ? new HashMap<>(): Collections.unmodifiableMap(options);
    }

    public Set<String> getOrganizationWhiteList() {
        return CollectionUtils.isEmpty(organizationWhiteList) ? new HashSet<>() : Collections.unmodifiableSet(organizationWhiteList);
    }

    @JsonIgnore
    public Long getPk() {
        return pk;
    }
}


================================================
File: src/main/java/org/cftoolsuite/cfapp/domain/ServiceInstancePolicyReadConverter.java
================================================
package org.cftoolsuite.cfapp.domain;

import java.io.IOException;
import java.util.Map;

import org.cftoolsuite.cfapp.util.CsvUtil;
import org.springframework.core.convert.converter.Converter;
import org.springframework.data.convert.ReadingConverter;
import org.springframework.stereotype.Indexed;

import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;

import io.r2dbc.spi.Row;

@Indexed
@ReadingConverter
public class ServiceInstancePolicyReadConverter implements Converter<Row, ServiceInstancePolicy> {

    private ObjectMapper mapper = new ObjectMapper();

    @Override
    public ServiceInstancePolicy convert(Row source) {
        return
            ServiceInstancePolicy
                .builder()
                    .pk(source.get("pk", Long.class))
                    .id(source.get("id", String.class))
                    .gitCommit(source.get("git_commit", String.class))
                    .operation(source.get("operation", String.class))
                    .description(source.get("description", String.class))
                    .options(readOptions(source.get("options", String.class) == null ? "{}" : source.get("options", String.class)))
                    .organizationWhiteList(CsvUtil.parse(source.get("organization_whitelist", String.class)))
                    .cronExpression(source.get("cron_expression", String.class))
                    .build();
    }

    private Map<String, Object> readOptions(String value) {
        try {
            return mapper.readValue(value, new TypeReference<Map<String, Object>>() {});
        } catch (IOException ioe) {
            throw new RuntimeException("Problem reading options", ioe);
        }
    }
}



================================================
File: src/main/java/org/cftoolsuite/cfapp/domain/ServiceInstancePolicyWriteConverter.java
================================================
package org.cftoolsuite.cfapp.domain;

import java.util.stream.Collectors;

import org.apache.commons.lang3.StringUtils;
import org.springframework.core.convert.converter.Converter;
import org.springframework.data.convert.WritingConverter;
import org.springframework.data.r2dbc.mapping.OutboundRow;
import org.springframework.r2dbc.core.Parameter;
import org.springframework.stereotype.Indexed;
import org.springframework.util.CollectionUtils;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;

@Indexed
@WritingConverter
public class ServiceInstancePolicyWriteConverter implements Converter<ServiceInstancePolicy, OutboundRow> {

    private ObjectMapper mapper = new ObjectMapper();

    @Override
    public OutboundRow convert(ServiceInstancePolicy source) {
        OutboundRow row = new OutboundRow();
        row.put("id", Parameter.fromOrEmpty(source.getId(), String.class));
        row.put("git_commit", Parameter.fromOrEmpty(source.getGitCommit(), String.class));
        row.put("operation", Parameter.fromOrEmpty(source.getOperation(), String.class));
        row.put("description", Parameter.fromOrEmpty(source.getDescription(), String.class));
        row.put("options", Parameter.fromOrEmpty(CollectionUtils.isEmpty(source.getOptions()) ? null : writeOptions(source.getOptions()), String.class));
        row.put("organization_whitelist", Parameter.fromOrEmpty(source.getOrganizationWhiteList().stream().filter(StringUtils::isNotBlank).collect(Collectors.joining(",")), String.class));
        row.put("cron_expression", Parameter.fromOrEmpty(source.getCronExpression(), String.class));
        return row;
    }

    private String writeOptions(Object value) {
        try {
            return mapper.writeValueAsString(value);
        } catch (JsonProcessingException jpe) {
            throw new RuntimeException("Problem writing options", jpe);
        }
    }
}


================================================
File: src/main/java/org/cftoolsuite/cfapp/domain/SnapshotDetail.java
================================================
package org.cftoolsuite.cfapp.domain;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;

import lombok.Builder;
import lombok.Builder.Default;
import lombok.Getter;
import lombok.ToString;

@Builder
@Getter
@ToString
@JsonPropertyOrder({ "applications", "service-instances", "application-relationships", "user-accounts", "service-accounts" })
public class SnapshotDetail {

    @Default
    @JsonProperty("applications")
    private List<AppDetail> applications = new ArrayList<>();

    @Default
    @JsonProperty("service-instances")
    private List<ServiceInstanceDetail> serviceInstances = new ArrayList<>();

    @Default
    @JsonProperty("application-relationships")
    private List<AppRelationship> applicationRelationships = new ArrayList<>();

    @Default
    @JsonProperty("user-accounts")
    private Set<String> userAccounts = new HashSet<>();

    @Default
    @JsonProperty("service-accounts")
    private Set<String> serviceAccounts = new HashSet<>();

}


================================================
File: src/main/java/org/cftoolsuite/cfapp/domain/SnapshotSummary.java
================================================
package org.cftoolsuite.cfapp.domain;

import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;

import lombok.Builder;
import lombok.Getter;
import lombok.ToString;

@Builder
@Getter
@ToString
@JsonPropertyOrder({ "application-counts", "service-instance-counts", "user-counts" })
public class SnapshotSummary {

    @JsonProperty("application-counts")
    private ApplicationCounts applicationCounts;

    @JsonProperty("service-instance-counts")
    private ServiceInstanceCounts serviceInstanceCounts;

    @JsonProperty("user-counts")
    private UserCounts userCounts;

}


================================================
File: src/main/java/org/cftoolsuite/cfapp/domain/Space.java
================================================
package org.cftoolsuite.cfapp.domain;

import org.springframework.data.annotation.Id;
import org.springframework.data.annotation.PersistenceCreator;
import org.springframework.data.relational.core.mapping.Column;
import org.springframework.data.relational.core.mapping.Table;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;

import lombok.Builder;
import lombok.EqualsAndHashCode;
import lombok.Getter;
import lombok.ToString;

@Builder
@Getter
@JsonPropertyOrder({ "organization-id", "organization-name", "space-id", "space-name" })
@EqualsAndHashCode
@ToString
@Table("spaces")
public class Space {

    @Column("org_id")
    @JsonProperty("organization-id")
    private final String organizationId;

    @Column("org_name")
    @JsonProperty("organization-name")
    private final String organizationName;

    @Id
    @JsonProperty("space-id")
    private final String spaceId;

    @JsonProperty("space-name")
    private final String spaceName;


    @JsonCreator
    @PersistenceCreator
    Space(
            @JsonProperty("organization-id") String organizationId,
            @JsonProperty("organization-name") String organizationName,
            @JsonProperty("space-id") String spaceId,
            @JsonProperty("space-name") String spaceName) {
        this.organizationId = organizationId;
        this.organizationName = organizationName;
        this.spaceId = spaceId;
        this.spaceName = spaceName;
    }

}


================================================
File: src/main/java/org/cftoolsuite/cfapp/domain/SpaceUsers.java
================================================
package org.cftoolsuite.cfapp.domain;

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;

import org.springframework.data.annotation.Id;
import org.springframework.data.relational.core.mapping.Table;
import org.springframework.util.CollectionUtils;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;

import lombok.Builder;
import lombok.Builder.Default;
import lombok.EqualsAndHashCode;
import lombok.Getter;
import lombok.ToString;

@Builder
@Getter
@EqualsAndHashCode
@ToString
@JsonPropertyOrder({"organization", "space", "auditors", "developers", "managers", "users", "user-count"})
@Table("space_users")
public class SpaceUsers {

    @Id
    @JsonIgnore
    private Long pk;

    @JsonProperty("organization")
    private String organization;

    @JsonProperty("space")
    private String space;

    @Default
    @JsonProperty("auditors")
    private List<String> auditors = new ArrayList<>();

    @Default
    @JsonProperty("developers")
    private List<String> developers = new ArrayList<>();

    @Default
    @JsonProperty("managers")
    private List<String> managers = new ArrayList<>();

    @JsonCreator
    public SpaceUsers(
            Long pk,
            @JsonProperty("organization") String organization,
            @JsonProperty("space") String space,
            @JsonProperty("auditors") List<String> auditors,
            @JsonProperty("developers") List<String> developers,
            @JsonProperty("managers") List<String> managers
            ) {
        this.pk = pk;
        this.organization = organization;
        this.space = space;
        this.auditors = auditors;
        this.developers = developers;
        this.managers = managers;
    }

    // enforce consistent and distinct reporting of accounts by implementing a to lower-case policy and scrub for possible duplicates

    public List<String> getAuditors() {
        if (CollectionUtils.isEmpty(auditors)) {
            return Collections.emptyList();
        } else {
            return new ArrayList<>(auditors.stream().map(String::toLowerCase).collect(Collectors.toSet()));
        }
    }

    public List<String> getDevelopers() {
        if (CollectionUtils.isEmpty(developers)) {
            return Collections.emptyList();
        } else {
            return new ArrayList<>(developers.stream().map(String::toLowerCase).collect(Collectors.toSet()));
        }
    }

    public List<String> getManagers() {
        if (CollectionUtils.isEmpty(managers)) {
            return Collections.emptyList();
        } else {
            return new ArrayList<>(managers.stream().map(String::toLowerCase).collect(Collectors.toSet()));
        }
    }

    @JsonProperty("user-count")
    public Integer getUserCount() {
        return getUsers().size();
    }

    @JsonProperty("users")
    public Set<String> getUsers() {
        Set<String> users = new HashSet<>();
        users.addAll(getAuditors());
        users.addAll(getDevelopers());
        users.addAll(getManagers());
        return users;
    }

}


================================================
File: src/main/java/org/cftoolsuite/cfapp/domain/SpaceUsersReadConverter.java
================================================
package org.cftoolsuite.cfapp.domain;

import org.springframework.core.convert.converter.Converter;
import org.springframework.data.convert.ReadingConverter;
import org.springframework.stereotype.Indexed;

import io.r2dbc.spi.Row;

@Indexed
@ReadingConverter
public class SpaceUsersReadConverter implements Converter<Row, SpaceUsers> {

    @Override
    public SpaceUsers convert(Row source) {
        return
                SpaceUsers
                .builder()
                .pk(source.get("pk", Long.class))
                .organization(Defaults.getColumnValue(source, "organization", String.class))
                .space(Defaults.getColumnValue(source, "space", String.class))
                .auditors(Defaults.getColumnListOfStringValue(source, "auditors"))
                .developers(Defaults.getColumnListOfStringValue(source, "developers"))
                .managers(Defaults.getColumnListOfStringValue(source, "managers"))
                .build();
    }

}


================================================
File: src/main/java/org/cftoolsuite/cfapp/domain/SpaceUsersWriteConverter.java
================================================
package org.cftoolsuite.cfapp.domain;

import java.util.stream.Collectors;

import org.apache.commons.lang3.StringUtils;
import org.springframework.core.convert.converter.Converter;
import org.springframework.data.convert.WritingConverter;
import org.springframework.data.r2dbc.mapping.OutboundRow;
import org.springframework.r2dbc.core.Parameter;
import org.springframework.stereotype.Indexed;

@Indexed
@WritingConverter
public class SpaceUsersWriteConverter implements Converter<SpaceUsers, OutboundRow> {

    @Override
    public OutboundRow convert(SpaceUsers source) {
        OutboundRow row = new OutboundRow();
        row.put("organization", Parameter.fromOrEmpty(source.getOrganization(), String.class));
        row.put("space", Parameter.fromOrEmpty(source.getSpace(), String.class));
        row.put("auditors", Parameter.fromOrEmpty(source.getAuditors().stream().filter(StringUtils::isNotBlank).collect(Collectors.joining(",")), String.class));
        row.put("developers", Parameter.fromOrEmpty(source.getDevelopers().stream().filter(StringUtils::isNotBlank).collect(Collectors.joining(",")), String.class));
        row.put("managers", Parameter.fromOrEmpty(source.getManagers().stream().filter(StringUtils::isNotBlank).collect(Collectors.joining(",")), String.class));
        return row;
    }

}


================================================
File: src/main/java/org/cftoolsuite/cfapp/domain/Stack.java
================================================
package org.cftoolsuite.cfapp.domain;

import lombok.Builder;
import lombok.Getter;
import lombok.ToString;

@Builder
@Getter
@ToString
public class Stack {

    private final String id;
    private final String name;
    private final String description;
}


================================================
File: src/main/java/org/cftoolsuite/cfapp/domain/TimeKeeper.java
================================================
package org.cftoolsuite.cfapp.domain;

import java.time.LocalDateTime;

import org.springframework.data.annotation.Id;
import org.springframework.data.annotation.PersistenceCreator;
import org.springframework.data.relational.core.mapping.Table;

import lombok.Getter;

@Getter
@Table("time_keeper")
public class TimeKeeper {

    @Id
    private LocalDateTime collectionTime;

    @PersistenceCreator
    public TimeKeeper(LocalDateTime collectionTime) {
        this.collectionTime = collectionTime;
    }
}


================================================
File: src/main/java/org/cftoolsuite/cfapp/domain/UserAccounts.java
================================================
package org.cftoolsuite.cfapp.domain;

import java.util.Collections;
import java.util.HashSet;
import java.util.Set;

import org.apache.commons.lang3.StringUtils;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;

import lombok.Builder;
import lombok.Builder.Default;
import lombok.EqualsAndHashCode;
import lombok.Getter;
import lombok.ToString;

@Builder
@Getter
@EqualsAndHashCode
@ToString
@JsonPropertyOrder({"organization", "space", "accounts"})
public class UserAccounts {

    public static String headers() {
        return String.join(",", "organization", "space", "user accounts");
    }

    private static String wrap(String value) {
        return value != null ? StringUtils.wrap(value, '"') : StringUtils.wrap("", '"');
    }

    @JsonProperty("organization")
    private String organization;

    @JsonProperty("space")
    private String space;

    @Default
    @JsonProperty("accounts")
    private Set<String> accounts = new HashSet<>();

    @JsonCreator
    public UserAccounts(
            @JsonProperty("organization") String organization,
            @JsonProperty("space") String space,
            @JsonProperty("accounts") Set<String> accounts
            ) {
        this.organization = organization;
        this.space = space;
        this.accounts = accounts;
    }

    public String toCsv() {
        return String.join(",", wrap(getOrganization()), wrap(getSpace()), wrap(String.join(",", getAccounts() != null ? getAccounts(): Collections.emptyList())));
    }
}


================================================
File: src/main/java/org/cftoolsuite/cfapp/domain/UserCounts.java
================================================
package org.cftoolsuite.cfapp.domain;

import java.util.HashMap;
import java.util.Map;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;

import lombok.Builder;
import lombok.Builder.Default;
import lombok.Getter;
import lombok.ToString;

@Builder
@Getter
@ToString
@JsonPropertyOrder({ "by-organization", "total-user-accounts", "total-service-accounts"})
public class UserCounts {

    @Default
    @JsonProperty("by-organization")
    private Map<String, Integer> byOrganization = new HashMap<>();

    @Default
    @JsonProperty("total-user-accounts")
    private Long totalUserAccounts = 0L;

    @Default
    @JsonProperty("total-service-accounts")
    private Long totalServiceAccounts = 0L;

    @JsonCreator
    public UserCounts(
            @JsonProperty("by-organization") Map<String, Integer> byOrganization,
            @JsonProperty("total-user-accounts") Long totalUserAccounts,
            @JsonProperty("total-service-accounts") Long totalServiceAccounts
            ) {
        this.byOrganization = byOrganization;
        this.totalUserAccounts = totalUserAccounts;
        this.totalServiceAccounts = totalServiceAccounts;
    }
}


================================================
File: src/main/java/org/cftoolsuite/cfapp/domain/UserSpaces.java
================================================
package org.cftoolsuite.cfapp.domain;

import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;

import lombok.Builder;
import lombok.Builder.Default;
import lombok.Getter;

@Builder
@Getter
@JsonPropertyOrder({ "account-name", "spaces" })
public class UserSpaces {

    @JsonProperty("account-name")
    private String accountName;

    @Default
    @JsonProperty("spaces")
    private List<Space> spaces = new ArrayList<>();


    @JsonCreator
    public UserSpaces(
            @JsonProperty("account-name") String accountName,
            @JsonProperty("spaces") List<Space> spaces)
    {
        this.accountName = accountName;
        this.spaces = spaces;
    }

    @Override
    public String toString() {
        return String.format(
                "User: %s, Spaces: [%s]",
                getAccountName(),
                String.join(",", getSpaces()
                        .stream()
                        .map(s ->
                        String.join("/", s.getOrganizationName(), s.getSpaceName())
                                )
                        .collect(Collectors.toList())));
    }
}


================================================
File: src/main/java/org/cftoolsuite/cfapp/domain/Workloads.java
================================================
package org.cftoolsuite.cfapp.domain;

import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;

import lombok.Builder;
import lombok.Builder.Default;
import lombok.EqualsAndHashCode;
import lombok.Getter;


@Builder
@Getter
@EqualsAndHashCode
@JsonPropertyOrder({ "applications", "service-instances", "application-relationships" })
public class Workloads {

    @Default
    @JsonProperty("applications")
    private List<AppDetail> applications = new ArrayList<>();

    @Default
    @JsonProperty("service-instances")
    private List<ServiceInstanceDetail> serviceInstances = new ArrayList<>();

    @Default
    @JsonProperty("application-relationships")
    private List<AppRelationship> appRelationships = new ArrayList<>();

    @JsonCreator
    public Workloads(
            @JsonProperty("applications") List<AppDetail> applications,
            @JsonProperty("service-instances") List<ServiceInstanceDetail> serviceInstances,
            @JsonProperty("application-relationships") List<AppRelationship> appRelationships
            ) {
        this.applications = applications;
        this.serviceInstances = serviceInstances;
        this.appRelationships = appRelationships;
    }

    public Workloads matchBySpace(List<Space> spaces) {
        List<AppDetail> matchingApps = new ArrayList<>();
        List<ServiceInstanceDetail> matchingServiceInstances = new ArrayList<>();
        List<AppRelationship> matchingAppRelationships = new ArrayList<>();
        for (Space s: spaces) {
            matchingApps.addAll(applications
                    .stream()
                    .filter(application ->
                    application.getOrganization().equalsIgnoreCase(s.getOrganizationName())
                    && application.getSpace().equalsIgnoreCase(s.getSpaceName()))
                    .collect(Collectors.toList()));
            matchingServiceInstances.addAll(serviceInstances
                    .stream()
                    .filter(serviceInstance ->
                    serviceInstance.getOrganization().equalsIgnoreCase(s.getOrganizationName())
                    && serviceInstance.getSpace().equalsIgnoreCase(s.getSpaceName()))
                    .collect(Collectors.toList()));
            matchingAppRelationships.addAll(appRelationships
                    .stream()
                    .filter(appRelationship ->
                    appRelationship.getOrganization().equalsIgnoreCase(s.getOrganizationName())
                    && appRelationship.getSpace().equalsIgnoreCase(s.getSpaceName()))
                    .collect(Collectors.toList()));
        }
        return Workloads.builder().applications(matchingApps).serviceInstances(matchingServiceInstances).appRelationships(matchingAppRelationships).build();
    }

    @Override
    public String toString() {
        return String
                .format(
                        "Workloads comprised of... \n\tApplications: [%s],\n\tService Instances [%s],\n\tApplication Relationships [%s]",
                        String.join(",", getApplications().stream().map(AppDetail::getAppName).collect(Collectors.toList())),
                        String.join(",", getServiceInstances().stream().map(ServiceInstanceDetail::getName).collect(Collectors.toList())),
                        String.join(",", getAppRelationships().stream().map(AppRelationship::getAppName).collect(Collectors.toList()))
                        );
    }
}


================================================
File: src/main/java/org/cftoolsuite/cfapp/domain/WorkloadsFilter.java
================================================
package org.cftoolsuite.cfapp.domain;

import java.util.Set;

import lombok.Builder;
import lombok.Getter;

@Builder
@Getter
public class WorkloadsFilter {

    private Set<String> stacks;
    private Set<String> serviceOfferings;

}


================================================
File: src/main/java/org/cftoolsuite/cfapp/domain/accounting/application/AppUsageMonthly.java
================================================
package org.cftoolsuite.cfapp.domain.accounting.application;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;

import lombok.Builder;
import lombok.Builder.Default;
import lombok.Getter;

@Builder
@Getter
@JsonPropertyOrder({"month", "year", "average_app_instances","maximum_app_instances", "app_instance_hours"})
public class AppUsageMonthly {

    @JsonProperty("month")
    private Integer month;

    @JsonProperty("year")
    private Integer year;

    @Default
    @JsonProperty("average_app_instances")
    private Double averageAppInstances = 0.0;

    @Default
    @JsonProperty("maximum_app_instances")
    private Integer maximumAppInstances = 0;

    @Default
    @JsonProperty("app_instance_hours")
    private Double appInstanceHours = 0.0;

    @JsonCreator
    public AppUsageMonthly(
            @JsonProperty("month") Integer month,
            @JsonProperty("year") Integer year,
            @JsonProperty("average_app_instances") Double averageAppInstances,
            @JsonProperty("maximum_app_instances") Integer maximumAppInstances,
            @JsonProperty("app_instance_hours") Double appInstanceHours) {
        this.month = month;
        this.year = year;
        this.averageAppInstances = averageAppInstances;
        this.maximumAppInstances = maximumAppInstances;
        this.appInstanceHours = appInstanceHours;
    }

}


================================================
File: src/main/java/org/cftoolsuite/cfapp/domain/accounting/application/AppUsageReport.java
================================================
package org.cftoolsuite.cfapp.domain.accounting.application;

import java.util.ArrayList;
import java.util.List;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;

import lombok.Builder;
import lombok.Builder.Default;
import lombok.Getter;

@Builder
@Getter
@JsonPropertyOrder({"report_time", "monthly_reports", "yearly_reports"})
public class AppUsageReport {

    @JsonProperty("report_time")
    private String reportTime;

    @Default
    @JsonProperty("monthly_reports")
    private List<AppUsageMonthly> monthlyReports = new ArrayList<>();

    @Default
    @JsonProperty("yearly_reports")
    private List<AppUsageYearly> yearlyReports = new ArrayList<>();

    @JsonCreator
    public AppUsageReport(
            @JsonProperty("report_time") String reportTime,
            @JsonProperty("monthly_reports") List<AppUsageMonthly> monthlyReports,
            @JsonProperty("yearly_reports") List<AppUsageYearly> yearlyReports) {
        this.reportTime = reportTime;
        this.monthlyReports = monthlyReports;
        this.yearlyReports = yearlyReports;
    }

}


================================================
File: src/main/java/org/cftoolsuite/cfapp/domain/accounting/application/AppUsageYearly.java
================================================
package org.cftoolsuite.cfapp.domain.accounting.application;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;

import lombok.Builder;
import lombok.Builder.Default;
import lombok.Getter;

@Builder
@Getter
@JsonPropertyOrder({"year", "average_app_instances", "maximum_app_instances", "app_instance_hours"})
public class AppUsageYearly {

    @JsonProperty("year")
    private Integer year;

    @Default
    @JsonProperty("average_app_instances")
    private Double averageAppInstances = 0.0;

    @Default
    @JsonProperty("maximum_app_instances")
    private Integer maximumAppInstances = 0;

    @Default
    @JsonProperty("app_instance_hours")
    private Double appInstanceHours = 0.0;

    @JsonCreator
    public AppUsageYearly(
            @JsonProperty("year") Integer year,
            @JsonProperty("average_app_instances") Double averageAppInstances,
            @JsonProperty("maximum_app_instances") Integer maximumAppInstances,
            @JsonProperty("app_instance_hours") Double appInstanceHours) {
        this.year = year;
        this.averageAppInstances = averageAppInstances;
        this.maximumAppInstances = maximumAppInstances;
        this.appInstanceHours = appInstanceHours;
    }

}


================================================
File: src/main/java/org/cftoolsuite/cfapp/domain/accounting/service/NormalizedServiceMonthlyUsage.java
================================================
package org.cftoolsuite.cfapp.domain.accounting.service;

import java.util.ArrayList;
import java.util.Comparator;
import java.util.List;

import lombok.Builder;
import lombok.Getter;

@Builder
@Getter
public class NormalizedServiceMonthlyUsage {

    public static List<NormalizedServiceMonthlyUsage> listOf(ServiceUsageReport report) {
        List<NormalizedServiceMonthlyUsage> result = new ArrayList<>();
        List<ServiceUsageMonthlyAggregate> monthlyAggregates = report.getMonthlyServiceReports();
        for (ServiceUsageMonthlyAggregate suma: monthlyAggregates) {
            String serviceName = suma.getServiceName();
            String serviceGuid = suma.getServiceGuid();
            List<ServiceUsageMonthly> monthlyServiceUsageMetrics = suma.getUsages();
            for (ServiceUsageMonthly metrics: monthlyServiceUsageMetrics) {
                result.add(
                        NormalizedServiceMonthlyUsage.builder()
                        .year(metrics.getYear())
                        .month(metrics.getMonth())
                        .serviceGuid(serviceGuid)
                        .serviceName(serviceName)
                        .averageInstances(metrics.getAverageInstances())
                        .maximumInstances(metrics.getMaximumInstances())
                        .durationInHours(metrics.getDurationInHours())
                        .build()
                        );
            }
        }
        result.sort(Comparator.comparing(NormalizedServiceMonthlyUsage::getKey));
        return result;
    }
    private Integer year;
    private Integer month;
    private String serviceName;
    private String serviceGuid;
    private Double durationInHours;
    private Double averageInstances;

    private Integer maximumInstances;

    public String getKey() {
        return String.join("-", serviceName, String.valueOf(year), String.format("%02d", month));
    }
}


================================================
File: src/main/java/org/cftoolsuite/cfapp/domain/accounting/service/NormalizedServicePlanMonthlyUsage.java
================================================
package org.cftoolsuite.cfapp.domain.accounting.service;

import java.util.ArrayList;
import java.util.Comparator;
import java.util.List;

import lombok.Builder;
import lombok.Getter;

@Builder
@Getter
public class NormalizedServicePlanMonthlyUsage {

    public static List<NormalizedServicePlanMonthlyUsage> listOf(ServiceUsageReport report) {
        List<NormalizedServicePlanMonthlyUsage> result = new ArrayList<>();
        List<ServiceUsageMonthlyAggregate> monthlyAggregates = report.getMonthlyServiceReports();
        for (ServiceUsageMonthlyAggregate suma: monthlyAggregates) {
            String serviceName = suma.getServiceName();
            String serviceGuid = suma.getServiceGuid();
            List<ServicePlanUsageMonthly> monthlyServicePlanUsages = suma.getPlans();
            for (ServicePlanUsageMonthly spum: monthlyServicePlanUsages) {
                String servicePlanName = spum.getServicePlanName();
                String servicePlanGuid = spum.getServicePlanGuid();
                List<ServiceUsageMonthly> monthlyServicePlanUsageMetrics = spum.getUsages();
                for (ServiceUsageMonthly metrics: monthlyServicePlanUsageMetrics) {
                    result.add(
                            NormalizedServicePlanMonthlyUsage.builder()
                            .year(metrics.getYear())
                            .month(metrics.getMonth())
                            .serviceGuid(serviceGuid)
                            .serviceName(serviceName)
                            .servicePlanGuid(servicePlanGuid)
                            .servicePlanName(servicePlanName)
                            .averageInstances(metrics.getAverageInstances())
                            .maximumInstances(metrics.getMaximumInstances())
                            .durationInHours(metrics.getDurationInHours())
                            .build()
                            );
                }
            }
        }
        result.sort(Comparator.comparing(NormalizedServicePlanMonthlyUsage::getKey));
        return result;
    }
    private Integer year;
    private Integer month;
    private String serviceName;
    private String serviceGuid;
    private String servicePlanName;
    private String servicePlanGuid;
    private Double durationInHours;
    private Double averageInstances;

    private Integer maximumInstances;

    public String getKey() {
        return String.join("-", serviceName, servicePlanName, String.valueOf(year), String.format("%02d", month));
    }

}


================================================
File: src/main/java/org/cftoolsuite/cfapp/domain/accounting/service/ServicePlanUsageMonthly.java
================================================
package org.cftoolsuite.cfapp.domain.accounting.service;

import java.util.ArrayList;
import java.util.List;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;

import lombok.Builder;
import lombok.Builder.Default;
import lombok.Getter;

@Builder
@Getter
@JsonPropertyOrder({ "usages", "service_plan_name", "service_plan_guid"})
public class ServicePlanUsageMonthly {

    @Default
    @JsonProperty("usages")
    public List<ServiceUsageMonthly> usages = new ArrayList<>();

    @JsonProperty("service_plan_name")
    public String servicePlanName;

    @JsonProperty("service_plan_guid")
    public String servicePlanGuid;

    @JsonCreator
    public ServicePlanUsageMonthly(
            @JsonProperty("usages") List<ServiceUsageMonthly> usages,
            @JsonProperty("service_plan_name") String servicePlanName,
            @JsonProperty("service_plan_guid") String servicePlanGuid) {
        this.usages = usages;
        this.servicePlanName = servicePlanName;
        this.servicePlanGuid = servicePlanGuid;
    }

}


================================================
File: src/main/java/org/cftoolsuite/cfapp/domain/accounting/service/ServicePlanUsageYearly.java
================================================
package org.cftoolsuite.cfapp.domain.accounting.service;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;

import lombok.Builder;
import lombok.Builder.Default;
import lombok.Getter;

@Builder
@Getter
@JsonPropertyOrder({ "service_plan_name", "service_plan_guid", "year", "duration_in_hours", "maximum_instances", "average_instances"})
public class ServicePlanUsageYearly {

    @JsonProperty("service_plan_name")
    public String servicePlanName;

    @JsonProperty("service_plan_guid")
    public String servicePlanGuid;

    @JsonProperty("year")
    public Integer year;

    @Default
    @JsonProperty("duration_in_hours")
    public Double durationInHours = 0.0;

    @Default
    @JsonProperty("maximum_instances")
    public Integer maximumInstances = 0;

    @Default
    @JsonProperty("average_instances")
    public Double averageInstances = 0.0;

    @JsonCreator
    public ServicePlanUsageYearly(
            @JsonProperty("service_plan_name") String servicePlanName,
            @JsonProperty("service_plan_guid") String servicePlanGuid,
            @JsonProperty("year") Integer year,
            @JsonProperty("duration_in_hours") Double durationInHours,
            @JsonProperty("maximum_instances") Integer maximumInstances,
            @JsonProperty("average_instances") Double averageInstances) {
        this.servicePlanName = servicePlanName;
        this.servicePlanGuid = servicePlanGuid;
        this.year = year;
        this.durationInHours = durationInHours;
        this.maximumInstances = maximumInstances;
        this.averageInstances = averageInstances;
    }


}


================================================
File: src/main/java/org/cftoolsuite/cfapp/domain/accounting/service/ServiceUsageMonthly.java
================================================
package org.cftoolsuite.cfapp.domain.accounting.service;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;

import lombok.Builder;
import lombok.Builder.Default;
import lombok.Getter;

@Builder
@Getter
@JsonPropertyOrder({"month", "year", "duration_in_hours", "average_instances", "maximum_instances"})
public class ServiceUsageMonthly {

    @JsonProperty("month")
    public Integer month;

    @JsonProperty("year")
    public Integer year;

    @Default
    @JsonProperty("duration_in_hours")
    public Double durationInHours = 0.0;

    @Default
    @JsonProperty("average_instances")
    public Double averageInstances = 0.0;

    @Default
    @JsonProperty("maximum_instances")
    public Integer maximumInstances = 0;

    @JsonCreator
    public ServiceUsageMonthly(
            @JsonProperty("month") Integer month,
            @JsonProperty("year") Integer year,
            @JsonProperty("duration_in_hours") Double durationInHours,
            @JsonProperty("average_instances") Double averageInstances,
            @JsonProperty("maximum_instances") Integer maximumInstances) {
        this.month = month;
        this.year = year;
        this.durationInHours = durationInHours;
        this.averageInstances = averageInstances;
        this.maximumInstances = maximumInstances;
    }

}


================================================
File: src/main/java/org/cftoolsuite/cfapp/domain/accounting/service/ServiceUsageMonthlyAggregate.java
================================================

package org.cftoolsuite.cfapp.domain.accounting.service;

import java.util.ArrayList;
import java.util.List;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;

import lombok.Builder;
import lombok.Builder.Default;
import lombok.Getter;

@Builder
@Getter
@JsonPropertyOrder({"service_name", "service_guid", "usages", "plans"})
public class ServiceUsageMonthlyAggregate {

    @JsonProperty("service_name")
    public String serviceName;

    @JsonProperty("service_guid")
    public String serviceGuid;

    @Default
    @JsonProperty("usages")
    public List<ServiceUsageMonthly> usages = new ArrayList<>();

    @Default
    @JsonProperty("plans")
    public List<ServicePlanUsageMonthly> plans = new ArrayList<>();

    @JsonCreator
    public ServiceUsageMonthlyAggregate(
            @JsonProperty("service_name") String serviceName,
            @JsonProperty("service_guid") String serviceGuid,
            @JsonProperty("usages") List<ServiceUsageMonthly> usages,
            @JsonProperty("plans") List<ServicePlanUsageMonthly> plans) {
        this.serviceName = serviceName;
        this.serviceGuid = serviceGuid;
        this.usages = usages;
        this.plans = plans;
    }

}


================================================
File: src/main/java/org/cftoolsuite/cfapp/domain/accounting/service/ServiceUsageReport.java
================================================
package org.cftoolsuite.cfapp.domain.accounting.service;

import java.util.ArrayList;
import java.util.List;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;

import lombok.Builder;
import lombok.Builder.Default;
import lombok.Getter;

@Builder
@Getter
@JsonPropertyOrder({"report_time", "monthly_service_reports", "yearly_service_report"})
public class ServiceUsageReport {

    @JsonProperty("report_time")
    public String reportTime;

    @Default
    @JsonProperty("monthly_service_reports")
    public List<ServiceUsageMonthlyAggregate> monthlyServiceReports = new ArrayList<>();

    @Default
    @JsonProperty("yearly_service_report")
    public List<ServiceUsageYearlyAggregate> yearlyServiceReport = new ArrayList<>();

    @JsonCreator
    public ServiceUsageReport(
            @JsonProperty("report_time") String reportTime,
            @JsonProperty("monthly_service_reports") List<ServiceUsageMonthlyAggregate> monthlyServiceReports,
            @JsonProperty("yearly_service_report") List<ServiceUsageYearlyAggregate> yearlyServiceReport) {
        this.reportTime = reportTime;
        this.monthlyServiceReports = monthlyServiceReports;
        this.yearlyServiceReport = yearlyServiceReport;
    }

}


================================================
File: src/main/java/org/cftoolsuite/cfapp/domain/accounting/service/ServiceUsageYearlyAggregate.java
================================================
package org.cftoolsuite.cfapp.domain.accounting.service;

import java.util.ArrayList;
import java.util.List;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;

import lombok.Builder;
import lombok.Builder.Default;
import lombok.Getter;

@Builder
@Getter
@JsonPropertyOrder({"service_name", "service_guid", "year", "duration_in_hours", "maximum_instances", "average_instances", "plans"})
public class ServiceUsageYearlyAggregate {

    @JsonProperty("service_name")
    public String serviceName;

    @JsonProperty("service_guid")
    public String serviceGuid;

    @JsonProperty("year")
    public Integer year;

    @Default
    @JsonProperty("duration_in_hours")
    public Double durationInHours = 0.0;

    @Default
    @JsonProperty("maximum_instances")
    public Integer maximumInstances = 0;

    @Default
    @JsonProperty("average_instances")
    public Double averageInstances = 0.0;

    @Default
    @JsonProperty("plans")
    public List<ServicePlanUsageYearly> plans = new ArrayList<>();

    @JsonCreator
    public ServiceUsageYearlyAggregate(
            @JsonProperty("service_name") String serviceName,
            @JsonProperty("service_guid") String serviceGuid,
            @JsonProperty("year") Integer year,
            @JsonProperty("duration_in_hours") Double durationInHours,
            @JsonProperty("maximum_instances") Integer maximumInstances,
            @JsonProperty("average_instances") Double averageInstances,
            @JsonProperty("plans") List<ServicePlanUsageYearly> plans) {
        this.serviceName = serviceName;
        this.serviceGuid = serviceGuid;
        this.year = year;
        this.durationInHours = durationInHours;
        this.maximumInstances = maximumInstances;
        this.averageInstances = averageInstances;
        this.plans = plans;
    }


}


================================================
File: src/main/java/org/cftoolsuite/cfapp/domain/accounting/task/TaskUsageMonthly.java
================================================
package org.cftoolsuite.cfapp.domain.accounting.task;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;

import lombok.Builder;
import lombok.Builder.Default;
import lombok.Getter;

@Builder
@Getter
@JsonPropertyOrder({"month", "year", "total_task_runs", "maximum_concurrent_tasks", "task_hours"})
public class TaskUsageMonthly {

    @JsonProperty("month")
    private Integer month;

    @JsonProperty("year")
    private Integer year;

    @Default
    @JsonProperty("total_task_runs")
    private Integer totalTaskRuns = 0;

    @Default
    @JsonProperty("maximum_concurrent_tasks")
    private Integer maximumConcurrentTasks = 0;

    @Default
    @JsonProperty("task_hours")
    private Double taskHours = 0.0;

    @JsonCreator
    public TaskUsageMonthly(
            @JsonProperty("month") Integer month,
            @JsonProperty("year") Integer year,
            @JsonProperty("total_task_runs") Integer totalTaskRuns,
            @JsonProperty("maximum_concurrent_tasks") Integer maximumConcurrentTasks,
            @JsonProperty("task_hours") Double taskHours) {
        this.month = month;
        this.year = year;
        this.totalTaskRuns = totalTaskRuns;
        this.maximumConcurrentTasks = maximumConcurrentTasks;
        this.taskHours = taskHours;
    }

}


================================================
File: src/main/java/org/cftoolsuite/cfapp/domain/accounting/task/TaskUsageReport.java
================================================
package org.cftoolsuite.cfapp.domain.accounting.task;

import java.util.ArrayList;
import java.util.List;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;

import lombok.Builder;
import lombok.Builder.Default;
import lombok.Getter;

@Builder
@Getter
@JsonPropertyOrder({"report_time", "monthly_reports", "yearly_reports"})
public class TaskUsageReport {

    @JsonProperty("report_time")
    private String reportTime;

    @Default
    @JsonProperty("monthly_reports")
    private List<TaskUsageMonthly> monthlyReports = new ArrayList<>();

    @Default
    @JsonProperty("yearly_reports")
    private List<TaskUsageYearly> yearlyReports = new ArrayList<>();

    @JsonCreator
    public TaskUsageReport(
            @JsonProperty("report_time") String reportTime,
            @JsonProperty("monthly_reports") List<TaskUsageMonthly> monthlyReports,
            @JsonProperty("yearly_reports") List<TaskUsageYearly> yearlyReports) {
        this.reportTime = reportTime;
        this.monthlyReports = monthlyReports;
        this.yearlyReports = yearlyReports;
    }

}



================================================
File: src/main/java/org/cftoolsuite/cfapp/domain/accounting/task/TaskUsageYearly.java
================================================
package org.cftoolsuite.cfapp.domain.accounting.task;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;

import lombok.Builder;
import lombok.Builder.Default;
import lombok.Getter;

@Builder
@Getter
@JsonPropertyOrder({"year", "total_task_runs", "maximum_concurrent_tasks", "task_hours"})
public class TaskUsageYearly {

    @JsonProperty("year")
    private Integer year;

    @Default
    @JsonProperty("total_task_runs")
    private Integer totalTaskRuns = 0;

    @Default
    @JsonProperty("maximum_concurrent_tasks")
    private Integer maximumConcurrentTasks = 0;

    @Default
    @JsonProperty("task_hours")
    private Double taskHours = 0.0;

    @JsonCreator
    public TaskUsageYearly(
            @JsonProperty("year") Integer year,
            @JsonProperty("total_task_runs") Integer totalTaskRuns,
            @JsonProperty("maximum_concurrent_tasks") Integer maximumConcurrentTasks,
            @JsonProperty("task_hours") Double taskHours) {
        this.year = year;
        this.totalTaskRuns = totalTaskRuns;
        this.maximumConcurrentTasks = maximumConcurrentTasks;
        this.taskHours = taskHours;
    }

}


================================================
File: src/main/java/org/cftoolsuite/cfapp/domain/event/Entity.java
================================================
package org.cftoolsuite.cfapp.domain.event;

import java.time.Instant;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;

import lombok.Builder;
import lombok.Getter;

@Builder
@Getter
@JsonInclude(JsonInclude.Include.NON_NULL)
@JsonPropertyOrder({
    "actee",
    "actee_name",
    "actee_type",
    "actor",
    "actor_name",
    "actor_type",
    "actor_username",
    "metadata",
    "organization_guid",
    "space_guid",
    "timestamp",
    "type"
})
public class Entity {

    @JsonProperty("actee")
    private String actee;

    @JsonProperty("actee_name")
    private String acteeName;

    @JsonProperty("actee_type")
    private String acteeType;

    @JsonProperty("actor")
    private String actor;

    @JsonProperty("actor_name")
    private String actorName;

    @JsonProperty("actor_type")
    private String actorType;

    @JsonProperty("actor_username")
    private String actorUsername;

    @JsonProperty("metadata")
    private EntityMetadata metadata;

    @JsonProperty("organization_guid")
    private String organizationGuid;

    @JsonProperty("space_guid")
    private String spaceGuid;

    @JsonProperty("timestamp")
    private Instant timestamp;

    @JsonProperty("type")
    private String type;

    @JsonCreator
    public Entity(
            @JsonProperty("actee") String actee,
            @JsonProperty("actee_name") String acteeName,
            @JsonProperty("actee_type") String acteeType,
            @JsonProperty("actor") String actor,
            @JsonProperty("actor_name") String actorName,
            @JsonProperty("actor_type") String actorType,
            @JsonProperty("actor_username") String actorUsername,
            @JsonProperty("metadata") EntityMetadata metadata,
            @JsonProperty("organization_guid") String organizationGuid,
            @JsonProperty("space_guid") String spaceGuid,
            @JsonProperty("timestamp") Instant timestamp,
            @JsonProperty("type") String type
            ) {
        this.actee = actee;
        this.acteeName = acteeName;
        this.acteeType = acteeType;
        this.actor = actor;
        this.actorType = actorType;
        this.actorUsername = actorUsername;
        this.metadata = metadata;
        this.organizationGuid = organizationGuid;
        this.spaceGuid = spaceGuid;
        this.timestamp = timestamp;
        this.type = type;
    }
}


================================================
File: src/main/java/org/cftoolsuite/cfapp/domain/event/EntityMetadata.java
================================================
package org.cftoolsuite.cfapp.domain.event;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;

@JsonInclude(JsonInclude.Include.NON_NULL)
@JsonPropertyOrder({
    "request",
    "droplet_guid",
    "package_guid",
    "build_guid",
    "app_port",
    "process_type",
    "route_guid",
    "route_mapping_guid"
})
public class EntityMetadata {

    @JsonProperty("request")
    private Request request;

    @JsonProperty("droplet_guid")
    private String dropletGuid;

    @JsonProperty("package_guid")
    private String packageGuid;

    @JsonProperty("build_guid")
    private String buildGuid;

    @JsonProperty("app_port")
    private Integer appPort;

    @JsonProperty("process_type")
    private String processType;

    @JsonProperty("route_guid")
    private String routeGuid;

    @JsonProperty("route_mapping_guid")
    private String routeMappingGuid;

    @JsonCreator
    public EntityMetadata(
            @JsonProperty("request") Request request,
            @JsonProperty("droplet_guid") String dropletGuid,
            @JsonProperty("package_guid") String packageGuid,
            @JsonProperty("build_guid") String buildGuid,
            @JsonProperty("app_port") Integer appPort,
            @JsonProperty("process_type") String processType,
            @JsonProperty("route_guid") String routeGuid,
            @JsonProperty("route_mapping_guid") String routeMappingGuid) {
        this.request = request;
        this.dropletGuid = dropletGuid;
        this.packageGuid = packageGuid;
        this.buildGuid = buildGuid;
        this.appPort = appPort;
        this.processType = processType;
        this.routeGuid = routeGuid;
        this.routeMappingGuid = routeMappingGuid;
    }

}


================================================
File: src/main/java/org/cftoolsuite/cfapp/domain/event/EventType.java
================================================
package org.cftoolsuite.cfapp.domain.event;

import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;

import org.springframework.util.Assert;

public enum EventType {
    APP_CRASH("app.crash"),
    AUDIT_APP_COPY_BITS("audit.app.copy-bits"),
    AUDIT_APP_CREATE("audit.app.create"),
    AUDIT_APP_DELETE_REQUEST("audit.app.delete-request"),
    AUDIT_APP_DROPLET_MAPPED("audit.app.droplet.mapped"),
    AUDIT_APP_MAP_ROUTE("audit.app.map-route"),
    AUDIT_APP_PACKAGE_CREATE("audit.app.package.create"),
    AUDIT_APP_PACKAGE_DELETE("audit.app.package.delete"),
    AUDIT_APP_PACKAGE_DOWNLOAD("audit.app.package.download"),
    AUDIT_APP_PACKAGE_UPLOAD("audit.app.package.upload"),
    AUDIT_APP_RESTAGE("audit.app.restage"),
    AUDIT_APP_SSH_AUTHORIZED("audit.app.ssh-authorized"),
    AUDIT_APP_SSH_UNAUTHORIZED("audit.app.ssh-unauthorized"),
    AUDIT_APP_START("audit.app.start"),
    AUDIT_APP_STOP("audit.app.stop"),
    AUDIT_APP_UNMAP_ROUTE("audit.app.unmap-route"),
    AUDIT_APP_UPDATE("audit.app.update"),
    AUDIT_APP_UPLOAD_BITS("audit.app.upload-bits"),
    AUDIT_ORGANIZATION_CREATE("audit.organization.create"),
    AUDIT_ORGANIZATION_DELETE_REQUEST("audit.organization.delete-request"),
    AUDIT_ORGANIZATION_UPDATE("audit.organization.update"),
    AUDIT_ROUTE_CREATE("audit.route.create"),
    AUDIT_ROUTE_DELETE_REQUEST("audit.route.delete-request"),
    AUDIT_ROUTE_UPDATE("audit.route.update"),
    AUDIT_SERVICE_CREATE("audit.service.create"),
    AUDIT_SERVICE_DELETE("audit.service.delete"),
    AUDIT_SERVICE_UPDATE("audit.service.update"),
    AUDIT_SERVICE_BINDING_CREATE("audit.service_binding.create"),
    AUDIT_SERVICE_BINDING_DELETE("audit.service_binding.delete"),
    AUDIT_SERVICE_BROKER_CREATE("audit.service_broker.create"),
    AUDIT_SERVICE_BROKER_DELETE("audit.service_broker.delete"),
    AUDIT_SERVICE_BROKER_UPDATE("audit.service_broker.update"),
    AUDIT_SERVICE_DASHBOARD_CLIENT_CREATE("audit.service_dashboard_client.create"),
    AUDIT_SERVICE_DASHBOARD_CLIENT_DELETE("audit.service_dashboard_client.delete"),
    AUDIT_SERVICE_INSTANCE_BIND_ROUTE("audit.service_instance.bind_route"),
    AUDIT_SERVICE_INSTANCE_CREATE("audit.service_instance.create"),
    AUDIT_SERVICE_INSTANCE_DELETE("audit.service_instance.delete"),
    AUDIT_SERVICE_INSTANCE_UNBIND_ROUTE("audit.service_instance.unbind_route"),
    AUDIT_SERVICE_INSTANCE_UPDATE("audit.service_instance.update"),
    AUDIT_SERVICE_KEY_CREATE("audit.service_key.create"),
    AUDIT_SERVICE_KEY_DELETE("audit.service_key.delete"),
    AUDIT_SERVICE_PLAN_CREATE("audit.service_plan.create"),
    AUDIT_SERVICE_PLAN_DELETE("audit.service_plan.delete"),
    AUDIT_SERVICE_PLAN_UPDATE("audit.service_plan.update"),
    AUDIT_SERVICE_PLAN_VISIBILITY_CREATE("audit.service_plan_visibility.create"),
    AUDIT_SERVICE_PLAN_VISIBILITY_DELETE("audit.service_plan_visibility.delete"),
    AUDIT_SERVICE_PLAN_VISIBILITY_UPDATE("audit.service_plan_visibility.update"),
    AUDIT_SPACE_CREATE("audit.space.create"),
    AUDIT_SPACE_DELETE_REQUEST("audit.space.delete-request"),
    AUDIT_SPACE_UPDATE("audit.space.update"),
    AUDIT_USER_PROVIDED_SERVICE_INSTANCE_CREATE("audit.user_provided_service_instance.create"),
    AUDIT_USER_PROVIDED_SERVICE_INSTANCE_DELETE("audit.user_provided_service_instance.delete"),
    AUDIT_USER_PROVIDED_SERVICE_INSTANCE_UPDATE("audit.user_provided_service_instance.update"),
    AUDIT_USER_SPACE_AUDITOR_ADD("audit.user.space_auditor_add"),
    AUDIT_USER_SPACE_AUDITOR_REMOVE("audit.user.space_auditor_remove"),
    AUDIT_USER_SPACE_MANAGER_ADD("audit.user.space_manager_add"),
    AUDIT_USER_SPACE_MANAGER_REMOVE("audit.user.space_manager_remove"),
    AUDIT_USER_SPACE_DEVELOPER_ADD("audit.user.space_developer_add"),
    AUDIT_USER_SPACE_DEVELOPER_REMOVE("audit.user.space_developer_remove"),
    AUDIT_USER_ORGANIZATION_AUDITOR_ADD("audit.user.organization_auditor_add"),
    AUDIT_USER_ORGANIZATION_AUDITOR_REMOVE("audit.user.organization_auditor_remove"),
    AUDIT_USER_ORGANIZATION_BILLING_MANAGER_ADD("audit.user.organization_billing_manager_add"),
    AUDIT_USER_ORGANIZATION_BILLING_MANAGER_REMOVE("audit.user.organization_billing_manager_remove"),
    AUDIT_USER_ORGANIZATION_MANAGER_ADD("audit.user.organization_manager_add"),
    AUDIT_USER_ORGANIZATION_MANAGER_REMOVE("audit.user.organization_manager_remove"),
    AUDIT_USER_ORGANIZATION_USER_ADD("audit.user.organization_user_add"),
    AUDIT_USER_ORGANIZATION_USER_REMOVE("audit.user.organization_user_remove"),
    BLOB_REMOVE_ORPHAN("blob.remove_orphan"),
    AUDIT_APP_BUILD_CREATE("audit.app.build.create"),
    AUDIT_APP_DROPLET_CREATE("audit.app.droplet.create"),
    AUDIT_APP_DROPLET_DELETE("audit.app.droplet.delete"),
    AUDIT_APP_DROPLET_DOWNLOAD("audit.app.droplet.download"),
    AUDIT_APP_PROCESS_CRASH("audit.app.process.crash"),
    AUDIT_APP_PROCESS_CREATE("audit.app.process.create"),
    AUDIT_APP_PROCESS_DELETE("audit.app.process.delete"),
    AUDIT_APP_PROCESS_SCALE("audit.app.process.scale"),
    AUDIT_APP_PROCESS_TERMINATE_INSTANCE("audit.app.process.terminate_instance"),
    AUDIT_APP_PROCESS_UPDATE("audit.app.process.update"),
    AUDIT_APP_TASK_CANCEL("audit.app.task.cancel"),
    AUDIT_APP_TASK_CREATE("audit.app.task.create"),
    AUDIT_SERVICE_INSTANCE_SHARE("audit.service_instance.share"),
    AUDIT_SERVICE_INSTANCE_UNSHARE("audit.service_instance.unshare");

    public static EventType from(String id) {
        EventType result = null;
        List<EventType> candidates = Arrays.asList(EventType.values()).stream().filter(et -> et.getId().equalsIgnoreCase(id)).collect(Collectors.toList());
        if (candidates != null && candidates.size() == 1) {
            result = candidates.get(0);
        }
        Assert.isTrue(result != null, "Not a valid event type identifier");
        return result;
    }

    private final String id;

    EventType(String id) {
        this.id = id;
    }

    public String getId() {
        return id;
    }
}


================================================
File: src/main/java/org/cftoolsuite/cfapp/domain/event/Events.java
================================================
package org.cftoolsuite.cfapp.domain.event;

import java.util.ArrayList;
import java.util.List;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;

import lombok.Builder;
import lombok.Builder.Default;
import lombok.Getter;

@Builder
@Getter
@JsonInclude(JsonInclude.Include.NON_NULL)
@JsonPropertyOrder({
    "next_url",
    "prev_url",
    "resources",
    "total_pages",
    "total_results"
})
public class Events {

    @JsonProperty("next_url")
    private String nextUrl;

    @JsonProperty("prev_url")
    private String prevUrl;

    @Default
    @JsonProperty("resources")
    private List<Resource> resources = new ArrayList<>();

    @Default
    @JsonProperty("total_pages")
    private Integer totalPages = 0;

    @Default
    @JsonProperty("total_results")
    private Integer totalResults = 0;

    @JsonCreator
    public Events(
            @JsonProperty("next_url") String nextUrl,
            @JsonProperty("prev_url") String prevUrl,
            @JsonProperty("resources") List<Resource> resources,
            @JsonProperty("total_pages") Integer totalPages,
            @JsonProperty("total_results") Integer totalResults
            ) {
        this.nextUrl = nextUrl;
        this.prevUrl = prevUrl;
        this.resources = resources;
        this.totalPages = totalPages;
        this.totalResults = totalResults;
    }

    @JsonIgnore
    public boolean hasNoEvents() {
        return resources.isEmpty();
    }

}


================================================
File: src/main/java/org/cftoolsuite/cfapp/domain/event/Request.java
================================================
package org.cftoolsuite.cfapp.domain.event;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;

import lombok.Builder;
import lombok.Getter;

@Builder
@Getter
@JsonInclude(JsonInclude.Include.NON_NULL)
@JsonPropertyOrder({
    "instances",
    "state",
    "related_guid",
    "relation",
    "route",
    "verb",
    "buildpack",
    "command",
    "console",
    "docker_credentials",
    "environment_json",
    "health_check_type",
    "memory",
    "name",
    "production",
    "space_guid",
    "stack_guid"
})
public class Request {

    @JsonProperty("instances")
    private Integer instances;

    @JsonProperty("state")
    private String state;

    @JsonProperty("related_guid")
    private String relatedGuid;

    @JsonProperty("relation")
    private String relation;

    @JsonProperty("route")
    private String route;

    @JsonProperty("verb")
    private String verb;

    @JsonProperty("buildpack")
    private String buildpack;

    @JsonProperty("command")
    private String command;

    @JsonProperty("console")
    private Boolean console;

    @JsonProperty("docker_credentials")
    private String dockerCredentials;

    @JsonProperty("environment_json")
    private String environmentJson;

    @JsonProperty("health_check_type")
    private String healthCheckType;

    @JsonProperty("memory")
    private Integer memory;

    @JsonProperty("name")
    private String name;

    @JsonProperty("production")
    private Boolean production;

    @JsonProperty("space_guid")
    private String spaceGuid;

    @JsonProperty("stack_guid")
    private String stackGuid;

    @JsonCreator
    public Request(
            @JsonProperty("instances") Integer instances,
            @JsonProperty("state") String state,
            @JsonProperty("related_guid") String relatedGuid,
            @JsonProperty("relation") String relation,
            @JsonProperty("route") String route,
            @JsonProperty("verb") String verb,
            @JsonProperty("buildpack") String buildpack,
            @JsonProperty("command") String command,
            @JsonProperty("console") Boolean console,
            @JsonProperty("docker_credentials") String dockerCredentials,
            @JsonProperty("environment_json") String environmentJson,
            @JsonProperty("health_check_type") String healthCheckType,
            @JsonProperty("memory") Integer memory,
            @JsonProperty("name") String name,
            @JsonProperty("production") Boolean production,
            @JsonProperty("space_guid") String spaceGuid,
            @JsonProperty("stack_guid") String stackGuid) {
        this.instances = instances;
        this.state = state;
        this.relatedGuid = relatedGuid;
        this.relation = relation;
        this.route = route;
        this.verb = verb;
        this.buildpack = buildpack;
        this.command = command;
        this.console = console;
        this.dockerCredentials = dockerCredentials;
        this.environmentJson = environmentJson;
        this.healthCheckType = healthCheckType;
        this.memory = memory;
        this.name = name;
        this.production = production;
        this.spaceGuid = spaceGuid;
        this.stackGuid = stackGuid;
    }

}


================================================
File: src/main/java/org/cftoolsuite/cfapp/domain/event/Resource.java
================================================
package org.cftoolsuite.cfapp.domain.event;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;

import lombok.Builder;
import lombok.Getter;

@Builder
@Getter
@JsonInclude(JsonInclude.Include.NON_NULL)
@JsonPropertyOrder({
    "entity",
    "metadata"
})
public class Resource {

    @JsonProperty("entity")
    private Entity entity;

    @JsonProperty("metadata")
    private ResourceMetadata metadata;

    @JsonCreator
    public Resource(
            @JsonProperty("entity") Entity entity,
            @JsonProperty("metadata") ResourceMetadata metadata
            ) {
        this.entity = entity;
        this.metadata = metadata;
    }

}


================================================
File: src/main/java/org/cftoolsuite/cfapp/domain/event/ResourceMetadata.java
================================================
package org.cftoolsuite.cfapp.domain.event;

import java.time.Instant;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;

import lombok.Builder;
import lombok.Getter;

@Builder
@Getter
@JsonInclude(JsonInclude.Include.NON_NULL)
@JsonPropertyOrder({
    "created_at",
    "guid",
    "updated_at",
    "url"
})
public class ResourceMetadata {

    @JsonProperty("created_at")
    private Instant createdAt;

    @JsonProperty("guid")
    private String guid;

    @JsonProperty("updated_at")
    private Instant updatedAt;

    @JsonProperty("url")
    private String url;

    @JsonCreator
    public ResourceMetadata(
            @JsonProperty("created_at") Instant createdAt,
            @JsonProperty("guid") String guid,
            @JsonProperty("updated_at") Instant updatedAt,
            @JsonProperty("url") String url) {
        this.createdAt = createdAt;
        this.guid = guid;
        this.updatedAt = updatedAt;
        this.url = url;
    }

}


================================================
File: src/main/java/org/cftoolsuite/cfapp/domain/product/ArtifactReferences.java
================================================

package org.cftoolsuite.cfapp.domain.product;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;

import lombok.Builder;
import lombok.Getter;

@Builder
@Getter
@JsonPropertyOrder({
    "href"
})
public class ArtifactReferences {

    @JsonProperty("href")
    private String href;

    @JsonCreator
    public ArtifactReferences(@JsonProperty("href") String href) {
        this.href = href;
    }

}


================================================
File: src/main/java/org/cftoolsuite/cfapp/domain/product/DeployedProduct.java
================================================
package org.cftoolsuite.cfapp.domain.product;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;

import lombok.Builder;
import lombok.Getter;

@Builder
@Getter
@JsonPropertyOrder({
    "installation_name",
    "guid",
    "type",
    "product_version",
    "label",
    "service_broker",
    "stale"
})
public class DeployedProduct {

    @JsonProperty("installation_name")
    private String installationName;

    @JsonProperty("guid")
    private String guid;

    @JsonProperty("type")
    private String type;

    @JsonProperty("product_version")
    private String productVersion;

    @JsonProperty("label")
    private String label;

    @JsonProperty("service_broker")
    private Boolean serviceBroker;

    @JsonProperty("stale")
    private Staleness stale;

    @JsonCreator
    public DeployedProduct(
            @JsonProperty("installation_name") String installationName,
            @JsonProperty("guid") String guid,
            @JsonProperty("type") String type,
            @JsonProperty("product_version") String productVersion,
            @JsonProperty("label") String label,
            @JsonProperty("service_broker") Boolean serviceBroker,
            @JsonProperty("stale") Staleness stale
            ) {
        this.installationName = installationName;
        this.guid = guid;
        this.type = type;
        this.productVersion = productVersion;
        this.label = label;
        this.serviceBroker = serviceBroker;
        this.stale = stale;
    }
}


================================================
File: src/main/java/org/cftoolsuite/cfapp/domain/product/Eula.java
================================================
package org.cftoolsuite.cfapp.domain.product;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;

import lombok.Builder;
import lombok.Builder.Default;
import lombok.Getter;

@Builder
@Getter
@JsonPropertyOrder({
    "id",
    "slug",
    "name",
    "_links",
    "archived_at"
})
public class Eula {

    @Default
    @JsonProperty("id")
    private Long id = -1L;

    @JsonProperty("slug")
    private String slug;

    @JsonProperty("name")
    private String name;

    @JsonProperty("_links")
    private EulaLinks links;

    @JsonProperty
    private String archivedAt;

    @JsonCreator
    public Eula(
            @JsonProperty("id") Long id,
            @JsonProperty("slug") String slug,
            @JsonProperty("name") String name,
            @JsonProperty("_links") EulaLinks links,
            @JsonProperty("archived_at") String archivedAt
            ) {
        this.id = id;
        this.slug = slug;
        this.name = name;
        this.links = links;
        this.archivedAt = archivedAt;
    }
}


================================================
File: src/main/java/org/cftoolsuite/cfapp/domain/product/EulaAcceptance.java
================================================
package org.cftoolsuite.cfapp.domain.product;

import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;

import lombok.Builder;
import lombok.Getter;

@Builder
@Getter
@JsonPropertyOrder({
    "href"
})
public class EulaAcceptance {

    @JsonProperty("href")
    private String href;

    public EulaAcceptance(@JsonProperty("href") String href) {
        this.href = href;
    }
}


================================================
File: src/main/java/org/cftoolsuite/cfapp/domain/product/EulaLinks.java
================================================

package org.cftoolsuite.cfapp.domain.product;

import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;

import lombok.Builder;
import lombok.Getter;


@Builder
@Getter
@JsonPropertyOrder({
    "self"
})
public class EulaLinks {

    @JsonProperty("self")
    private Self self;

    public EulaLinks(
            @JsonProperty("self") Self self
            ) {
        this.self = self;
    }

}


================================================
File: src/main/java/org/cftoolsuite/cfapp/domain/product/FileGroups.java
================================================

package org.cftoolsuite.cfapp.domain.product;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;

import lombok.Builder;
import lombok.Getter;

@Builder
@Getter
@JsonPropertyOrder({
    "href"
})
public class FileGroups {

    @JsonProperty("href")
    private String href;

    @JsonCreator
    public FileGroups(@JsonProperty("href") String href) {
        this.href = href;
    }

}


================================================
File: src/main/java/org/cftoolsuite/cfapp/domain/product/OmInfo.java
================================================
package org.cftoolsuite.cfapp.domain.product;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonProperty;

import lombok.Builder;
import lombok.Getter;

@Builder
@Getter
public class OmInfo {

    @Builder
    @Getter
    public static class Info {

        @JsonProperty("version")
        private String version;

        @JsonCreator
        public Info(@JsonProperty("version") String version) {
            this.version = version;
        }
    }

    @JsonProperty("info")
    private Info info;

    @JsonCreator
    public OmInfo(@JsonProperty("info") Info info) {
        this.info = info;
    }

    public Integer getMajorVersion() {
        String[] versionParts = info.getVersion().split("v");
        String[] buildParts = versionParts[0].split("-");
        String[] majorMinorParts = buildParts[0].split("\\.");
        return Integer.valueOf(majorMinorParts[0]);
    }

    public Integer getMinorVersion() {
        String[] versionParts = info.getVersion().split("v");
        String[] buildParts = versionParts[0].split("-");
        String[] majorMinorParts = buildParts[0].split("\\.");
        return Integer.valueOf(majorMinorParts[1]);
    }
}


================================================
File: src/main/java/org/cftoolsuite/cfapp/domain/product/PivnetCache.java
================================================
package org.cftoolsuite.cfapp.domain.product;

import java.util.ArrayList;
import java.util.Comparator;
import java.util.List;
import java.util.stream.Collectors;

import org.springframework.stereotype.Component;
import org.springframework.util.CollectionUtils;

import lombok.Data;
import lombok.extern.slf4j.Slf4j;

@Data
@Component
@Slf4j
public class PivnetCache {

    private Products products;
    private List<Release> allProductReleases = new ArrayList<>();
    private List<Release> latestProductReleases = new ArrayList<>();

    public Release findLatestMinorProductReleaseBySlugAndVersion(String slug, String version) {
        List<Release> candidates =
            allProductReleases
                .stream()
                .filter(release ->
                    release.getSlug().equals(slug) && version.startsWith(release.getVersion().split("\\.")[0]))
                .sorted(Comparator.comparing(Release::getReleaseDate).reversed())
                .collect(Collectors.toList());
        if (!CollectionUtils.isEmpty(candidates)) {
            log.trace("Found latest minor release by {} and {}. \n\t {}", slug, version, candidates.get(0).toCsv());
            return candidates.get(0);
        } else {
            log.trace("No match found for latest minor release by {} and {}.", slug, version);
            return Release.empty();
        }
    }

    public Release findLatestProductReleaseBySlug(String slug) {
        List<Release> candidates =
            latestProductReleases
                .stream()
                .filter(release -> release.getSlug().equals(slug))
                .collect(Collectors.toList());
        if (!CollectionUtils.isEmpty(candidates)) {
            log.trace("Found latest release by {}. \n\t {}", slug, candidates.get(0).toCsv());
            return candidates.get(0);
        } else {
            log.trace("No match found for latest release by {}.", slug);
            return Release.empty();
        }
    }

    public Release findProductReleaseBySlugAndVersion(String slug, String version) {
        List<Release> candidates =
            allProductReleases
                .stream()
                .filter(release ->
                    release.getSlug().equals(slug) &&
                        (release.getVersion().equals(version) || version.startsWith(release.getVersion())))
                .collect(Collectors.toList());
        if (!CollectionUtils.isEmpty(candidates)) {
            log.trace("Found release by {} and {}. \n\t {}", slug, version, candidates.get(0).toCsv());
            return candidates.get(0);
        } else {
            log.trace("No match found for release by {} and {}.", slug, version);
            return Release.empty();
        }
    }

}


================================================
File: src/main/java/org/cftoolsuite/cfapp/domain/product/Product.java
================================================

package org.cftoolsuite.cfapp.domain.product;

import java.util.ArrayList;
import java.util.List;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;

import lombok.Builder;
import lombok.Builder.Default;
import lombok.Getter;

@Builder
@Getter
@JsonPropertyOrder({
    "id",
    "slug",
    "name",
    "logo_url",
    "_links",
    "platform_compatibility",
    "installs_on_pks"
})
public class Product {

    @Default
    @JsonProperty("id")
    private Long id = -1L;

    @JsonProperty("slug")
    private String slug;

    @JsonProperty("name")
    private String name;

    @JsonProperty("logo_url")
    private String logoUrl;

    @JsonProperty("_links")
    private ProductLinks links;

    @Default
    @JsonProperty("platform_compatibility")
    private List<String> platformCompatibility = new ArrayList<>();

    @JsonProperty("installs_on_pks")
    private Boolean installsOnPks;

    @JsonCreator
    public Product(
            @JsonProperty("id") Long id,
            @JsonProperty("slug") String slug,
            @JsonProperty("name") String name,
            @JsonProperty("logo_url") String logoUrl,
            @JsonProperty("_links") ProductLinks links,
            @JsonProperty("platform_compatibility") List<String> platformCompatibility,
            @JsonProperty("installs_on_pks") Boolean installsOnPks
            ) {
        this.id = id;
        this.slug = slug;
        this.name = name;
        this.logoUrl = logoUrl;
        this.links = links;
        this.platformCompatibility = platformCompatibility;
        this.installsOnPks = installsOnPks;
    }
}


================================================
File: src/main/java/org/cftoolsuite/cfapp/domain/product/ProductFiles.java
================================================

package org.cftoolsuite.cfapp.domain.product;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;

import lombok.Builder;
import lombok.Getter;

@Builder
@Getter
@JsonPropertyOrder({
    "href"
})
public class ProductFiles {

    @JsonProperty("href")
    private String href;

    @JsonCreator
    public ProductFiles(@JsonProperty("href") String href) {
        this.href = href;
    }

}


================================================
File: src/main/java/org/cftoolsuite/cfapp/domain/product/ProductLinks.java
================================================

package org.cftoolsuite.cfapp.domain.product;

import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;

import lombok.Builder;
import lombok.Getter;


@Builder
@Getter
@JsonPropertyOrder({
    "self",
    "releases",
    "product_files",
    "file_groups"
})
public class ProductLinks {

    @JsonProperty("self")
    private Self self;

    @JsonProperty("releases")
    private Releases releases;

    @JsonProperty("product_files")
    private ProductFiles productFiles;

    @JsonProperty("file_groups")
    private FileGroups fileGroups;

    public ProductLinks(
            @JsonProperty("self") Self self,
            @JsonProperty("releases") Releases releases,
            @JsonProperty("product_files") ProductFiles productFiles,
            @JsonProperty("file_groups") FileGroups fileGroups
            ) {
        this.self = self;
        this.releases = releases;
        this.productFiles = productFiles;
        this.fileGroups = fileGroups;
    }

}


================================================
File: src/main/java/org/cftoolsuite/cfapp/domain/product/ProductMetric.java
================================================
package org.cftoolsuite.cfapp.domain.product;

import java.time.LocalDate;
import java.time.temporal.ChronoUnit;

import org.apache.commons.lang3.StringUtils;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;

import lombok.Builder;
import lombok.EqualsAndHashCode;
import lombok.Getter;

@Builder
@Getter
@JsonPropertyOrder({
    "name", "type", "currently-installed-release-date", "currently-installed-version",
    "latest-available-release-date", "latest-available-version", "end-of-support-date",
    "days-behind-latest-available-version", "days-out-of-support", "end-of-life", "pre-release"
})
@EqualsAndHashCode
public class ProductMetric {

    public static String headers() {
        return String.join("name", "type", "currently-installed-release-date", "currently-installed-version",
                "latest-available-release-date", "latest-available-version", "end-of-support-date",
                "days-behind-latest-available-version", "days-out-of-support", "end-of-life", "pre-release");
    }

    private static String wrap(String value) {
        return value != null ? StringUtils.wrap(value, '"') : StringUtils.wrap("", '"');
    }

    @JsonProperty("name")
    private String name;

    @JsonProperty("type")
    private ProductType type;

    @JsonProperty("currently-installed-release-date")
    private LocalDate currentlyInstalledReleaseDate;

    @JsonProperty("currently-installed-version")
    private String currentlyInstalledVersion;

    @JsonProperty("latest-available-release-date")
    private LocalDate latestAvailableReleaseDate;

    @JsonProperty("latest-available-version")
    private String latestAvailableVersion;

    @JsonProperty("end-of-support-date")
    private LocalDate endOfSupportDate;

    @JsonCreator
    public ProductMetric(
            @JsonProperty("name") String name,
            @JsonProperty("type") ProductType type,
            @JsonProperty("currently-installed-release-date") LocalDate currentlyInstalledReleaseDate,
            @JsonProperty("currently-installed-version") String currentlyInstalledVersion,
            @JsonProperty("latest-available-release-date") LocalDate latestAvailableReleaseDate,
            @JsonProperty("latest-available-version") String latestAvailableVersion,
            @JsonProperty("end-of-support-date") LocalDate endOfSupportDate
            ) {
        this.name = name;
        this.type = type;
        this.currentlyInstalledReleaseDate = currentlyInstalledReleaseDate;
        this.currentlyInstalledVersion = currentlyInstalledVersion;
        this.latestAvailableReleaseDate = latestAvailableReleaseDate;
        this.latestAvailableVersion = latestAvailableVersion;
        this.endOfSupportDate = endOfSupportDate;
    }

    @JsonProperty("days-behind-latest-available-version")
    public Long getDaysBehindLatestAvailableVersion() {
        Long result = null;
        if (currentlyInstalledReleaseDate != null && latestAvailableReleaseDate != null) {
            result = ChronoUnit.DAYS.between(currentlyInstalledReleaseDate, latestAvailableReleaseDate);
        }
        return result;
    }

    @JsonProperty("days-out-of-support")
    public Long getDaysOutOfSupport() {
        Long result = null;
        if (isEndOfLife()) {
            result = ChronoUnit.DAYS.between(endOfSupportDate, LocalDate.now());
        }
        return result;
    }

    @JsonProperty("end-of-life")
    public boolean isEndOfLife() {
        boolean result = false;
        LocalDate today = LocalDate.now();
        if (endOfSupportDate != null && today.isAfter(endOfSupportDate)) {
            result = true;
        }
        return result;
    }

    @JsonProperty("pre-release")
    public boolean isPreRelease() {
        boolean result = false;
        if (currentlyInstalledReleaseDate == null || latestAvailableReleaseDate == null) {
            result = true;
        }
        return result;
    }

    public String toCsv() {
        return String.join(",", wrap(getName()), wrap(getType().getId()),
                wrap(getCurrentlyInstalledReleaseDate() != null ? getCurrentlyInstalledReleaseDate().toString(): ""),
                wrap(getCurrentlyInstalledVersion()), wrap(getLatestAvailableReleaseDate() != null ? getLatestAvailableReleaseDate().toString(): ""),
                wrap(getLatestAvailableVersion()), wrap(getEndOfSupportDate() != null ? getEndOfSupportDate().toString(): ""),
                wrap(getDaysBehindLatestAvailableVersion() != null ? String.valueOf(getDaysBehindLatestAvailableVersion()): ""),
                wrap(getDaysOutOfSupport() != null ? String.valueOf(getDaysOutOfSupport()): ""),
                wrap(String.valueOf(isEndOfLife())), wrap(String.valueOf(isPreRelease()))
                );
    }

}


================================================
File: src/main/java/org/cftoolsuite/cfapp/domain/product/ProductMetrics.java
================================================
package org.cftoolsuite.cfapp.domain.product;

import java.util.Set;
import java.util.TreeSet;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;

import lombok.Builder;
import lombok.Builder.Default;
import lombok.Getter;

@Builder
@Getter
@JsonPropertyOrder({ "product-metrics "})
public class ProductMetrics {

    @Default
    @JsonProperty("product-metrics")
    Set<ProductMetric> productMetrics = new TreeSet<>();

    @JsonCreator
    public ProductMetrics(Set<ProductMetric> productMetrics) {
        this.productMetrics = productMetrics;
    }
}


================================================
File: src/main/java/org/cftoolsuite/cfapp/domain/product/ProductType.java
================================================
package org.cftoolsuite.cfapp.domain.product;

import com.fasterxml.jackson.annotation.JsonValue;

public enum ProductType {
    BUILDPACK("buildpack"),
    STEMCELL("stemcell"),
    TILE("tile");

    public static ProductType from(String value) {
        ProductType result = ProductType.TILE;
        if (value.contains("stemcell")) {
            result = ProductType.STEMCELL;
        } else if (value.contains("buildpack")) {
            result = ProductType.BUILDPACK;
        }
        return result;
    }

    private String id;

    ProductType(String id) {
        this.id = id;
    }

    @JsonValue
    public String getId() {
        return id;
    }
}


================================================
File: src/main/java/org/cftoolsuite/cfapp/domain/product/Products.java
================================================

package org.cftoolsuite.cfapp.domain.product;

import java.util.ArrayList;
import java.util.List;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;

import lombok.Builder;
import lombok.Builder.Default;
import lombok.Getter;


@Builder
@Getter
@JsonPropertyOrder({
    "products"
})
public class Products {

    @Default
    @JsonProperty("products")
    private List<Product> products = new ArrayList<>();

    @JsonCreator
    public Products(@JsonProperty("products") List<Product> products) {
        this.products = products;
    }
}


================================================
File: src/main/java/org/cftoolsuite/cfapp/domain/product/Release.java
================================================
package org.cftoolsuite.cfapp.domain.product;

import java.time.Instant;
import java.time.LocalDate;
import java.time.format.DateTimeFormatter;

import org.apache.commons.lang3.StringUtils;
import org.cftoolsuite.cfapp.deser.RelaxedLocalDateDeserializer;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;
import com.fasterxml.jackson.databind.annotation.JsonDeserialize;

import lombok.Builder;
import lombok.Builder.Default;
import lombok.Getter;

@Builder
@Getter
@JsonPropertyOrder({
    "id",
    "slug",
    "version",
    "release_type",
    "release_date",
    "release_notes_url",
    "availability",
    "description",
    "eula",
    "end_of_support_date",
    "end_of_guidance_date",
    "end_of_availability_date",
    "eccn",
    "license_exception",
    "updated_at",
    "software_files_updated_at",
    "_links"
})
public class Release {

    private static final String BASE_URL = "https://network.tanzu.vmware.com/api/v2/products/";

    public static Release empty() {
        return Release.builder().build();
    }

    public static String headers() {
        return String.join(",", "id", "slug", "version", "release_type", "release_date",
                "release_notes_url", "availability", "description", "end_of_support_date",
                "end_of_guidance_date", "end_of_availability_date", "eccn", "license_exception", "updated_at",
                "software_files_updated_at");
    }

    private static String wrap(String value) {
        return value != null ? StringUtils.wrap(value, '"') : StringUtils.wrap("", '"');
    }

    @Default
    @JsonProperty("id")
    private Long id = -1L;

    @JsonProperty("version")
    private String version;

    @JsonProperty("release_type")
    private String releaseType;

    @JsonDeserialize(using = RelaxedLocalDateDeserializer.class)
    @JsonProperty("release_date")
    private LocalDate releaseDate;

    @JsonProperty("release_notes_url")
    private String releaseNotesUrl;

    @JsonProperty("availability")
    private String availability;

    @JsonProperty("description")
    private String description;

    @JsonProperty("eula")
    private Eula eula;

    @JsonDeserialize(using = RelaxedLocalDateDeserializer.class)
    @JsonProperty("end_of_support_date")
    private LocalDate endOfSupportDate;

    @JsonDeserialize(using = RelaxedLocalDateDeserializer.class)
    @JsonProperty("end_of_guidance_date")
    private LocalDate endOfGuidanceDate;

    @JsonDeserialize(using = RelaxedLocalDateDeserializer.class)
    @JsonProperty("end_of_availability_date")
    private LocalDate endOfAvailabilityDate;

    @JsonProperty("eccn")
    private String eccn;

    @JsonProperty("license_exception")
    private String licenseException;

    @JsonProperty("updated_at")
    private Instant updatedAt;

    @JsonProperty("software_files_updated_at")
    private Instant softwareFilesUpdatedAt;

    @JsonProperty("_links")
    private ReleaseLinks links;

    @JsonCreator
    public Release(
            @JsonProperty("id") Long id,
            @JsonProperty("version") String version,
            @JsonProperty("release_type") String releaseType,
            @JsonProperty("release_date") LocalDate releaseDate,
            @JsonProperty("release_notes_url") String releaseNotesUrl,
            @JsonProperty("availability") String availability,
            @JsonProperty("description") String description,
            @JsonProperty("eula") Eula eula,
            @JsonProperty("end_of_support_date") LocalDate endOfSupportDate,
            @JsonProperty("end_of_guidance_date") LocalDate endOfGuidanceDate,
            @JsonProperty("end_of_availability_date") LocalDate endOfAvailabilityDate,
            @JsonProperty("eccn") String eccn,
            @JsonProperty("license_exception") String licenseException,
            @JsonProperty("updated_at") Instant updatedAt,
            @JsonProperty("software_files_updated_at") Instant softwareFilesUpdatedAt,
            @JsonProperty("_links") ReleaseLinks links
            ) {
        this.id = id;
        this.version = version;
        this.releaseType = releaseType;
        this.releaseDate = releaseDate;
        this.releaseNotesUrl = releaseNotesUrl;
        this.availability = availability;
        this.description = description;
        this.eula = eula;
        this.endOfSupportDate = endOfSupportDate;
        this.endOfGuidanceDate = endOfGuidanceDate;
        this.endOfAvailabilityDate = endOfAvailabilityDate;
        this.eccn = eccn;
        this.licenseException = licenseException;
        this.updatedAt = updatedAt;
        this.softwareFilesUpdatedAt = softwareFilesUpdatedAt;
        this.links = links;
    }

    @JsonProperty("slug")
    public String getSlug() {
        String ref = getLinks().getSelf().getHref();
        String refStrippedOfBaseUrl = ref.replace(BASE_URL, "");
        String slug = refStrippedOfBaseUrl.split("/")[0];
        return slug;
    }

    public String toCsv() {
        return String.join(",", wrap(String.valueOf(getId())), wrap(getSlug()), wrap(getVersion()),
                wrap(getReleaseType()), wrap(getReleaseDate() != null ? getReleaseDate().toString(): ""),
                wrap(getReleaseNotesUrl()), wrap(getAvailability()), wrap(getDescription()),
                wrap(getEndOfSupportDate() != null ? DateTimeFormatter.ISO_LOCAL_DATE.format(getEndOfSupportDate()): null),
                wrap(getEndOfGuidanceDate() != null ? DateTimeFormatter.ISO_LOCAL_DATE.format(getEndOfGuidanceDate()): null),
                wrap(getEndOfAvailabilityDate() != null ? DateTimeFormatter.ISO_LOCAL_DATE.format(getEndOfAvailabilityDate()): null),
                wrap(getEccn()), wrap(getLicenseException()), wrap(getUpdatedAt() != null ? getUpdatedAt().toString(): ""),
                wrap(getSoftwareFilesUpdatedAt() != null ? getSoftwareFilesUpdatedAt().toString(): ""));
    }

}


================================================
File: src/main/java/org/cftoolsuite/cfapp/domain/product/ReleaseLinks.java
================================================

package org.cftoolsuite.cfapp.domain.product;

import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;

import lombok.Builder;
import lombok.Getter;


@Builder
@Getter
@JsonPropertyOrder({
    "self",
    "eula_acceptance",
    "product_files",
    "file_groups",
    "user_groups",
    "artifact_references"
})
public class ReleaseLinks {

    @JsonProperty("self")
    private Self self;

    @JsonProperty("eula_acceptance")
    private EulaAcceptance eulaAcceptance;

    @JsonProperty("product_files")
    private ProductFiles productFiles;

    @JsonProperty("file_groups")
    private FileGroups fileGroups;

    @JsonProperty("user_groups")
    private UserGroups userGroups;

    @JsonProperty("artifact_references")
    private ArtifactReferences artifactReferences;

    public ReleaseLinks(
            @JsonProperty("self") Self self,
            @JsonProperty("eula_acceptance") EulaAcceptance eulaAcceptance,
            @JsonProperty("product_files") ProductFiles productFiles,
            @JsonProperty("file_groups") FileGroups fileGroups,
            @JsonProperty("user_groups") UserGroups userGroups,
            @JsonProperty("artifact_references") ArtifactReferences artifactReferences
            ) {
        this.self = self;
        this.eulaAcceptance = eulaAcceptance;
        this.productFiles = productFiles;
        this.fileGroups = fileGroups;
        this.userGroups = userGroups;
        this.artifactReferences = artifactReferences;
    }

}


================================================
File: src/main/java/org/cftoolsuite/cfapp/domain/product/Releases.java
================================================

package org.cftoolsuite.cfapp.domain.product;

import java.util.ArrayList;
import java.util.List;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;

import lombok.Builder;
import lombok.Builder.Default;
import lombok.Getter;

@Builder
@Getter
@JsonPropertyOrder({
    "releases"
})
public class Releases {

    @Default
    @JsonProperty("releases")
    private List<Release> releases = new ArrayList<>();

    @JsonCreator
    public Releases(@JsonProperty("releases") List<Release> releases) {
        this.releases = releases;
    }
}



================================================
File: src/main/java/org/cftoolsuite/cfapp/domain/product/Self.java
================================================

package org.cftoolsuite.cfapp.domain.product;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;

import lombok.Builder;
import lombok.Getter;

@Builder
@Getter
@JsonPropertyOrder({
    "href"
})
public class Self {

    @JsonProperty("href")
    private String href;

    @JsonCreator
    public Self(@JsonProperty("href") String href) {
        this.href = href;
    }

}


================================================
File: src/main/java/org/cftoolsuite/cfapp/domain/product/Staleness.java
================================================
package org.cftoolsuite.cfapp.domain.product;

import java.util.ArrayList;
import java.util.List;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;

import lombok.Builder;
import lombok.Builder.Default;
import lombok.Getter;

@Builder
@Getter
@JsonPropertyOrder({
    "parent_products_deployed_more_recently"
})
public class Staleness {

    @Default
    @JsonProperty("parent_products_deployed_more_recently")
    private List<String> parentProductsDeployedMoreRecently = new ArrayList<>();

    @JsonCreator
    public Staleness(
            @JsonProperty("parent_products_deployed_more_recently") List<String> parentProductsDeployedMoreRecently
            ) {
        this.parentProductsDeployedMoreRecently = parentProductsDeployedMoreRecently;
    }
}


================================================
File: src/main/java/org/cftoolsuite/cfapp/domain/product/StemcellAssignment.java
================================================
package org.cftoolsuite.cfapp.domain.product;

import java.util.ArrayList;
import java.util.List;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;

import lombok.Builder;
import lombok.Builder.Default;
import lombok.Getter;

@Builder
@Getter
@JsonPropertyOrder({
    "available_stemcell_versions",
    "deployed_product_version",
    "deployed_stemcell_version",
    "guid",
    "identifier",
    "is_staged_for_deletion",
    "label",
    "required_stemcell_os",
    "required_stemcell_version",
    "staged_product_version",
    "staged_stemcell_version",
})
public class StemcellAssignment {

    @Default
    @JsonProperty("available_stemcell_versions")
    private List<String> availableStemcellVersions = new ArrayList<>();

    @JsonProperty("deployed_product_version")
    private String deployedProductVersion;

    @JsonProperty("deployed_stemcell_version")
    private String deployedStemcellVersion;

    @JsonProperty("guid")
    private String guid;

    @JsonProperty("identifier")
    private String identifier;

    @JsonProperty("is_staged_for_deletion")
    private Boolean isStagedForDeletion;

    @JsonProperty("label")
    private String label;

    @JsonProperty("required_stemcell_os")
    private String requiredStemcellOs;

    @JsonProperty("required_stemcell_version")
    private String requiredStemcellVersion;

    @JsonProperty("staged_product_version")
    private String stagedProductVersion;

    @JsonProperty("staged_stemcell_version")
    private String stagedStemcellVersion;

    @JsonCreator
    public StemcellAssignment(
            @JsonProperty("available_stemcell_versions") List<String> availableStemcellVersions,
            @JsonProperty("deployed_product_version") String deployedProductVersion,
            @JsonProperty("deployed_stemcell_version") String deployedStemcellVersion,
            @JsonProperty("guid") String guid,
            @JsonProperty("identifier") String identifier,
            @JsonProperty("is_staged_for_deletion") Boolean isStagedForDeletion,
            @JsonProperty("label") String label,
            @JsonProperty("required_stemcell_os") String requiredStemcellOs,
            @JsonProperty("required_stemcell_version") String requiredStemcellVersion,
            @JsonProperty("staged_product_version") String stagedProductVersion,
            @JsonProperty("staged_stemcell_version") String stagedStemcellVersion
            ) {
        this.availableStemcellVersions = availableStemcellVersions;
        this.deployedProductVersion = deployedProductVersion;
        this.deployedStemcellVersion = deployedStemcellVersion;
        this.guid = guid;
        this.identifier = identifier;
        this.isStagedForDeletion = isStagedForDeletion;
        this.label = label;
        this.requiredStemcellOs = requiredStemcellOs;
        this.requiredStemcellVersion = requiredStemcellVersion;
        this.stagedProductVersion = stagedProductVersion;
        this.stagedStemcellVersion = stagedStemcellVersion;
    }

}


================================================
File: src/main/java/org/cftoolsuite/cfapp/domain/product/StemcellAssignments.java
================================================
package org.cftoolsuite.cfapp.domain.product;

import java.util.ArrayList;
import java.util.List;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;

import lombok.Builder;
import lombok.Builder.Default;
import lombok.Getter;

@Builder
@Getter
@JsonPropertyOrder({
    "products"
})
public class StemcellAssignments {

    @Default
    @JsonProperty("products")
    private List<StemcellAssignment> products = new ArrayList<>();

    @JsonCreator
    public StemcellAssignments(@JsonProperty("products") List<StemcellAssignment> products) {
        this.products = products;
    }
}


================================================
File: src/main/java/org/cftoolsuite/cfapp/domain/product/StemcellAssociation.java
================================================
package org.cftoolsuite.cfapp.domain.product;

import java.util.ArrayList;
import java.util.List;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;

import lombok.Builder;
import lombok.Builder.Default;
import lombok.Getter;

@Builder
@Getter
@JsonPropertyOrder({
    "guid",
    "identifier",
    "label",
    "staged_product_version",
    "deployed_product_version",
    "is_staged_for_deletion",
    "staged_stemcells",
    "deployed_stemcells",
    "available_stemcells",
    "required_stemcells"
})
public class StemcellAssociation {

    @JsonProperty("guid")
    private String guid;

    @JsonProperty("identifier")
    private String identifier;

    @JsonProperty("label")
    private String label;

    @JsonProperty("staged_product_version")
    private String stagedProductVersion;

    @JsonProperty("deployed_product_version")
    private String deployedProductVersion;

    @JsonProperty("is_staged_for_deletion")
    private Boolean isStagedForDeletion;

    @Default
    @JsonProperty("staged_stemcells")
    private List<StemcellDetail> stagedStemcells = new ArrayList<>();

    @Default
    @JsonProperty("deployed_stemcells")
    private List<StemcellDetail> deployedStemcells = new ArrayList<>();

    @Default
    @JsonProperty("available_stemcells")
    private List<StemcellDetail> availableStemcells = new ArrayList<>();

    @Default
    @JsonProperty("required_stemcells")
    private List<StemcellDetail> requiredStemcells = new ArrayList<>();

    @JsonCreator
    public StemcellAssociation(
            @JsonProperty("guid") String guid,
            @JsonProperty("identifier") String identifier,
            @JsonProperty("label") String label,
            @JsonProperty("staged_product_version") String stagedProductVersion,
            @JsonProperty("deployed_product_version") String deployedProductVersion,
            @JsonProperty("is_staged_for_deletion") Boolean isStagedForDeletion,
            @JsonProperty("staged_stemcells") List<StemcellDetail> stagedStemcells,
            @JsonProperty("deployed_stemcells") List<StemcellDetail> deployedStemcells,
            @JsonProperty("available_stemcells") List<StemcellDetail> availableStemcells,
            @JsonProperty("required_stemcells") List<StemcellDetail> requiredStemcells
            ) {
        this.guid = guid;
        this.identifier = identifier;
        this.label = label;
        this.stagedProductVersion = stagedProductVersion;
        this.deployedProductVersion = deployedProductVersion;
        this.isStagedForDeletion = isStagedForDeletion;
        this.stagedStemcells = stagedStemcells;
        this.deployedStemcells = deployedStemcells;
        this.availableStemcells = availableStemcells;
        this.requiredStemcells = requiredStemcells;
    }

}


================================================
File: src/main/java/org/cftoolsuite/cfapp/domain/product/StemcellAssociations.java
================================================
package org.cftoolsuite.cfapp.domain.product;

import java.util.ArrayList;
import java.util.List;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;

import lombok.Builder;
import lombok.Builder.Default;
import lombok.Getter;

@Builder
@Getter
@JsonPropertyOrder({
    "products"
})
public class StemcellAssociations {

    @Default
    @JsonProperty("products")
    private List<StemcellAssociation> products = new ArrayList<>();

    @JsonCreator
    public StemcellAssociations(@JsonProperty("products") List<StemcellAssociation> products) {
        this.products = products;
    }
}


================================================
File: src/main/java/org/cftoolsuite/cfapp/domain/product/StemcellDetail.java
================================================
package org.cftoolsuite.cfapp.domain.product;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;

import lombok.Builder;
import lombok.Getter;

@Builder
@Getter
@JsonPropertyOrder({ "os", "version" })
public class StemcellDetail {

    @JsonProperty("os")
    private String os;

    @JsonProperty("version")
    private String version;

    @JsonCreator
    public StemcellDetail(
            @JsonProperty("os") String os,
            @JsonProperty("version") String version
            ) {
        this.os = os;
        this.version = version;
    }
}


================================================
File: src/main/java/org/cftoolsuite/cfapp/domain/product/UserGroups.java
================================================
package org.cftoolsuite.cfapp.domain.product;

import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;

import lombok.Builder;
import lombok.Getter;

@Builder
@Getter
@JsonPropertyOrder({
    "href"
})
public class UserGroups {

    @JsonProperty("href")
    private String href;

    public UserGroups(@JsonProperty("href") String href) {
        this.href = href;
    }
}


================================================
File: src/main/java/org/cftoolsuite/cfapp/event/AppDetailReadyToBeRetrievedEvent.java
================================================
package org.cftoolsuite.cfapp.event;

import org.springframework.context.ApplicationEvent;

public class AppDetailReadyToBeRetrievedEvent extends ApplicationEvent {

    private static final long serialVersionUID = 1L;

    public AppDetailReadyToBeRetrievedEvent(Object source) {
        super(source);
    }

}


================================================
File: src/main/java/org/cftoolsuite/cfapp/event/AppDetailRetrievedEvent.java
================================================
package org.cftoolsuite.cfapp.event;

import java.util.List;

import org.cftoolsuite.cfapp.domain.AppDetail;
import org.springframework.context.ApplicationEvent;

public class AppDetailRetrievedEvent extends ApplicationEvent {

    private static final long serialVersionUID = 1L;

    private List<AppDetail> detail;

    public AppDetailRetrievedEvent(Object source) {
        super(source);
    }

    public AppDetailRetrievedEvent detail(List<AppDetail> detail) {
        this.detail = detail;
        return this;
    }

    public List<AppDetail> getDetail() {
        return detail;
    }

}


================================================
File: src/main/java/org/cftoolsuite/cfapp/event/AppRelationshipRetrievedEvent.java
================================================
package org.cftoolsuite.cfapp.event;

import java.util.List;

import org.cftoolsuite.cfapp.domain.AppRelationship;
import org.springframework.context.ApplicationEvent;

public class AppRelationshipRetrievedEvent extends ApplicationEvent {

    private static final long serialVersionUID = 1L;

    private List<AppRelationship> relations;

    public AppRelationshipRetrievedEvent(Object source) {
        super(source);
    }

    public List<AppRelationship> getRelations() {
        return relations;
    }

    public AppRelationshipRetrievedEvent relations(List<AppRelationship> relations) {
        this.relations = relations;
        return this;
    }

}


================================================
File: src/main/java/org/cftoolsuite/cfapp/event/BuildpacksRetrievedEvent.java
================================================
package org.cftoolsuite.cfapp.event;

import org.springframework.context.ApplicationEvent;

public class BuildpacksRetrievedEvent extends ApplicationEvent {

    private static final long serialVersionUID = 1L;

    public BuildpacksRetrievedEvent(Object source) {
        super(source);
    }

}


================================================
File: src/main/java/org/cftoolsuite/cfapp/event/DatabaseCreatedEvent.java
================================================
package org.cftoolsuite.cfapp.event;

import org.springframework.context.ApplicationEvent;

public class DatabaseCreatedEvent extends ApplicationEvent {

    private static final long serialVersionUID = 1L;

    public DatabaseCreatedEvent(Object source) {
        super(source);
    }

}


================================================
File: src/main/java/org/cftoolsuite/cfapp/event/EmailNotificationEvent.java
================================================
package org.cftoolsuite.cfapp.event;

import java.util.HashSet;
import java.util.List;
import java.util.Set;

import org.cftoolsuite.cfapp.domain.EmailAttachment;
import org.springframework.context.ApplicationEvent;

public class EmailNotificationEvent extends ApplicationEvent {

    private static final long serialVersionUID = 1L;

    private String domain;
    private Set<String> recipients;
    private Set<String> carbonCopyRecipients;
    private Set<String> blindCarbonCopyRecipients;
    private String from;
    private String subject;
    private String body;
    private List<EmailAttachment> attachments;

    public EmailNotificationEvent(Object source) {
        super(source);
    }

    public EmailNotificationEvent attachments(List<EmailAttachment> attachments) {
        this.attachments = attachments;
        return this;
    }

    public EmailNotificationEvent body(String body) {
        this.body = body;
        return this;
    }

    public EmailNotificationEvent domain(String domain) {
        this.domain = domain;
        return this;
    }

    public EmailNotificationEvent from(String from) {
        this.from = from;
        return this;
    }

    public List<EmailAttachment> getAttachments() {
        return attachments;
    }

    public String getBody() {
        return body;
    }

    public String getDomain() {
        return domain;
    }

    public String getFrom() {
        return from;
    }

    public Set<String> getRecipients() {
        return recipients;
    }

    public Set<String> getCarbonCopyRecipients() {
        return carbonCopyRecipients;
    }

    public Set<String> getBlindCarbonCopyRecipients() {
        return blindCarbonCopyRecipients;
    }

    public String getSubject() {
        return subject;
    }

    public EmailNotificationEvent recipient(String recipient) {
        if (this.recipients == null) {
            this.recipients = new HashSet<>();
        }
        this.recipients.add(recipient);
        return this;
    }

    public EmailNotificationEvent recipients(Set<String> recipients) {
        this.recipients = recipients;
        return this;
    }

    public EmailNotificationEvent carbonCopyRecipient(String carbonCopyRecipient) {
        if (this.carbonCopyRecipients == null) {
            this.carbonCopyRecipients = new HashSet<>();
        }
        this.recipients.add(carbonCopyRecipient);
        return this;
    }

    public EmailNotificationEvent carbonCopyRecipients(Set<String> carbonCopyRecipients) {
        this.carbonCopyRecipients = carbonCopyRecipients;
        return this;
    }

    public EmailNotificationEvent blindCarbonCopyRecipient(String blindCarbonCopyRecipient) {
        if (this.blindCarbonCopyRecipients == null) {
            this.blindCarbonCopyRecipients = new HashSet<>();
        }
        this.recipients.add(blindCarbonCopyRecipient);
        return this;
    }

    public EmailNotificationEvent blindCarbonCopyRecipients(Set<String> blindCarbonCopyRecipients) {
        this.blindCarbonCopyRecipients = blindCarbonCopyRecipients;
        return this;
    }

    public EmailNotificationEvent subject(String subject) {
        this.subject = subject;
        return this;
    }

}


================================================
File: src/main/java/org/cftoolsuite/cfapp/event/HistoricalRecordRetrievedEvent.java
================================================
package org.cftoolsuite.cfapp.event;

import java.util.List;

import org.cftoolsuite.cfapp.domain.HistoricalRecord;
import org.springframework.context.ApplicationEvent;

public class HistoricalRecordRetrievedEvent extends ApplicationEvent {

    private static final long serialVersionUID = 1L;

    private List<HistoricalRecord> records;

    public HistoricalRecordRetrievedEvent(Object source) {
        super(source);
    }

    public List<HistoricalRecord> getRecords() {
        return records;
    }

    public HistoricalRecordRetrievedEvent records(List<HistoricalRecord> records) {
        this.records = records;
        return this;
    }

}


================================================
File: src/main/java/org/cftoolsuite/cfapp/event/OrganizationsRetrievedEvent.java
================================================
package org.cftoolsuite.cfapp.event;

import java.util.List;

import org.cftoolsuite.cfapp.domain.Organization;
import org.springframework.context.ApplicationEvent;

public class OrganizationsRetrievedEvent extends ApplicationEvent {

    private static final long serialVersionUID = 1L;

    private List<Organization> organizations;

    public OrganizationsRetrievedEvent(Object source) {
        super(source);
    }

    public List<Organization> getOrganizations() {
        return organizations;
    }

    public OrganizationsRetrievedEvent organizations(List<Organization> organizations) {
        this.organizations = organizations;
        return this;
    }

}


================================================
File: src/main/java/org/cftoolsuite/cfapp/event/PoliciesLoadedEvent.java
================================================
package org.cftoolsuite.cfapp.event;

import org.cftoolsuite.cfapp.domain.Policies;
import org.springframework.context.ApplicationEvent;

public class PoliciesLoadedEvent extends ApplicationEvent {

    private static final long serialVersionUID = 1L;

    private Policies policies;

    public PoliciesLoadedEvent(Object source) {
        super(source);
    }

    public Policies getPolicies() {
        return policies;
    }

    public PoliciesLoadedEvent policies(Policies policies) {
        this.policies = policies;
        return this;
    }

}


================================================
File: src/main/java/org/cftoolsuite/cfapp/event/ProductsAndReleasesRetrievedEvent.java
================================================
package org.cftoolsuite.cfapp.event;

import java.util.List;

import org.cftoolsuite.cfapp.domain.product.Products;
import org.cftoolsuite.cfapp.domain.product.Release;
import org.springframework.context.ApplicationEvent;

public class ProductsAndReleasesRetrievedEvent extends ApplicationEvent {

    private static final long serialVersionUID = 1L;

    private Products products;
    private List<Release> allReleases;
    private List<Release> latestReleases;

    public ProductsAndReleasesRetrievedEvent(Object source) {
        super(source);
    }

    public ProductsAndReleasesRetrievedEvent allReleases(List<Release> allReleases) {
        this.allReleases = allReleases;
        return this;
    }

    public List<Release> getAllReleases() {
        return allReleases;
    }

    public List<Release> getLatestReleases() {
        return latestReleases;
    }

    public Products getProducts() {
        return products;
    }

    public ProductsAndReleasesRetrievedEvent latestReleases(List<Release> latestReleases) {
        this.latestReleases = latestReleases;
        return this;
    }

    public ProductsAndReleasesRetrievedEvent products(Products products) {
        this.products = products;
        return this;
    }

}


================================================
File: src/main/java/org/cftoolsuite/cfapp/event/ServiceInstanceDetailRetrievedEvent.java
================================================
package org.cftoolsuite.cfapp.event;

import java.util.List;

import org.cftoolsuite.cfapp.domain.ServiceInstanceDetail;
import org.springframework.context.ApplicationEvent;

public class ServiceInstanceDetailRetrievedEvent extends ApplicationEvent {

    private static final long serialVersionUID = 1L;

    private List<ServiceInstanceDetail> detail;

    public ServiceInstanceDetailRetrievedEvent(Object source) {
        super(source);
    }

    public ServiceInstanceDetailRetrievedEvent detail(List<ServiceInstanceDetail> detail) {
        this.detail = detail;
        return this;
    }

    public List<ServiceInstanceDetail> getDetail() {
        return detail;
    }


}


================================================
File: src/main/java/org/cftoolsuite/cfapp/event/SpacesRetrievedEvent.java
================================================
package org.cftoolsuite.cfapp.event;

import java.util.List;

import org.cftoolsuite.cfapp.domain.Space;
import org.springframework.context.ApplicationEvent;

public class SpacesRetrievedEvent extends ApplicationEvent {

    private static final long serialVersionUID = 1L;

    private List<Space> spaces;

    public SpacesRetrievedEvent(Object source) {
        super(source);
    }

    public List<Space> getSpaces() {
        return spaces;
    }

    public SpacesRetrievedEvent spaces(List<Space> spaces) {
        this.spaces = spaces;
        return this;
    }

}


================================================
File: src/main/java/org/cftoolsuite/cfapp/event/StacksRetrievedEvent.java
================================================
package org.cftoolsuite.cfapp.event;

import org.springframework.context.ApplicationEvent;

public class StacksRetrievedEvent extends ApplicationEvent {

    private static final long serialVersionUID = 1L;

    public StacksRetrievedEvent(Object source) {
        super(source);
    }

}


================================================
File: src/main/java/org/cftoolsuite/cfapp/event/TkRetrievedEvent.java
================================================
package org.cftoolsuite.cfapp.event;

import java.time.LocalDateTime;

import org.springframework.context.ApplicationEvent;

public class TkRetrievedEvent extends ApplicationEvent {

    private static final long serialVersionUID = 1L;

    private LocalDateTime lastCollected;

    public TkRetrievedEvent(Object source) {
        super(source);
    }

    public LocalDateTime getLastCollected() {
        return lastCollected;
    }

    public TkRetrievedEvent lastCollected(LocalDateTime lastCollected) {
        this.lastCollected = lastCollected;
        return this;
    }

}


================================================
File: src/main/java/org/cftoolsuite/cfapp/event/UserAccountsRetrievedEvent.java
================================================
package org.cftoolsuite.cfapp.event;

import java.util.List;

import org.cftoolsuite.cfapp.domain.UserAccounts;
import org.springframework.context.ApplicationEvent;

public class UserAccountsRetrievedEvent extends ApplicationEvent {

    private static final long serialVersionUID = 1L;

    private List<UserAccounts> detail;

    public UserAccountsRetrievedEvent(Object source) {
        super(source);
    }

    public UserAccountsRetrievedEvent detail(List<UserAccounts> detail) {
        this.detail = detail;
        return this;
    }

    public List<UserAccounts> getDetail() {
        return detail;
    }

}


================================================
File: src/main/java/org/cftoolsuite/cfapp/notifier/AppDetailConsoleNotifier.java
================================================
package org.cftoolsuite.cfapp.notifier;

import org.cftoolsuite.cfapp.config.PasSettings;
import org.cftoolsuite.cfapp.event.AppDetailRetrievedEvent;
import org.cftoolsuite.cfapp.report.AppDetailCsvReport;
import org.cftoolsuite.cfapp.service.TimeKeeperService;
import org.cftoolsuite.cfapp.service.TkServiceUtil;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.ApplicationListener;
import org.springframework.stereotype.Component;

import lombok.extern.slf4j.Slf4j;

@Slf4j
@Component
public class AppDetailConsoleNotifier implements ApplicationListener<AppDetailRetrievedEvent> {

    private final AppDetailCsvReport report;
    private final TkServiceUtil util;

    @Autowired
    public AppDetailConsoleNotifier(
            PasSettings appSettings,
            TimeKeeperService tkService) {
        this.report = new AppDetailCsvReport(appSettings);
        this.util = new TkServiceUtil(tkService);
    }

    @Override
    public void onApplicationEvent(AppDetailRetrievedEvent event) {
        util
        .getTimeCollected()
        .subscribe(tc -> log.trace(String.join("%n%n", report.generatePreamble(tc), report.generateDetail(event))));

    }

}


================================================
File: src/main/java/org/cftoolsuite/cfapp/notifier/AppRelationshipConsoleNotifier.java
================================================
package org.cftoolsuite.cfapp.notifier;

import org.cftoolsuite.cfapp.config.PasSettings;
import org.cftoolsuite.cfapp.event.AppRelationshipRetrievedEvent;
import org.cftoolsuite.cfapp.report.AppRelationshipCsvReport;
import org.cftoolsuite.cfapp.service.TimeKeeperService;
import org.cftoolsuite.cfapp.service.TkServiceUtil;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.ApplicationListener;
import org.springframework.stereotype.Component;

import lombok.extern.slf4j.Slf4j;

@Slf4j
@Component
public class AppRelationshipConsoleNotifier implements ApplicationListener<AppRelationshipRetrievedEvent> {

    private final AppRelationshipCsvReport report;
    private final TkServiceUtil util;

    @Autowired
    public AppRelationshipConsoleNotifier(
            PasSettings appSettings,
            TimeKeeperService tkService) {
        this.report = new AppRelationshipCsvReport(appSettings);
        this.util = new TkServiceUtil(tkService);
    }

    @Override
    public void onApplicationEvent(AppRelationshipRetrievedEvent event) {
        util
        .getTimeCollected()
        .subscribe(tc -> log.trace(String.join("%n%n", report.generatePreamble(tc), report.generateDetail(event))));
    }

}


================================================
File: src/main/java/org/cftoolsuite/cfapp/notifier/EmailNotifier.java
================================================
package org.cftoolsuite.cfapp.notifier;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;

import org.apache.commons.lang3.StringUtils;
import org.cftoolsuite.cfapp.domain.EmailAttachment;
import org.cftoolsuite.cfapp.event.EmailNotificationEvent;
import org.springframework.context.ApplicationListener;
import org.springframework.core.io.ClassPathResource;

import lombok.extern.slf4j.Slf4j;

@Slf4j
public abstract class EmailNotifier implements ApplicationListener<EmailNotificationEvent> {

    private String customTemplatePath;
    private String template;

    public EmailNotifier(String customTemplatePath) {
        this.customTemplatePath = customTemplatePath;
        this.template = getEmailTemplate();
    }

    protected String buildBody(String template, String body, String subject, String footer) {
        String result = "";
        if (StringUtils.isNotBlank(template) && isEmailTemplate(template)) {
            result = template.replace("{{header}}", subject).replace("{{body}}", body).replace("{{footer}}", footer);
        } else {
            result = String.format("%s<br/><br/>%s", body, footer);
        }
        return result;
    }

    private String getEmailTemplate() {
        String result = null;
        try {
            InputStream resource;
            if (StringUtils.isNotBlank(customTemplatePath)) {
                resource = new ClassPathResource(customTemplatePath).getInputStream();
            } else {
                resource = new ClassPathResource("email-template.html").getInputStream();
            }
            try (BufferedReader reader = new BufferedReader(new InputStreamReader(resource))) {
                result = reader.lines().collect(Collectors.joining("\n"));
            }
        } catch (IOException ioe) {
            log.warn("Problem reading email template. {}", ioe.getMessage());
        }
        return result;
    }

    protected boolean isEmailTemplate(String template) {
        boolean result = false;
        if (template.contains("{{header}}") && template.contains("{{body}}") && template.contains("{{footer}}")) {
            result = true;
        }
        return result;
    }

    @Override
    public void onApplicationEvent(EmailNotificationEvent event) {
        Set<String> recipients = event.getRecipients();
        String[] cc = convertSetToArray(event.getCarbonCopyRecipients());
        String[] bcc = convertSetToArray(event.getBlindCarbonCopyRecipients());
        String from = event.getFrom();
        String footer =
            String.format("This email was sent from %s on %s",
                    event.getDomain(), DateTimeFormatter.ISO_DATE_TIME.format(LocalDateTime.now()));
        String subject = String.format("%s (from %s)", event.getSubject(), event.getDomain());
        final String body = buildBody(template, event.getBody(), subject, footer);
        log.trace("About to send email using ||> From: {}, To: {}, Cc: {}, Bcc: {}, Subject: {}, Body: {}", from, recipients.toString(), String.join(", ", cc), String.join(", ", bcc), subject, body);
        List<EmailAttachment> prunedAttachments = new ArrayList<EmailAttachment>();;
        if (event.getAttachments() != null){
            prunedAttachments = event.getAttachments().stream().filter(EmailAttachment::hasContent).collect(Collectors.toList());
        }
        List<EmailAttachment> attachments = prunedAttachments;
        String[] toRecipients = recipients.toArray(new String[0]);
        sendMail(from, toRecipients, cc, bcc, subject, body, attachments);
    }

    private String[] convertSetToArray(Set<String> set) {
        return (set != null && !set.isEmpty()) ? set.toArray(new String[set.size()]) : new String[0];
    }

    public abstract void sendMail(String from, String[] to, String[] cc, String[] bcc, String subject, String body, List<EmailAttachment> attachments);

}


================================================
File: src/main/java/org/cftoolsuite/cfapp/notifier/JavaMailNotifier.java
================================================
package org.cftoolsuite.cfapp.notifier;

import java.io.IOException;
import java.util.List;

import org.cftoolsuite.cfapp.domain.EmailAttachment;
import org.springframework.mail.MailException;
import org.springframework.mail.javamail.JavaMailSender;
import org.springframework.mail.javamail.MimeMessageHelper;

import jakarta.activation.DataSource;
import jakarta.mail.MessagingException;
import jakarta.mail.internet.MimeMessage;
import jakarta.mail.util.ByteArrayDataSource;
import lombok.extern.slf4j.Slf4j;

@Slf4j
public class JavaMailNotifier extends EmailNotifier {

    private static void addAttachment(MimeMessageHelper helper, EmailAttachment ea) {
        try {
            DataSource ds = new ByteArrayDataSource(ea.getHeadedContent(), ea.getMimeType());
            helper.addAttachment(ea.getFilename() + ea.getExtension(), ds);
        } catch (MessagingException | IOException e) {
            log.warn("Could not add attachment to email!", e);
        }
    }

    private final JavaMailSender javaMailSender;

    public JavaMailNotifier(String customTemplatePath, JavaMailSender javaMailSender) {
        super(customTemplatePath);
        this.javaMailSender = javaMailSender;
    }

    @Override
    public void sendMail(String from, String[] to, String[] cc, String[] bcc, String subject, String body, List<EmailAttachment> attachments) {
        try {
            MimeMessage message = javaMailSender.createMimeMessage();
            MimeMessageHelper helper = new MimeMessageHelper(message, true);
            helper.setFrom(from);
            helper.setSubject(subject);
            if (to != null && to.length > 0) { helper.setTo(to); }
            if (cc != null && cc.length > 0) { helper.setCc(cc); }
            if (bcc != null && bcc.length > 0) { helper.setBcc(bcc); }
            helper.setText(body, true);
            attachments.forEach(ea -> addAttachment(helper, ea));
            javaMailSender.send(message);
            log.info("Email sent to: {} with subject: {}", String.join(", ", to), subject);
            if (cc != null && cc.length > 0) { log.info("Also sent to cc: {}", String.join(", ", cc)); }
            if (bcc != null && bcc.length > 0) { log.info("Also sent to bcc: {}", String.join(", ", bcc)); }
        } catch (MailException | MessagingException me) {
            log.warn("Could not send email!", me);
        }
    }
}


================================================
File: src/main/java/org/cftoolsuite/cfapp/notifier/ProductsAndReleasesConsoleNotifier.java
================================================
package org.cftoolsuite.cfapp.notifier;

import org.cftoolsuite.cfapp.event.ProductsAndReleasesRetrievedEvent;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.ApplicationListener;
import org.springframework.stereotype.Component;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;

import lombok.extern.slf4j.Slf4j;

@Slf4j
@Component
public class ProductsAndReleasesConsoleNotifier implements ApplicationListener<ProductsAndReleasesRetrievedEvent> {

    private final ObjectMapper mapper;

    @Autowired
    public ProductsAndReleasesConsoleNotifier(ObjectMapper mapper) {
        this.mapper = mapper;
    }

    @Override
    public void onApplicationEvent(ProductsAndReleasesRetrievedEvent event) {
        try {
            log.trace(mapper.writerWithDefaultPrettyPrinter().writeValueAsString(event.getProducts()));
            log.trace(mapper.writerWithDefaultPrettyPrinter().writeValueAsString(event.getAllReleases()));
            log.trace(mapper.writerWithDefaultPrettyPrinter().writeValueAsString(event.getLatestReleases()));
        } catch (JsonProcessingException jpe) {
            log.error("Could not list products from Pivotal Network.", jpe);
        }
    }


}


================================================
File: src/main/java/org/cftoolsuite/cfapp/notifier/SendGridNotifier.java
================================================
package org.cftoolsuite.cfapp.notifier;

import java.io.IOException;
import java.util.Arrays;
import java.util.Base64;
import java.util.List;
import java.util.UUID;

import org.cftoolsuite.cfapp.domain.EmailAttachment;
import org.springframework.http.HttpStatus;

import com.sendgrid.Method;
import com.sendgrid.Request;
import com.sendgrid.Response;
import com.sendgrid.SendGrid;
import com.sendgrid.helpers.mail.Mail;
import com.sendgrid.helpers.mail.objects.Attachments;
import com.sendgrid.helpers.mail.objects.Content;
import com.sendgrid.helpers.mail.objects.Email;
import com.sendgrid.helpers.mail.objects.Personalization;

import lombok.extern.slf4j.Slf4j;

@Slf4j
public class SendGridNotifier extends EmailNotifier {

    private static void addAttachments(Mail mail, List<EmailAttachment> attachments) {
        attachments.forEach(ea -> {
            Attachments payload = new Attachments();
            String content = new String(Base64.getEncoder().encode(ea.getHeadedContent().getBytes()));
            log.trace("Content of attachment {}", content);
            payload.setContent(content);
            payload.setType(ea.getMimeType());
            payload.setFilename(ea.getFilename() + ea.getExtension());
            payload.setDisposition("attachment");
            payload.setContentId(UUID.randomUUID().toString());
            mail.addAttachments(payload);
        });
    }

    private SendGrid sendGrid;

    public SendGridNotifier(String customTemplatePath, SendGrid sendGrid) {
        super(customTemplatePath);
        this.sendGrid = sendGrid;
    }

    @Override
    public void sendMail(String originator, String[] recipients, String[] carbonCopyRecipients, String[] blindCarbonCopyRecipients, String subject, String body, List<EmailAttachment> attachments) {
        try {
            Email from = new Email(originator);
            Content content = new Content("text/html", body);
            //Mail mail = new Mail(from, subject, to, content);
            Mail mail = new Mail();
            Personalization personalization = new Personalization();
            personalization.setFrom(from);
            if (recipients != null && recipients.length > 0) { Arrays.asList(recipients).forEach(to -> personalization.addCc(new Email(to))); }
            personalization.setSubject(subject);
            if (carbonCopyRecipients != null && carbonCopyRecipients.length > 0) { Arrays.asList(carbonCopyRecipients).forEach(cc -> personalization.addCc(new Email(cc))); }
            if (blindCarbonCopyRecipients != null && blindCarbonCopyRecipients.length > 0) { Arrays.asList(blindCarbonCopyRecipients).forEach(bcc -> personalization.addBcc(new Email(bcc))); }
            mail.addContent(content);
            mail.addPersonalization(personalization);
            addAttachments(mail, attachments);
            Request request = new Request();
            request.setMethod(Method.POST);
            request.setEndpoint("mail/send");
            request.setBody(mail.build());
            Response response = sendGrid.api(request);
            log.info("Email sent to {} with subject: {}", recipients, subject);
            if (carbonCopyRecipients != null && carbonCopyRecipients.length > 0) { log.info("Also sent to cc: {}", String.join(", ", carbonCopyRecipients)); }
            if (blindCarbonCopyRecipients != null && blindCarbonCopyRecipients.length > 0) { log.info("Also sent to bcc: {}", String.join(", ", blindCarbonCopyRecipients)); }
            log.trace(String.format("\n\tStatus: %s\n\t%s", HttpStatus.valueOf(response.getStatusCode()).getReasonPhrase(), response.getBody()));
        } catch (IOException ioe) {
            log.warn("Could not send email!", ioe);
        }
    }
}


================================================
File: src/main/java/org/cftoolsuite/cfapp/notifier/ServiceInstanceDetailConsoleNotifier.java
================================================
package org.cftoolsuite.cfapp.notifier;

import org.cftoolsuite.cfapp.config.PasSettings;
import org.cftoolsuite.cfapp.event.ServiceInstanceDetailRetrievedEvent;
import org.cftoolsuite.cfapp.report.ServiceInstanceDetailCsvReport;
import org.cftoolsuite.cfapp.service.TimeKeeperService;
import org.cftoolsuite.cfapp.service.TkServiceUtil;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.ApplicationListener;
import org.springframework.stereotype.Component;

import lombok.extern.slf4j.Slf4j;

@Slf4j
@Component
public class ServiceInstanceDetailConsoleNotifier implements ApplicationListener<ServiceInstanceDetailRetrievedEvent> {

    private final ServiceInstanceDetailCsvReport report;
    private final TkServiceUtil util;

    @Autowired
    public ServiceInstanceDetailConsoleNotifier(
            PasSettings appSettings,
            TimeKeeperService tkService) {
        this.report = new ServiceInstanceDetailCsvReport(appSettings);
        this.util = new TkServiceUtil(tkService);
    }

    @Override
    public void onApplicationEvent(ServiceInstanceDetailRetrievedEvent event) {
        util
        .getTimeCollected()
        .subscribe(tc -> log.trace(String.join("%n%n", report.generatePreamble(tc), report.generateDetail(event))));
    }

}


================================================
File: src/main/java/org/cftoolsuite/cfapp/report/AppDetailCsvReport.java
================================================
package org.cftoolsuite.cfapp.report;

import java.time.LocalDateTime;

import org.cftoolsuite.cfapp.config.PasSettings;
import org.cftoolsuite.cfapp.domain.AppDetail;
import org.cftoolsuite.cfapp.event.AppDetailRetrievedEvent;

public class AppDetailCsvReport  {

    private PasSettings appSettings;

    public AppDetailCsvReport(PasSettings appSettings) {
        this.appSettings = appSettings;
    }

    public String generateDetail(AppDetailRetrievedEvent event) {
        StringBuffer details = new StringBuffer();
        details.append("\n");
        details.append(AppDetail.headers());
        details.append("\n");
        event.getDetail()
        .forEach(a -> {
            details.append(a.toCsv());
            details.append("\n");
        });
        return details.toString();
    }

    public String generatePreamble(LocalDateTime collectionTime) {
        StringBuffer preamble = new StringBuffer();
        preamble.append("Application inventory detail from ");
        preamble.append(appSettings.getApiHost());
        if (collectionTime != null) {
            preamble.append(" collected ");
            preamble.append(collectionTime);
            preamble.append(" and");
        }
        preamble.append(" generated ");
        preamble.append(LocalDateTime.now());
        preamble.append(".");
        return preamble.toString();
    }

}


================================================
File: src/main/java/org/cftoolsuite/cfapp/report/AppRelationshipCsvReport.java
================================================
package org.cftoolsuite.cfapp.report;

import java.time.LocalDateTime;

import org.cftoolsuite.cfapp.config.PasSettings;
import org.cftoolsuite.cfapp.domain.AppRelationship;
import org.cftoolsuite.cfapp.event.AppRelationshipRetrievedEvent;

public class AppRelationshipCsvReport  {

    private PasSettings appSettings;

    public AppRelationshipCsvReport(PasSettings appSettings) {
        this.appSettings = appSettings;
    }

    public String generateDetail(AppRelationshipRetrievedEvent event) {
        StringBuffer details = new StringBuffer();
        details.append("\n");
        details.append(AppRelationship.headers());
        details.append("\n");
        event.getRelations()
        .forEach(a -> {
            details.append(a.toCsv());
            details.append("\n");
        });
        return details.toString();
    }

    public String generatePreamble(LocalDateTime collectionTime) {
        StringBuffer preamble = new StringBuffer();
        preamble.append("Application relationships from ");
        preamble.append(appSettings.getApiHost());
        if (collectionTime != null) {
            preamble.append(" collected ");
            preamble.append(collectionTime);
            preamble.append(" and");
        }
        preamble.append(" generated ");
        preamble.append(LocalDateTime.now());
        preamble.append(".");
        return preamble.toString();
    }

}


================================================
File: src/main/java/org/cftoolsuite/cfapp/report/HistoricalRecordCsvReport.java
================================================
package org.cftoolsuite.cfapp.report;

import java.time.LocalDateTime;

import org.cftoolsuite.cfapp.config.PasSettings;
import org.cftoolsuite.cfapp.domain.HistoricalRecord;
import org.cftoolsuite.cfapp.event.HistoricalRecordRetrievedEvent;

public class HistoricalRecordCsvReport {

    private PasSettings settings;

    public HistoricalRecordCsvReport(PasSettings settings) {
        this.settings = settings;
    }

    public String generateDetail(HistoricalRecordRetrievedEvent event) {
        StringBuffer detail = new StringBuffer();
        detail.append("\n");
        detail.append(HistoricalRecord.headers());
        detail.append("\n");
        event.getRecords()
        .forEach(a -> {
            detail.append(a.toCsv());
            detail.append("\n");
        });
        return detail.toString();
    }

    public String generatePreamble() {
        StringBuffer preamble = new StringBuffer();
        preamble.append("Historical records from ");
        preamble.append(settings.getApiHost());
        preamble.append(" generated ");
        preamble.append(LocalDateTime.now());
        preamble.append(".");
        return preamble.toString();
    }

}


================================================
File: src/main/java/org/cftoolsuite/cfapp/report/ServiceInstanceDetailCsvReport.java
================================================
package org.cftoolsuite.cfapp.report;

import java.time.LocalDateTime;

import org.cftoolsuite.cfapp.config.PasSettings;
import org.cftoolsuite.cfapp.domain.ServiceInstanceDetail;
import org.cftoolsuite.cfapp.event.ServiceInstanceDetailRetrievedEvent;

public class ServiceInstanceDetailCsvReport {

    private PasSettings settings;

    public ServiceInstanceDetailCsvReport(PasSettings settings) {
        this.settings = settings;
    }

    public String generateDetail(ServiceInstanceDetailRetrievedEvent event) {
        StringBuffer detail = new StringBuffer();
        detail.append("\n");
        detail.append(ServiceInstanceDetail.headers());
        detail.append("\n");
        event.getDetail()
        .forEach(a -> {
            detail.append(a.toCsv());
            detail.append("\n");
        });
        return detail.toString();
    }

    public String generatePreamble(LocalDateTime collectionTime) {
        StringBuffer preamble = new StringBuffer();
        preamble.append("Service inventory detail from ");
        preamble.append(settings.getApiHost());
        if (collectionTime != null) {
            preamble.append(" collected ");
            preamble.append(collectionTime);
            preamble.append(" and");
        }
        preamble.append(" generated ");
        preamble.append(LocalDateTime.now());
        preamble.append(".");
        return preamble.toString();
    }

}


================================================
File: src/main/java/org/cftoolsuite/cfapp/report/UserAccountsCsvReport.java
================================================
package org.cftoolsuite.cfapp.report;

import java.time.LocalDateTime;

import org.cftoolsuite.cfapp.config.PasSettings;
import org.cftoolsuite.cfapp.domain.UserAccounts;
import org.cftoolsuite.cfapp.event.UserAccountsRetrievedEvent;

public class UserAccountsCsvReport  {

    private PasSettings appSettings;

    public UserAccountsCsvReport(PasSettings appSettings) {
        this.appSettings = appSettings;
    }

    public String generateDetail(UserAccountsRetrievedEvent event) {
        StringBuffer details = new StringBuffer();
        details.append("\n");
        details.append(UserAccounts.headers());
        details.append("\n");
        event.getDetail()
        .forEach(a -> {
            details.append(a.toCsv());
            details.append("\n");
        });
        return details.toString();
    }

    public String generatePreamble(LocalDateTime collectionTime) {
        StringBuffer preamble = new StringBuffer();
        preamble.append("User accounts from ");
        preamble.append(appSettings.getApiHost());
        if (collectionTime != null) {
            preamble.append(" collected ");
            preamble.append(collectionTime);
            preamble.append(" and");
        }
        preamble.append(" generated ");
        preamble.append(LocalDateTime.now());
        preamble.append(".");
        return preamble.toString();
    }

}


================================================
File: src/main/java/org/cftoolsuite/cfapp/repository/PolicyIdProvider.java
================================================
package org.cftoolsuite.cfapp.repository;

import org.cftoolsuite.cfapp.client.GitClient;
import org.cftoolsuite.cfapp.config.GitSettings;
import org.cftoolsuite.cfapp.domain.ApplicationPolicy;
import org.cftoolsuite.cfapp.domain.EndpointPolicy;
import org.cftoolsuite.cfapp.domain.HygienePolicy;
import org.cftoolsuite.cfapp.domain.LegacyPolicy;
import org.cftoolsuite.cfapp.domain.QueryPolicy;
import org.cftoolsuite.cfapp.domain.ResourceNotificationPolicy;
import org.cftoolsuite.cfapp.domain.ServiceInstancePolicy;
import org.eclipse.jgit.lib.Repository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

@Component
public class PolicyIdProvider {

    private final GitSettings settings;
    private final String commit;

    public PolicyIdProvider(
            GitSettings settings,
            @Autowired(required = false) GitClient client
            ) {
        this.settings = settings;
        if (client != null && settings.isVersionManaged()) {
            Repository repo = client.getRepository(settings);
            this.commit =
                    settings.isPinnedCommit()
                    ? settings.getCommit()
                            : client.orLatestCommit(settings.getCommit(), repo);
        } else {
            this.commit = settings.getCommit();
        }
    }

    public ApplicationPolicy seedApplicationPolicy(ApplicationPolicy policy) {
        return settings.isVersionManaged() ? ApplicationPolicy.seedWith(policy, commit): ApplicationPolicy.seed(policy);
    }

    public EndpointPolicy seedEndpointPolicy(EndpointPolicy policy) {
        return settings.isVersionManaged() ? EndpointPolicy.seedWith(policy, commit): EndpointPolicy.seed(policy);
    }

    public HygienePolicy seedHygienePolicy(HygienePolicy policy) {
        return settings.isVersionManaged() ? HygienePolicy.seedWith(policy, commit): HygienePolicy.seed(policy);
    }

    public ResourceNotificationPolicy seedResourceNotificationPolicy(ResourceNotificationPolicy policy) {
        return settings.isVersionManaged() ? ResourceNotificationPolicy.seedWith(policy, commit): ResourceNotificationPolicy.seed(policy);
    }

    public LegacyPolicy seedLegacyPolicy(LegacyPolicy policy) {
        return settings.isVersionManaged() ? LegacyPolicy.seedWith(policy, commit): LegacyPolicy.seed(policy);
    }

    public QueryPolicy seedQueryPolicy(QueryPolicy policy) {
        return settings.isVersionManaged() ? QueryPolicy.seedWith(policy, commit): QueryPolicy.seed(policy);
    }

    public ServiceInstancePolicy seedServiceInstancePolicy(ServiceInstancePolicy policy) {
        return settings.isVersionManaged() ? ServiceInstancePolicy.seedWith(policy, commit): ServiceInstancePolicy.seed(policy);
    }

}


================================================
File: src/main/java/org/cftoolsuite/cfapp/repository/R2dbcAppDetailRepository.java
================================================
package org.cftoolsuite.cfapp.repository;

import java.time.Duration;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.LocalTime;

import org.cftoolsuite.cfapp.domain.AppDetail;
import org.cftoolsuite.cfapp.domain.ApplicationPolicy;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.Sort;
import org.springframework.data.domain.Sort.Order;
import org.springframework.data.r2dbc.core.R2dbcEntityOperations;
import org.springframework.data.relational.core.query.Criteria;
import org.springframework.data.relational.core.query.Query;
import org.springframework.stereotype.Repository;

import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;
import reactor.util.function.Tuple2;
import reactor.util.function.Tuples;

@Repository
public class R2dbcAppDetailRepository {

    private final R2dbcEntityOperations client;

    @Autowired
    public R2dbcAppDetailRepository(R2dbcEntityOperations client) {
        this.client = client;
    }

    public Mono<Void> deleteAll() {
        return
            client
                .delete(AppDetail.class)
                .all()
                .then();
    }

    public Flux<AppDetail> findAll() {
        Sort order = Sort.by(Order.asc("organization"), Order.asc("space"), Order.asc("app_name"));
        return
            client
                .select(AppDetail.class)
                .matching(Query.empty().sort(order))
                .all();
    }

    private Flux<Tuple2<AppDetail, ApplicationPolicy>> findApplicationsThatDoNotHaveServiceBindings(ApplicationPolicy policy) {
        LocalDateTime fromDateTime = policy.getOption("from-datetime", LocalDateTime.class);
        String fromDuration = policy.getOption("from-duration", String.class);
        LocalDateTime temporal = null;
        Criteria criteria = null;
        if (fromDateTime != null) {
            temporal = fromDateTime;
        }
        if (fromDuration != null) {
            temporal = LocalDateTime.now().minus(Duration.parse(fromDuration));
        }
        if (temporal != null) {
            criteria = Criteria.where("requested_state").is(policy.getState()).and("service_instance_id").isNull().and("last_event_time").lessThanOrEquals(temporal);
        } else {
            criteria = Criteria.where("requested_state").is(policy.getState()).and("service_instance_id").isNull();
        }
        return
            client
                .select(AppDetail.class)
                .from("service_bindings")
                .matching(Query.query(criteria).sort(Sort.by(Order.asc("organization"), Order.asc("space"), Order.asc("app_name"))))
                .all()
                .map(r -> toTuple(r, policy));
    }

    private Flux<Tuple2<AppDetail, ApplicationPolicy>> findApplicationsThatMayHaveServiceBindings(ApplicationPolicy policy) {
        LocalDateTime fromDateTime = policy.getOption("from-datetime", LocalDateTime.class);
        String fromDuration = policy.getOption("from-duration", String.class);
        LocalDateTime temporal = null;
        Criteria criteria = null;
        if (fromDateTime != null) {
            temporal = fromDateTime;
        }
        if (fromDuration != null) {
            temporal = LocalDateTime.now().minus(Duration.parse(fromDuration));
        }
        if (temporal != null) {
            criteria = Criteria.where("requested_state").is(policy.getState()).and("last_event_time").lessThanOrEquals(temporal);
        } else {
            criteria = Criteria.where("requested_state").is(policy.getState());
        }
        return
            client
                .select(AppDetail.class)
                .matching(Query.query(criteria).sort(Sort.by(Order.asc("organization"), Order.asc("space"), Order.asc("app_name"))))
                .all()
                .map(r -> toTuple(r, policy));
    }

    public Mono<AppDetail> findByAppId(String appId) {
        Criteria criteria =
                Criteria
                .where("app_id").is(appId);
        return
            client
                .select(AppDetail.class)
                .matching(Query.query(criteria))
                .one();
    }

    public Flux<Tuple2<AppDetail, ApplicationPolicy>> findByApplicationPolicy(ApplicationPolicy policy, boolean mayHaveServiceBindings) {
        return mayHaveServiceBindings == true
                ? findApplicationsThatMayHaveServiceBindings(policy)
                        : findApplicationsThatDoNotHaveServiceBindings(policy);
    }

    public Flux<AppDetail> findByDateRange(LocalDate start, LocalDate end) {
        Criteria criteria =
                Criteria
                .where("last_pushed")
                .lessThanOrEquals(LocalDateTime.of(end, LocalTime.MAX))
                .and("last_pushed")
                .greaterThan(LocalDateTime.of(start, LocalTime.MIDNIGHT));
        Sort order = Sort.by(Order.desc("last_pushed"));
        return
            client
                .select(AppDetail.class)
                .matching(Query.query(criteria).sort(order))
                .all();
    }

    public Mono<AppDetail> save(AppDetail entity) {
        return
            client
                .insert(entity);
    }

    private Tuple2<AppDetail, ApplicationPolicy> toTuple(AppDetail detail, ApplicationPolicy policy) {
        return Tuples.of(detail, policy);
    }

}


================================================
File: src/main/java/org/cftoolsuite/cfapp/repository/R2dbcAppMetricsRepository.java
================================================
package org.cftoolsuite.cfapp.repository;

import java.math.BigDecimal;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.LocalTime;

import org.cftoolsuite.cfapp.config.DbmsSettings;
import org.cftoolsuite.cfapp.domain.AppDetail;
import org.cftoolsuite.cfapp.domain.Defaults;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.r2dbc.core.R2dbcEntityOperations;
import org.springframework.data.relational.core.query.Criteria;
import org.springframework.data.relational.core.query.Query;
import org.springframework.stereotype.Repository;

import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;
import reactor.util.function.Tuple2;
import reactor.util.function.Tuples;

@Repository
public class R2dbcAppMetricsRepository {

    private final R2dbcEntityOperations client;
    private final DbmsSettings settings;

    @Autowired
    public R2dbcAppMetricsRepository(
            R2dbcEntityOperations client,
            DbmsSettings settings) {
        this.client = client;
        this.settings = settings;
    }

    protected Flux<Tuple2<String, Long>> by(String columnName) {
        String sql = "select " + columnName + ", count(" + columnName + ") as cnt from application_detail group by " + columnName;
        return
                client
                .getDatabaseClient()
                .sql(sql)
                .map((row, metadata)
                        -> Tuples.of(Defaults.getColumnValueOrDefault(row, columnName, String.class, "--"), Defaults.getColumnValueOrDefault(row, "cnt", Long.class, 0L)))
                .all()
                .defaultIfEmpty(Tuples.of("--", 0L));
    }

    public Flux<Tuple2<String, Long>> byBuildpack() {
        String sql = "select buildpack, count(buildpack) as cnt from application_detail where image is null and buildpack is not null group by buildpack";
        return
                client
                .getDatabaseClient()
                .sql(sql)
                .map((row, metadata)
                        -> Tuples.of(Defaults.getColumnValueOrDefault(row, "buildpack", String.class, "--"), Defaults.getColumnValueOrDefault(row, "cnt", Long.class, 0L)))
                .all()
                .defaultIfEmpty(Tuples.of("--", 0L));
    }

    public Flux<Tuple2<String, Long>> byDockerImage() {
        String sql = "select image, count(image) as cnt from application_detail where image is not null group by image";
        return
                client
                .getDatabaseClient()
                .sql(sql)
                .map((row, metadata)
                        -> Tuples.of(Defaults.getColumnValueOrDefault(row, "image", String.class, "--"), Defaults.getColumnValueOrDefault(row, "cnt", Long.class, 0L)))
                .all()
                .defaultIfEmpty(Tuples.of("--", 0L));
    }

    public Flux<Tuple2<String, Long>> byOrganization() {
        return by("organization");
    }

    public Flux<Tuple2<String, Long>> byStack() {
        return by("stack");
    }

    public Flux<Tuple2<String, Long>> byStatus() {
        return by("requested_state");
    }

    protected Mono<Long> countByDateRange(LocalDate start, LocalDate end) {
        Criteria criteria =
                Criteria.where("last_pushed").lessThanOrEquals(LocalDateTime.of(end, LocalTime.MAX)).and("last_pushed").greaterThan(LocalDateTime.of(start, LocalTime.MIDNIGHT));
        return
                client
                .select(AppDetail.class)
                .matching(Query.query(criteria))
                .all()
                .count()
                .defaultIfEmpty(0L);
    }

    protected Mono<Long> countStagnant(LocalDate end) {
        Criteria criteria =
                Criteria.where("last_pushed").lessThan(LocalDateTime.of(end, LocalTime.MIDNIGHT));
        return
                client
                .select(AppDetail.class)
                .matching(Query.query(criteria))
                .all()
                .count()
                .defaultIfEmpty(0L);
    }

    private Double toGigabytes(BigDecimal input) {
        return Double.valueOf(input.doubleValue() / Math.pow(1024, 3));
    }

    public Mono<Long> totalApplicationInstances() {
        String sql = "select sum(total_instances) as cnt from application_detail";
        if (settings.getProvider().equals("MySQL")) {
            sql = "select cast(sum(total_instances) as signed) as cnt from application_detail";
        }
        return
                client
                .getDatabaseClient()
                .sql(sql)
                .map((row, metadata) -> Defaults.getColumnValueOrDefault(row, "cnt", Long.class, 0L))
                .one()
                .defaultIfEmpty(0L);
    }

    public Mono<Long> totalApplications() {
        String sql = "select count(*) as cnt from application_detail";
        return
                client
                .getDatabaseClient()
                .sql(sql)
                .map((row, metadata) -> Defaults.getColumnValueOrDefault(row, "cnt", Long.class, 0L))
                .one()
                .defaultIfEmpty(0L);
    }

    public Mono<Long> totalCrashedApplicationInstances() {
        String sql = "select count(running_instances) as cnt from application_detail where requested_state = 'started' and running_instances = 0";
        return
                client
                .getDatabaseClient()
                .sql(sql)
                .map((row, metadata) -> Defaults.getColumnValueOrDefault(row, "cnt", Long.class, 0L))
                .one()
                .defaultIfEmpty(0L);
    }

    public Mono<Double> totalDiskUsed() {
        String sql = "select sum(disk_used) as tot from application_detail";
        return
                client
                .getDatabaseClient()
                .sql(sql)
                .map((row, metadata) -> Defaults.getColumnValueOrDefault(row, "tot", BigDecimal.class, BigDecimal.valueOf(0L)))
                .one()
                .map(this::toGigabytes)
                .defaultIfEmpty(0.0);
    }

    public Mono<Double> totalMemoryUsed() {
        String sql = "select sum(memory_used) as tot from application_detail";
        return
                client
                .getDatabaseClient()
                .sql(sql)
                .map((row, metadata) -> Defaults.getColumnValueOrDefault(row, "tot", BigDecimal.class, BigDecimal.valueOf(0L)))
                .one()
                .map(this::toGigabytes)
                .defaultIfEmpty(0.0);
    }

    public Mono<Long> totalRunningApplicationInstances() {
        String sql = "select sum(running_instances) as cnt from application_detail where requested_state = 'started'";
        if (settings.getProvider().equals("MySQL")) {
            sql = "select cast(sum(running_instances) as signed) as cnt from application_detail where requested_state = 'started'";
        }
        return
                client
                .getDatabaseClient()
                .sql(sql)
                .map((row, metadata) -> Defaults.getColumnValueOrDefault(row, "cnt", Long.class, 0L))
                .one()
                .defaultIfEmpty(0L);
    }

    public Mono<Long> totalStoppedApplicationInstances() {
        String sql = "select sum(total_instances) as cnt from application_detail where requested_state = 'stopped'";
        if (settings.getProvider().equals("MySQL")) {
            sql = "select cast(sum(total_instances) as signed) as cnt from application_detail where requested_state = 'stopped'";
        }
        return
                client
                .getDatabaseClient()
                .sql(sql)
                .map((row, metadata) -> Defaults.getColumnValueOrDefault(row, "cnt", Long.class, 0L))
                .one()
                .defaultIfEmpty(0L);
    }

    public Flux<Tuple2<String, Long>> totalVelocity() {
        final LocalDate now = LocalDate.now();
        return
                Flux.concat(
                        countByDateRange(now.minusDays(1), now).map(r -> Tuples.of("in-last-day", r)),
                        countByDateRange(now.minusDays(2), now.minusDays(1)).map(r -> Tuples.of("between-one-day-and-two-days", r)),
                        countByDateRange(now.minusWeeks(1), now.minusDays(2)).map(r -> Tuples.of("between-two-days-and-one-week", r)),
                        countByDateRange(now.minusWeeks(2), now.minusWeeks(1)).map(r -> Tuples.of("between-one-week-and-two-weeks", r)),
                        countByDateRange(now.minusMonths(1), now.minusWeeks(2)).map(r -> Tuples.of("between-two-weeks-and-one-month", r)),
                        countByDateRange(now.minusMonths(3), now.minusMonths(1)).map(r -> Tuples.of("between-one-month-and-three-months", r)),
                        countByDateRange(now.minusMonths(6), now.minusMonths(3)).map(r -> Tuples.of("between-three-months-and-six-months", r)),
                        countByDateRange(now.minusYears(1), now.minusMonths(6)).map(r -> Tuples.of("between-six-months-and-one-year", r)),
                        countStagnant(now.minusYears(1)).map(r -> Tuples.of("beyond-one-year", r)));
    }

}


================================================
File: src/main/java/org/cftoolsuite/cfapp/repository/R2dbcAppRelationshipRepository.java
================================================
package org.cftoolsuite.cfapp.repository;

import org.cftoolsuite.cfapp.domain.AppRelationship;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.Sort;
import org.springframework.data.domain.Sort.Order;
import org.springframework.data.r2dbc.core.R2dbcEntityOperations;
import org.springframework.data.relational.core.query.Criteria;
import org.springframework.data.relational.core.query.Query;
import org.springframework.stereotype.Repository;

import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

@Repository
public class R2dbcAppRelationshipRepository {

    private final R2dbcEntityOperations client;

    @Autowired
    public R2dbcAppRelationshipRepository(R2dbcEntityOperations client) {
        this.client = client;
    }

    public Mono<Void> deleteAll() {
        return
                client
                .delete(AppRelationship.class)
                .all()
                .then();
    }

    public Flux<AppRelationship> findAll() {
        return
                client
                .select(AppRelationship.class)
                .matching(Query.empty().sort(Sort.by(Order.asc("organization"), Order.asc("space"), Order.asc("app_name"))))
                .all();
    }

    public Flux<AppRelationship> findByApplicationId(String applicationId) {
        Criteria criteria =
                Criteria.where("app_id").is(applicationId);
        return
                client
                .select(AppRelationship.class)
                .matching(Query.query(criteria).sort(Sort.by(Order.asc("organization"), Order.asc("space"), Order.asc("service_name"))))
                .all();
    }

    public Flux<AppRelationship> findByServiceInstanceId(String serviceInstanceId) {
        Criteria criteria =
                Criteria.where("service_instance_id").is(serviceInstanceId);
        return
                client
                .select(AppRelationship.class)
                .matching(Query.query(criteria).sort(Sort.by(Order.asc("organization"), Order.asc("space"), Order.asc("service_name"))))
                .all();
    }

    public Mono<AppRelationship> save(AppRelationship entity) {
        return
                client
                .insert(entity);
    }

}


================================================
File: src/main/java/org/cftoolsuite/cfapp/repository/R2dbcHistoricalRecordRepository.java
================================================
package org.cftoolsuite.cfapp.repository;

import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.LocalTime;

import org.cftoolsuite.cfapp.domain.HistoricalRecord;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.Sort;
import org.springframework.data.domain.Sort.Order;
import org.springframework.data.r2dbc.core.R2dbcEntityOperations;
import org.springframework.data.relational.core.query.Criteria;
import org.springframework.data.relational.core.query.Query;
import org.springframework.stereotype.Repository;

import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

@Repository
public class R2dbcHistoricalRecordRepository {

    private final R2dbcEntityOperations client;

    @Autowired
    public R2dbcHistoricalRecordRepository(R2dbcEntityOperations client) {
        this.client = client;
    }

    public Flux<HistoricalRecord> findAll() {
        return
                client
                .select(HistoricalRecord.class)
                .matching(Query.empty().sort(Sort.by(Order.desc("transaction_date_time"))))
                .all();
    }

    public Flux<HistoricalRecord> findByDateRange(LocalDate start, LocalDate end) {
        Criteria criteria =
                Criteria.where("transaction_date_time").lessThanOrEquals(LocalDateTime.of(end, LocalTime.MAX)).and("transaction_date_time").greaterThan(LocalDateTime.of(start, LocalTime.MIDNIGHT));
        return
                client
                .select(HistoricalRecord.class)
                .matching(Query.query(criteria).sort(Sort.by(Order.desc("transaction_date_time"))))
                .all();
    }

    public Mono<HistoricalRecord> save(HistoricalRecord entity) {
        return
                client
                .insert(entity);
    }

}


================================================
File: src/main/java/org/cftoolsuite/cfapp/repository/R2dbcJavaAppDetailRepository.java
================================================
package org.cftoolsuite.cfapp.repository;

import org.cftoolsuite.cfapp.domain.JavaAppDetail;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.Sort;
import org.springframework.data.domain.Sort.Order;
import org.springframework.data.r2dbc.core.R2dbcEntityOperations;
import org.springframework.data.relational.core.query.Criteria;
import org.springframework.data.relational.core.query.Query;
import org.springframework.stereotype.Repository;

import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

@Repository
public class R2dbcJavaAppDetailRepository {

    private final R2dbcEntityOperations client;

    @Autowired
    public R2dbcJavaAppDetailRepository(R2dbcEntityOperations client) {
        this.client = client;
    }

    public Mono<Void> deleteAll() {
        return
            client
                .delete(JavaAppDetail.class)
                .all()
                .then();
    }

    public Flux<JavaAppDetail> findAll() {
        Sort order = Sort.by(Order.asc("organization"), Order.asc("space"), Order.asc("app_name"));
        return
            client
                .select(JavaAppDetail.class)
                .matching(Query.empty().sort(order))
                .all();
    }

    public Mono<JavaAppDetail> findByAppId(String appId) {
        Criteria criteria =
                Criteria
                .where("app_id").is(appId);
        return
            client
                .select(JavaAppDetail.class)
                .matching(Query.query(criteria))
                .one();
    }

    public Mono<JavaAppDetail> save(JavaAppDetail entity) {
        return
            client
                .insert(entity);
    }

}


================================================
File: src/main/java/org/cftoolsuite/cfapp/repository/R2dbcOrganizationRepository.java
================================================
package org.cftoolsuite.cfapp.repository;

import org.cftoolsuite.cfapp.domain.Organization;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.Sort;
import org.springframework.data.domain.Sort.Order;
import org.springframework.data.r2dbc.core.R2dbcEntityOperations;
import org.springframework.data.relational.core.query.Query;
import org.springframework.stereotype.Repository;

import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

@Repository
public class R2dbcOrganizationRepository {

    private final R2dbcEntityOperations client;

    @Autowired
    public R2dbcOrganizationRepository(R2dbcEntityOperations client) {
        this.client = client;
    }

    public Mono<Void> deleteAll() {
        return
                client
                .delete(Organization.class)
                .all()
                .then();
    }

    public Flux<Organization> findAll() {
        return
                client
                .select(Organization.class)
                .matching(Query.empty().sort(Sort.by(Order.asc("org_name"))))
                .all();
    }

    public Mono<Organization> save(Organization entity) {
        return
                client
                .insert(entity);
    }

}


================================================
File: src/main/java/org/cftoolsuite/cfapp/repository/R2dbcPoliciesRepository.java
================================================
package org.cftoolsuite.cfapp.repository;

import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;

import org.cftoolsuite.cfapp.domain.ApplicationOperation;
import org.cftoolsuite.cfapp.domain.ApplicationPolicy;
import org.cftoolsuite.cfapp.domain.EndpointPolicy;
import org.cftoolsuite.cfapp.domain.HygienePolicy;
import org.cftoolsuite.cfapp.domain.LegacyPolicy;
import org.cftoolsuite.cfapp.domain.Policies;
import org.cftoolsuite.cfapp.domain.QueryPolicy;
import org.cftoolsuite.cfapp.domain.ResourceNotificationPolicy;
import org.cftoolsuite.cfapp.domain.ServiceInstanceOperation;
import org.cftoolsuite.cfapp.domain.ServiceInstancePolicy;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.r2dbc.core.R2dbcEntityOperations;
import org.springframework.data.relational.core.query.Criteria;
import org.springframework.stereotype.Repository;

import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

@Repository
public class R2dbcPoliciesRepository {

    private final R2dbcEntityOperations dbClient;
    private final PolicyIdProvider idProvider;

    @Autowired
    public R2dbcPoliciesRepository(
            R2dbcEntityOperations dbClient,
            PolicyIdProvider idProvider) {
        this.dbClient = dbClient;
        this.idProvider = idProvider;
    }

    public Mono<Void> deleteAll() {
        return
                dbClient
                .delete(ApplicationPolicy.class).all()
                .then(dbClient.delete(ServiceInstancePolicy.class).all())
                .then(dbClient.delete(EndpointPolicy.class).all())
                .then(dbClient.delete(QueryPolicy.class).all())
                .then(dbClient.delete(HygienePolicy.class).all())
                .then(dbClient.delete(ResourceNotificationPolicy.class).all())
                .then(dbClient.delete(LegacyPolicy.class).all())
                .then();
    }

    public Mono<Void> deleteApplicationPolicyById(String id) {
        return
                dbClient
                .delete(ApplicationPolicy.class)
                .matching(org.springframework.data.relational.core.query.Query.query(Criteria.where("id").is(id)))
                .all()
                .then();
    }

    public Mono<Void> deleteEndpointPolicyById(String id) {
        return
                dbClient
                .delete(EndpointPolicy.class)
                .matching(org.springframework.data.relational.core.query.Query.query(Criteria.where("id").is(id)))
                .all()
                .then();
    }

    public Mono<Void> deleteHygienePolicyById(String id) {
        return
                dbClient
                .delete(HygienePolicy.class)
                .matching(org.springframework.data.relational.core.query.Query.query(Criteria.where("id").is(id)))
                .all()
                .then();
    }

    public Mono<Void> deleteResourceNotificationPolicyById(String id) {
        return
                dbClient
                .delete(ResourceNotificationPolicy.class)
                .matching(org.springframework.data.relational.core.query.Query.query(Criteria.where("id").is(id)))
                .all()
                .then();
    }

    public Mono<Void> deleteLegacyPolicyById(String id) {
        return
                dbClient
                .delete(LegacyPolicy.class)
                .matching(org.springframework.data.relational.core.query.Query.query(Criteria.where("id").is(id)))
                .all()
                .then();
    }

    public Mono<Void> deleteQueryPolicyById(String id) {
        return
                dbClient
                .delete(QueryPolicy.class)
                .matching(org.springframework.data.relational.core.query.Query.query(Criteria.where("id").is(id)))
                .all()
                .then();
    }

    public Mono<Void> deleteServiceInstancePolicyById(String id) {
        return
                dbClient
                .delete(ServiceInstancePolicy.class)
                .matching(org.springframework.data.relational.core.query.Query.query(Criteria.where("id").is(id)))
                .all()
                .then();
    }

    public Mono<Policies> findAll() {
        List<ApplicationPolicy> applicationPolicies = new ArrayList<>();
        List<ServiceInstancePolicy> serviceInstancePolicies = new ArrayList<>();
        List<EndpointPolicy> endpointPolicies = new ArrayList<>();
        List<QueryPolicy> queryPolicies = new ArrayList<>();
        List<HygienePolicy> hygienePolicies = new ArrayList<>();
        List<ResourceNotificationPolicy> resourceNotificationPolicies = new ArrayList<>();
        List<LegacyPolicy> legacyPolicies = new ArrayList<>();
        return
                Flux
                .from(dbClient.select(ApplicationPolicy.class).all())
                .map(ap -> applicationPolicies.add(ap))
                .thenMany(
                        Flux
                        .from(dbClient.select(ServiceInstancePolicy.class).all())
                        .map(sp -> serviceInstancePolicies.add(sp)))
                .thenMany(
                        Flux
                        .from(dbClient.select(EndpointPolicy.class).all())
                        .map(ep -> endpointPolicies.add(ep)))
                .thenMany(
                        Flux
                        .from(dbClient.select(QueryPolicy.class).all())
                        .map(qp -> queryPolicies.add(qp)))
                .thenMany(
                        Flux
                        .from(dbClient.select(HygienePolicy.class).all())
                        .map(hp -> hygienePolicies.add(hp)))
                .thenMany(
                        Flux
                        .from(dbClient.select(ResourceNotificationPolicy.class).all())
                        .map(rnp -> resourceNotificationPolicies.add(rnp)))
                .thenMany(
                        Flux
                        .from(dbClient.select(LegacyPolicy.class).all())
                        .map(lp -> legacyPolicies.add(lp)))
                .then(Mono.just(Policies.builder().applicationPolicies(applicationPolicies).endpointPolicies(endpointPolicies).serviceInstancePolicies(serviceInstancePolicies).queryPolicies(queryPolicies).hygienePolicies(hygienePolicies).resourceNotificationPolicies(resourceNotificationPolicies).legacyPolicies(legacyPolicies).build()))
                .flatMap(p -> p.isEmpty() ? Mono.empty(): Mono.just(p));
    }

    public Mono<Policies> findAllEndpointPolicies() {
        return
                dbClient
                .select(EndpointPolicy.class)
                .all()
                .collectList()
                .map(eps -> Policies.builder().endpointPolicies(eps).build())
                .flatMap(p -> p.isEmpty() ? Mono.empty(): Mono.just(p));
    }

    public Mono<Policies> findAllHygienePolicies() {
        return
                dbClient
                .select(HygienePolicy.class)
                .all()
                .collectList()
                .map(hps -> Policies.builder().hygienePolicies(hps).build())
                .flatMap(p -> p.isEmpty() ? Mono.empty(): Mono.just(p));
    }

    public Mono<Policies> findAllResourceNotificationPolicies() {
        return
                dbClient
                .select(ResourceNotificationPolicy.class)
                .all()
                .collectList()
                .map(rnps -> Policies.builder().resourceNotificationPolicies(rnps).build())
                .flatMap(p -> p.isEmpty() ? Mono.empty(): Mono.just(p));
    }

    public Mono<Policies> findAllLegacyPolicies() {
        return
                dbClient
                .select(LegacyPolicy.class)
                .all()
                .collectList()
                .map(lps -> Policies.builder().legacyPolicies(lps).build())
                .flatMap(p -> p.isEmpty() ? Mono.empty(): Mono.just(p));
    }

    public Mono<Policies> findAllQueryPolicies() {
        return
                dbClient
                .select(QueryPolicy.class)
                .all()
                .collectList()
                .map(qps -> Policies.builder().queryPolicies(qps).build())
                .flatMap(p -> p.isEmpty() ? Mono.empty(): Mono.just(p));
    }

    public Mono<Policies> findApplicationPolicyById(String id) {
        List<ApplicationPolicy> applicationPolicies = new ArrayList<>();
        return
                Flux
                .from(dbClient
                        .select(ApplicationPolicy.class)
                        .matching(org.springframework.data.relational.core.query.Query.query(Criteria.where("id").is(id)))
                        .all())
                .map(ap -> applicationPolicies.add(ap))
                .then(Mono.just(Policies.builder().applicationPolicies(applicationPolicies).build()))
                .flatMap(p -> p.isEmpty() ? Mono.empty(): Mono.just(p));
    }

    public Mono<Policies> findByApplicationOperation(ApplicationOperation operation) {
        List<ApplicationPolicy> applicationPolicies = new ArrayList<>();
        return
                Flux
                .from(dbClient
                        .select(ApplicationPolicy.class)
                        .matching(org.springframework.data.relational.core.query.Query.query(Criteria.where("operation").is(operation.getName())))
                        .all())
                .map(ap -> applicationPolicies.add(ap))
                .then(Mono.just(Policies.builder().applicationPolicies(applicationPolicies).build()))
                .flatMap(p -> p.isEmpty() ? Mono.empty(): Mono.just(p));
    }

    public Mono<Policies> findByServiceInstanceOperation(ServiceInstanceOperation operation) {
        List<ServiceInstancePolicy> serviceInstancePolicies = new ArrayList<>();
        return
                Flux
                .from(dbClient
                        .select(ServiceInstancePolicy.class)
                        .matching(org.springframework.data.relational.core.query.Query.query(Criteria.where("operation").is(operation.getName())))
                        .all())
                .map(sp -> serviceInstancePolicies.add(sp))
                .then(Mono.just(Policies.builder().serviceInstancePolicies(serviceInstancePolicies).build()))
                .flatMap(p -> p.isEmpty() ? Mono.empty(): Mono.just(p));
    }

    public Mono<Policies> findEndpointPolicyById(String id) {
        List<EndpointPolicy> endpointPolicies = new ArrayList<>();
        return
                Flux
                .from(dbClient
                        .select(EndpointPolicy.class)
                        .matching(org.springframework.data.relational.core.query.Query.query(Criteria.where("id").is(id)))
                        .all())
                .map(ep -> endpointPolicies.add(ep))
                .then(Mono.just(Policies.builder().endpointPolicies(endpointPolicies).build()))
                .flatMap(p -> p.isEmpty() ? Mono.empty(): Mono.just(p));
    }

    public Mono<Policies> findHygienePolicyById(String id) {
        List<HygienePolicy> hygienePolicies = new ArrayList<>();
        return
                Flux
                .from(dbClient
                        .select(HygienePolicy.class)
                        .matching(org.springframework.data.relational.core.query.Query.query(Criteria.where("id").is(id)))
                        .all())
                .map(hp -> hygienePolicies.add(hp))
                .then(Mono.just(Policies.builder().hygienePolicies(hygienePolicies).build()))
                .flatMap(p -> p.isEmpty() ? Mono.empty(): Mono.just(p));
    }

    public Mono<Policies> findResourceNotificationPolicyById(String id) {
        List<ResourceNotificationPolicy> resourceNotificationPolicies = new ArrayList<>();
        return
                Flux
                .from(dbClient
                        .select(ResourceNotificationPolicy.class)
                        .matching(org.springframework.data.relational.core.query.Query.query(Criteria.where("id").is(id)))
                        .all())
                .map(hp -> resourceNotificationPolicies.add(hp))
                .then(Mono.just(Policies.builder().resourceNotificationPolicies(resourceNotificationPolicies).build()))
                .flatMap(p -> p.isEmpty() ? Mono.empty(): Mono.just(p));
    }

    public Mono<Policies> findLegacyPolicyById(String id) {
        List<LegacyPolicy> legacyPolicies = new ArrayList<>();
        return
                Flux
                .from(dbClient
                        .select(LegacyPolicy.class)
                        .matching(org.springframework.data.relational.core.query.Query.query(Criteria.where("id").is(id)))
                        .all())
                .map(lp -> legacyPolicies.add(lp))
                .then(Mono.just(Policies.builder().legacyPolicies(legacyPolicies).build()))
                .flatMap(p -> p.isEmpty() ? Mono.empty(): Mono.just(p));
    }

    public Mono<Policies> findQueryPolicyById(String id) {
        List<QueryPolicy> queryPolicies = new ArrayList<>();
        return
                Flux
                .from(dbClient
                        .select(QueryPolicy.class)
                        .matching(org.springframework.data.relational.core.query.Query.query(Criteria.where("id").is(id)))
                        .all())
                .map(qp -> queryPolicies.add(qp))
                .then(Mono.just(Policies.builder().queryPolicies(queryPolicies).build()))
                .flatMap(p -> p.isEmpty() ? Mono.empty(): Mono.just(p));
    }

    public Mono<Policies> findServiceInstancePolicyById(String id) {
        List<ServiceInstancePolicy> serviceInstancePolicies = new ArrayList<>();
        return
                Flux
                .from(dbClient
                        .select(ServiceInstancePolicy.class)
                        .matching(org.springframework.data.relational.core.query.Query.query(Criteria.where("id").is(id)))
                        .all())
                .map(sp -> serviceInstancePolicies.add(sp))
                .then(Mono.just(Policies.builder().serviceInstancePolicies(serviceInstancePolicies).build()))
                .flatMap(p -> p.isEmpty() ? Mono.empty(): Mono.just(p));
    }

    public Mono<Policies> save(Policies entity) {
        List<ApplicationPolicy> applicationPolicies =
                entity.getApplicationPolicies().stream()
                .map(p -> idProvider.seedApplicationPolicy(p)).collect(Collectors.toList());

        List<ServiceInstancePolicy> serviceInstancePolicies =
                entity.getServiceInstancePolicies().stream()
                .map(p -> idProvider.seedServiceInstancePolicy(p)).collect(Collectors.toList());

        List<EndpointPolicy> endpointPolicies =
                entity.getEndpointPolicies().stream()
                .map(p -> idProvider.seedEndpointPolicy(p)).collect(Collectors.toList());

        List<QueryPolicy> queryPolicies =
                entity.getQueryPolicies().stream()
                .map(p -> idProvider.seedQueryPolicy(p)).collect(Collectors.toList());

        List<HygienePolicy> hygienePolicies =
                entity.getHygienePolicies().stream()
                .map(p -> idProvider.seedHygienePolicy(p)).collect(Collectors.toList());

        List<ResourceNotificationPolicy> resourceNotificationPolicies =
                entity.getResourceNotificationPolicies().stream()
                .map(p -> idProvider.seedResourceNotificationPolicy(p)).collect(Collectors.toList());

        List<LegacyPolicy> legacyPolicies =
                entity.getLegacyPolicies().stream()
                .map(p -> idProvider.seedLegacyPolicy(p)).collect(Collectors.toList());

        return Flux.fromIterable(applicationPolicies)
                .concatMap(this::saveApplicationPolicy)
                .thenMany(Flux.fromIterable(serviceInstancePolicies)
                        .concatMap(this::saveServiceInstancePolicy))
                .thenMany(Flux.fromIterable(endpointPolicies)
                        .concatMap(this::saveEndpointPolicy))
                .thenMany(Flux.fromIterable(queryPolicies)
                        .concatMap(this::saveQueryPolicy))
                .thenMany(Flux.fromIterable(hygienePolicies)
                        .concatMap(this::saveHygienePolicy))
                .thenMany(Flux.fromIterable(resourceNotificationPolicies)
                        .concatMap(this::saveResourceNotificationPolicy))
                .thenMany(Flux.fromIterable(legacyPolicies)
                        .concatMap(this::saveLegacyPolicy))
                .then(
                        Mono.just(
                                Policies
                                .builder()
                                .applicationPolicies(applicationPolicies)
                                .serviceInstancePolicies(serviceInstancePolicies)
                                .endpointPolicies(endpointPolicies)
                                .queryPolicies(queryPolicies)
                                .hygienePolicies(hygienePolicies)
                                .resourceNotificationPolicies(resourceNotificationPolicies)
                                .legacyPolicies(legacyPolicies)
                                .build()
                                )
                        );
    }

    private Mono<ApplicationPolicy> saveApplicationPolicy(ApplicationPolicy ap) {
        return
                dbClient
                .insert(ap);
    }

    private Mono<EndpointPolicy> saveEndpointPolicy(EndpointPolicy ep) {
        return
                dbClient
                .insert(ep);
    }

    private Mono<HygienePolicy> saveHygienePolicy(HygienePolicy hp) {
        return
                dbClient
                .insert(hp);
    }

    private Mono<ResourceNotificationPolicy> saveResourceNotificationPolicy(ResourceNotificationPolicy hp) {
        return
                dbClient
                .insert(hp);
    }

    private Mono<LegacyPolicy> saveLegacyPolicy(LegacyPolicy lp) {
        return
                dbClient
                .insert(lp);
    }

    private Mono<QueryPolicy> saveQueryPolicy(QueryPolicy qp) {
        return
                dbClient
                .insert(qp);
    }

    private Mono<ServiceInstancePolicy> saveServiceInstancePolicy(ServiceInstancePolicy sip) {
        return
                dbClient
                .insert(sip);
    }
}


================================================
File: src/main/java/org/cftoolsuite/cfapp/repository/R2dbcQueryRepository.java
================================================
package org.cftoolsuite.cfapp.repository;

import org.cftoolsuite.cfapp.domain.Query;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.r2dbc.core.R2dbcEntityOperations;
import org.springframework.stereotype.Repository;

import io.r2dbc.spi.Row;
import io.r2dbc.spi.RowMetadata;
import reactor.core.publisher.Flux;
import reactor.util.function.Tuple2;
import reactor.util.function.Tuples;

@Repository
public class R2dbcQueryRepository {

    private final R2dbcEntityOperations client;

    @Autowired
    public R2dbcQueryRepository(R2dbcEntityOperations client) {
        this.client = client;
    }

    public Flux<Tuple2<Row, RowMetadata>> executeQuery(Query query) {
        return
                client
                .getDatabaseClient()
                .sql(query.getSql())
                .map(Tuples::of)
                .all();
    }
}


================================================
File: src/main/java/org/cftoolsuite/cfapp/repository/R2dbcServiceInstanceDetailRepository.java
================================================
package org.cftoolsuite.cfapp.repository;

import java.time.Duration;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.LocalTime;

import org.cftoolsuite.cfapp.domain.ServiceInstanceDetail;
import org.cftoolsuite.cfapp.domain.ServiceInstancePolicy;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.Sort;
import org.springframework.data.domain.Sort.Order;
import org.springframework.data.r2dbc.core.R2dbcEntityOperations;
import org.springframework.data.relational.core.query.Criteria;
import org.springframework.data.relational.core.query.Query;
import org.springframework.stereotype.Repository;

import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;
import reactor.util.function.Tuple2;
import reactor.util.function.Tuples;

@Repository
public class R2dbcServiceInstanceDetailRepository {

    private final R2dbcEntityOperations client;

    @Autowired
    public R2dbcServiceInstanceDetailRepository(R2dbcEntityOperations client) {
        this.client = client;
    }

    public Mono<Void> deleteAll() {
        return
                client
                .delete(ServiceInstanceDetail.class)
                .all()
                .then();
    }

    public Flux<ServiceInstanceDetail> findAll() {
        return
                client
                .select(ServiceInstanceDetail.class)
                .matching(Query.empty().sort(Sort.by(Order.asc("organization"), Order.asc("space"), Order.asc("service"), Order.asc("service_name"))))
                .all();
    }

    public Flux<ServiceInstanceDetail> findByDateRange(LocalDate start, LocalDate end) {
        Criteria criteria =
                Criteria.where("last_updated").lessThanOrEquals(LocalDateTime.of(end, LocalTime.MAX)).and("last_updated").greaterThan(LocalDateTime.of(start, LocalTime.MIDNIGHT));
        return
                client
                .select(ServiceInstanceDetail.class)
                .matching(Query.query(criteria).sort(Sort.by(Order.desc("last_updated"))))
                .all();
    }

    public Flux<Tuple2<ServiceInstanceDetail, ServiceInstancePolicy>> findByServiceInstancePolicy(ServiceInstancePolicy policy) {
        LocalDateTime fromDateTime = policy.getOption("from-datetime", LocalDateTime.class);
        String fromDuration = policy.getOption("from-duration", String.class);
        LocalDateTime temporal = null;
        Criteria criteria = null;
        if (fromDateTime != null) {
            temporal = fromDateTime;
        }
        if (fromDuration != null) {
            temporal = LocalDateTime.now().minus(Duration.parse(fromDuration));
        }
        if (temporal != null) {
            criteria = Criteria.where("bound_applications").isNull().and("last_updated").lessThanOrEquals(temporal);
        } else {
            criteria = Criteria.where("bound_applications").isNull();
        }
        return
                client
                .select(ServiceInstanceDetail.class)
                .matching(Query.query(criteria).sort(Sort.by(Order.asc("organization"), Order.asc("space"), Order.asc("service_name"))))
                .all()
                .map(r -> toTuple(r, policy));
    }

    public Mono<ServiceInstanceDetail> save(ServiceInstanceDetail entity) {
        return
                client
                .insert(entity);
    }

    private Tuple2<ServiceInstanceDetail, ServiceInstancePolicy> toTuple(ServiceInstanceDetail detail, ServiceInstancePolicy policy) {
        return Tuples.of(detail, policy);
    }

}


================================================
File: src/main/java/org/cftoolsuite/cfapp/repository/R2dbcServiceInstanceMetricsRepository.java
================================================
package org.cftoolsuite.cfapp.repository;

import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.LocalTime;

import org.cftoolsuite.cfapp.domain.Defaults;
import org.cftoolsuite.cfapp.domain.ServiceInstanceDetail;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.r2dbc.core.R2dbcEntityOperations;
import org.springframework.data.relational.core.query.Criteria;
import org.springframework.data.relational.core.query.Query;
import org.springframework.stereotype.Repository;

import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;
import reactor.util.function.Tuple2;
import reactor.util.function.Tuples;

@Repository
public class R2dbcServiceInstanceMetricsRepository {

    private final R2dbcEntityOperations client;

    @Autowired
    public R2dbcServiceInstanceMetricsRepository(
            R2dbcEntityOperations client) {
        this.client = client;
    }

    protected Flux<Tuple2<String, Long>> by(String columnName) {
        String sql = "select " + columnName + ", count(" + columnName + ") as cnt from service_instance_detail group by " + columnName;
        return
                client
                .getDatabaseClient()
                .sql(sql)
                .map((row, metadata)
                        -> Tuples.of(Defaults.getColumnValueOrDefault(row, columnName, String.class, "--"), Defaults.getColumnValueOrDefault(row, "cnt", Long.class, 0L)))
                .all()
                .defaultIfEmpty(Tuples.of("--", 0L));
    }

    public Flux<Tuple2<String, Long>> byOrganization() {
        return by("organization");
    }

    public Flux<Tuple2<String, Long>> byService() {
        String sqlup = "select type, count(type) as cnt from service_instance_detail where type = 'user_provided_service_instance' group by type";
        Flux<Tuple2<String, Long>> ups =
                client
                .getDatabaseClient()
                .sql(sqlup)
                .map((row, metadata)
                        -> Tuples.of("user-provided", Defaults.getColumnValueOrDefault(row, "cnt", Long.class, 0L)))
                .all()
                .defaultIfEmpty(Tuples.of("user-provided", 0L));
        String sqlms = "select service, count(service) as cnt from service_instance_detail where type = 'managed_service_instance' group by service";
        Flux<Tuple2<String, Long>> ms =
                client
                .getDatabaseClient()
                .sql(sqlms)
                .map((row, metadata)
                        -> Tuples.of(Defaults.getColumnValueOrDefault(row, "service", String.class, "managed"), Defaults.getColumnValueOrDefault(row, "cnt", Long.class, 0L)))
                .all()
                .defaultIfEmpty(Tuples.of("managed", 0L));
        return ups.concatWith(ms);
    }

    public Flux<Tuple2<String, Long>> byServiceAndPlan() {
        String sql = "select service, plan, count(*) as cnt from service_instance_detail where type = 'managed_service_instance' group by service, plan";
        return
                client
                .getDatabaseClient()
                .sql(sql)
                .map((row, metadata)
                        -> Tuples.of(
                                String.join(
                                        "/",
                                        Defaults.getColumnValueOrDefault(row, "service", String.class, "unknown"),
                                        Defaults.getColumnValueOrDefault(row, "plan", String.class, "unknown")
                                        ),
                                Defaults.getColumnValueOrDefault(row, "cnt", Long.class, 0L)))
                .all()
                .defaultIfEmpty(Tuples.of("unknown", 0L));
    }

    protected Mono<Long> countByDateRange(LocalDate start, LocalDate end) {
        Criteria criteria =
                Criteria.where("last_updated").lessThanOrEquals(LocalDateTime.of(end, LocalTime.MAX)).and("last_updated").greaterThan(LocalDateTime.of(start, LocalTime.MIDNIGHT));
        return
                client
                .select(ServiceInstanceDetail.class)
                .matching(Query.query(criteria))
                .all()
                .count()
                .defaultIfEmpty(0L);
    }

    protected Mono<Long> countStagnant(LocalDate end) {
        Criteria criteria =
                Criteria.where("last_updated").lessThan(LocalDateTime.of(end, LocalTime.MIDNIGHT));
        return
                client
                .select(ServiceInstanceDetail.class)
                .matching(Query.query(criteria))
                .all()
                .count()
                .defaultIfEmpty(0L);
    }

    public Mono<Long> totalServiceInstances() {
        String sql = "select count(*) as cnt from service_instance_detail";
        return
                client
                .getDatabaseClient()
                .sql(sql)
                .map((row, metadata) -> Defaults.getColumnValueOrDefault(row, "cnt", Long.class, 0L))
                .one()
                .defaultIfEmpty(0L);
    }

    public Flux<Tuple2<String, Long>> totalVelocity() {
        final LocalDate now = LocalDate.now();
        return
                Flux.concat(
                        countByDateRange(now.minusDays(1), now).map(r -> Tuples.of("in-last-day", r)),
                        countByDateRange(now.minusDays(2), now.minusDays(1)).map(r -> Tuples.of("between-one-day-and-two-days", r)),
                        countByDateRange(now.minusWeeks(1), now.minusDays(2)).map(r -> Tuples.of("between-two-days-and-one-week", r)),
                        countByDateRange(now.minusWeeks(2), now.minusWeeks(1)).map(r -> Tuples.of("between-one-week-and-two-weeks", r)),
                        countByDateRange(now.minusMonths(1), now.minusWeeks(2)).map(r -> Tuples.of("between-two-weeks-and-one-month", r)),
                        countByDateRange(now.minusMonths(3), now.minusMonths(1)).map(r -> Tuples.of("between-one-month-and-three-months", r)),
                        countByDateRange(now.minusMonths(6), now.minusMonths(3)).map(r -> Tuples.of("between-three-months-and-six-months", r)),
                        countByDateRange(now.minusYears(1), now.minusMonths(6)).map(r -> Tuples.of("between-six-months-and-one-year", r)),
                        countStagnant(now.minusYears(1)).map(r -> Tuples.of("beyond-one-year", r)));
    }

}


================================================
File: src/main/java/org/cftoolsuite/cfapp/repository/R2dbcSpaceRepository.java
================================================
package org.cftoolsuite.cfapp.repository;

import org.cftoolsuite.cfapp.domain.Space;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.Sort;
import org.springframework.data.domain.Sort.Order;
import org.springframework.data.r2dbc.core.R2dbcEntityOperations;
import org.springframework.data.relational.core.query.Query;
import org.springframework.stereotype.Repository;

import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

@Repository
public class R2dbcSpaceRepository {

    private final R2dbcEntityOperations client;

    @Autowired
    public R2dbcSpaceRepository(R2dbcEntityOperations client) {
        this.client = client;
    }

    public Mono<Void> deleteAll() {
        return
                client
                .delete(Space.class)
                .all()
                .then();
    }

    public Flux<Space> findAll() {
        return
                client
                .select(Space.class)
                .matching(Query.empty().sort(Sort.by(Order.asc("org_name"), Order.asc("space_name"))))
                .all();
    }

    public Mono<Space> save(Space entity) {
        return
                client
                .insert(entity);
    }
}


================================================
File: src/main/java/org/cftoolsuite/cfapp/repository/R2dbcSpaceUsersRepository.java
================================================
package org.cftoolsuite.cfapp.repository;

import org.cftoolsuite.cfapp.domain.SpaceUsers;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.Sort;
import org.springframework.data.domain.Sort.Order;
import org.springframework.data.r2dbc.core.R2dbcEntityOperations;
import org.springframework.data.relational.core.query.Criteria;
import org.springframework.data.relational.core.query.Query;
import org.springframework.stereotype.Repository;

import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

@Repository
public class R2dbcSpaceUsersRepository {

    private final R2dbcEntityOperations client;

    @Autowired
    public R2dbcSpaceUsersRepository(R2dbcEntityOperations client) {
        this.client = client;
    }

    public Mono<Void> deleteAll() {
        return
                client
                .delete(SpaceUsers.class)
                .all()
                .then();
    }

    public Flux<SpaceUsers> findAll() {
        return
                client
                .select(SpaceUsers.class)
                .matching(Query.empty().sort(Sort.by(Order.asc("organization"), Order.asc("space"))))
                .all();
    }

    public Mono<SpaceUsers> findByOrganizationAndSpace(String organization, String space) {
        return
                client
                .select(SpaceUsers.class)
                .matching(Query.query(Criteria.where("organization").is(organization).and("space").is(space)))
                .one();
    }

    public Mono<SpaceUsers> save(SpaceUsers entity) {
        return
                client
                .insert(entity);
    }

}


================================================
File: src/main/java/org/cftoolsuite/cfapp/repository/R2dbcTimeKeeperRepository.java
================================================
package org.cftoolsuite.cfapp.repository;

import java.time.LocalDateTime;

import org.cftoolsuite.cfapp.domain.TimeKeeper;
import org.springframework.data.r2dbc.core.R2dbcEntityOperations;
import org.springframework.stereotype.Repository;

import reactor.core.publisher.Mono;

@Repository
public class R2dbcTimeKeeperRepository {

    private final R2dbcEntityOperations client;

    public R2dbcTimeKeeperRepository(R2dbcEntityOperations client) {
        this.client = client;
    }

    public Mono<Void> deleteOne() {
        return
                client
                .delete(TimeKeeper.class)
                .all()
                .then();
    }

    public Mono<LocalDateTime> findOne() {
        return
                client
                .select(TimeKeeper.class)
                .one()
                .map(TimeKeeper::getCollectionTime);
    }

    public Mono<TimeKeeper> save(LocalDateTime collectionTime) {
        return
                client
                .insert(new TimeKeeper(collectionTime));
    }

}


================================================
File: src/main/java/org/cftoolsuite/cfapp/service/AccountMatcher.java
================================================
package org.cftoolsuite.cfapp.service;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.cftoolsuite.cfapp.config.PasSettings;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import lombok.extern.slf4j.Slf4j;

@Slf4j
@Component
public class AccountMatcher {

    private final Pattern pattern;
    private final PasSettings settings;

    @Autowired
    public AccountMatcher(PasSettings settings) {
        this.settings = settings;
        this.pattern = Pattern.compile(settings.getAccountRegex());
    }

    public boolean matches(final String candidate) {
        Matcher matcher = pattern.matcher(candidate);
        boolean result = matcher.matches();
        log.trace("Does account {} match account regex pattern {}? {}", candidate, settings.getAccountRegex(), String.valueOf(result));
        return result;
    }
}


================================================
File: src/main/java/org/cftoolsuite/cfapp/service/AppDetailService.java
================================================
package org.cftoolsuite.cfapp.service;

import java.time.LocalDate;

import org.cftoolsuite.cfapp.domain.AppDetail;
import org.cftoolsuite.cfapp.domain.ApplicationPolicy;

import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;
import reactor.util.function.Tuple2;

public interface AppDetailService {

    Mono<Void> deleteAll();

    Flux<AppDetail> findAll();

    Mono<AppDetail> findByAppId(String appId);

    Flux<Tuple2<AppDetail, ApplicationPolicy>> findByApplicationPolicy(ApplicationPolicy policy, boolean mayHaveServiceBindings);

    Flux<AppDetail> findByDateRange(LocalDate start, LocalDate end);

    Mono<AppDetail> save(AppDetail entity);
}


================================================
File: src/main/java/org/cftoolsuite/cfapp/service/AppMetricsService.java
================================================
package org.cftoolsuite.cfapp.service;

import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;
import reactor.util.function.Tuple2;

public interface AppMetricsService {

    Flux<Tuple2<String, Long>> byBuildpack();

    Flux<Tuple2<String, Long>> byDockerImage();

    Flux<Tuple2<String, Long>> byOrganization();

    Flux<Tuple2<String, Long>> byStack();

    Flux<Tuple2<String, Long>> byStatus();

    Mono<Long> totalApplicationInstances();

    Mono<Long> totalApplications();

    Mono<Long> totalCrashedApplicationInstances();

    Mono<Double> totalDiskUsed();

    Mono<Double> totalMemoryUsed();

    Mono<Long> totalRunningApplicationInstances();

    Mono<Long> totalStoppedApplicationInstances();

    Flux<Tuple2<String, Long>> totalVelocity();

}


================================================
File: src/main/java/org/cftoolsuite/cfapp/service/AppRelationshipService.java
================================================
package org.cftoolsuite.cfapp.service;

import org.cftoolsuite.cfapp.domain.AppRelationship;

import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

public interface AppRelationshipService {

    Mono<Void> deleteAll();

    Flux<AppRelationship> findAll();

    Flux<AppRelationship> findByApplicationId(String applicationId);

    Flux<AppRelationship> findByServiceInstanceId(String serviceInstanceId);

    Mono<AppRelationship> save(AppRelationship entity);
}


================================================
File: src/main/java/org/cftoolsuite/cfapp/service/ApplicationReporter.java
================================================
package org.cftoolsuite.cfapp.service;

import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;

import org.cftoolsuite.cfapp.domain.accounting.application.AppUsageMonthly;
import org.cftoolsuite.cfapp.domain.accounting.application.AppUsageReport;
import org.cftoolsuite.cfapp.domain.accounting.application.AppUsageMonthly.AppUsageMonthlyBuilder;
import org.cftoolsuite.cfapp.domain.accounting.application.AppUsageReport.AppUsageReportBuilder;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.util.Assert;

import com.fasterxml.jackson.core.JsonParseException;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.JsonMappingException;
import com.fasterxml.jackson.databind.MappingIterator;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.dataformat.csv.CsvMapper;
import com.fasterxml.jackson.dataformat.csv.CsvParser;

import lombok.extern.slf4j.Slf4j;

@Slf4j
@Service
public class ApplicationReporter {

    private static final String REPORT_HEADER = "foundation,time_period,maximum_instances,average_instances,instance_hours\n";
    private final ObjectMapper mapper;

    @Autowired
    public ApplicationReporter(ObjectMapper mapper) {
        this.mapper = mapper;
    }

    public String createReport(ReportRequest[] requests) {
        List<ReportRequest> list = Arrays.asList(requests);
        try { log.info(mapper.writeValueAsString(list)); } catch (JsonProcessingException jpe) {}
        StringBuilder result = new StringBuilder();
        result.append(REPORT_HEADER);
        for (ReportRequest r: list) {
            result.append(createReport(r.getFoundation(), r.getEnvironment(), r.getPeriod(), r.getFilename()));
        }
        return result.toString();
    }

    public void createReport(String outputFilename, ReportRequest[] requests) {
        Path path = Paths.get(outputFilename);
        try {
            Files.write(path, createReport(requests).getBytes());
        } catch (IOException ioe) {
            log.warn("Could not create report output file!", ioe);
        }
    }

    public String createReport(String foundation, String environment, String period, String filename) {
        Assert.hasText(foundation, "Foundation must be specified!");
        Assert.hasText(environment, "Environment must be specified!");
        Assert.hasText(period, "Time period must be specified! It should have the form YYYY-MM");
        Assert.hasText(filename, "Filename must be specified!");
        StringBuilder result = new StringBuilder();
        Integer year = Integer.valueOf(period.split("-")[0]);
        Integer month = Integer.valueOf(period.split("-")[1]);
        try {
            AppUsageReport report = readAppUsageReport(filename);
            List<AppUsageMonthly> usage = report.getMonthlyReports();
            List<AppUsageMonthly> filtered =
                    usage
                    .stream()
                    .filter(u -> u.getYear().equals(year) && u.getMonth() != null && u.getMonth().equals(month))
                    .collect(Collectors.toList());
            for (AppUsageMonthly u: filtered) {
                result.append(foundation + "," + period + "," + u.getMaximumAppInstances() + "," + u.getAverageAppInstances() + "," + u.getAppInstanceHours() + "\n");
            }
        } catch (JsonParseException jpe) {
            log.warn(String.format("Could not parse file contents of %s into a AppUsageReport!", filename), jpe);
        } catch (JsonMappingException jme) {
            log.warn(String.format("Could not map file contents in %s into JSON!", filename), jme);
        } catch (IOException ioe) {
            log.warn(String.format("Trouble creating report from %s!", filename), ioe);
        }
        return result.toString();
    }

    protected AppUsageReport readAppUsageReport(String filename) throws JsonParseException, JsonMappingException, IOException {
        String content = readFile(filename);
        if (filename.endsWith(".json")) {
            return mapper.readValue(content, AppUsageReport.class);
        } else if (filename.endsWith(".csv")) {
            CsvMapper csvMapper = new CsvMapper();
            csvMapper.enable(CsvParser.Feature.WRAP_AS_ARRAY);
            File csvFile = new File(filename);
            MappingIterator<String[]> it = csvMapper.readerFor(String[].class).readValues(csvFile);
            AppUsageReportBuilder builder = AppUsageReport.builder();
            List<AppUsageMonthly> reports = new ArrayList<>();
            int rowNum = 0;
            while (it.hasNext()) {
                String[] row = it.next();
                if (rowNum > 0) {
                    AppUsageMonthlyBuilder amb = AppUsageMonthly.builder();
                    for (int i = 0; i < row.length; i++) {
                        if (i == 0) {
                            String[] period = row[i].split("-");
                            if (period.length == 2) {
                                amb.month(Integer.valueOf(period[1]));
                            }
                            amb.year(Integer.valueOf(period[0]));
                        }
                        if (i == 1) {
                            amb.averageAppInstances(Double.valueOf(row[i]));
                        }
                        if (i == 2) {
                            amb.maximumAppInstances(Integer.valueOf(row[i]));
                        }
                        if (i == 3) {
                            amb.appInstanceHours(Double.valueOf(row[i]));
                        }
                    }
                    reports.add(amb.build());
                }
                rowNum++;
            }
            builder.monthlyReports(reports);
            return builder.build();
        } else {
            return AppUsageReport.builder().build();
        }
    }

    protected String readFile(String filename) {
        String content = "";
        try {
            content = new String(Files.readAllBytes(Paths.get(filename)));
        } catch (IOException ioe) {
            log.warn(String.format("Trouble reading file %s contents", filename), ioe);
        }
        return content;
    }

}


================================================
File: src/main/java/org/cftoolsuite/cfapp/service/BuildpacksCache.java
================================================
package org.cftoolsuite.cfapp.service;

import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.apache.commons.lang3.StringUtils;
import org.cftoolsuite.cfapp.domain.Buildpack;
import org.springframework.stereotype.Component;

@Component
public class BuildpacksCache {

    private final Map<String, Buildpack> buildpacksById = new HashMap<>();

    public Map<String, Buildpack> from(List<org.cloudfoundry.operations.buildpacks.Buildpack> input) {
        buildpacksById.clear();
        input.forEach(
                b -> {
                    Buildpack buildpack =
                            Buildpack
                            .builder()
                            .id(b.getId())
                            .name(b.getName())
                            .position(b.getPosition())
                            .enabled(b.getEnabled())
                            .locked(b.getLocked())
                            .filename(b.getFilename())
                            .build();
                    buildpacksById.put(b.getId(), buildpack);
                });
        return buildpacksById;
    }

    public Buildpack getBuildpackById(String id) {
        if (StringUtils.isBlank(id)) {
            return null;
        }
        return buildpacksById.get(id);
    }
}


================================================
File: src/main/java/org/cftoolsuite/cfapp/service/DemographicsService.java
================================================
package org.cftoolsuite.cfapp.service;

import org.cftoolsuite.cfapp.domain.Demographics;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import reactor.core.publisher.Mono;

@Service
public class DemographicsService {

    private final SpaceService spaceService;
    private final SpaceUsersService spaceUsersService;
    private final OrganizationService orgService;

    @Autowired
    public DemographicsService(
            SpaceService spaceService,
            SpaceUsersService spaceUsersService,
            OrganizationService orgService
            ) {
        this.spaceService = spaceService;
        this.spaceUsersService = spaceUsersService;
        this.orgService = orgService;
    }

    public Mono<Demographics> getDemographics() {
        return totalUserAccounts()
                .map(ua -> Demographics.builder().userAccounts(ua))
                .flatMap(b -> totalServiceAccounts()
                        .map(sa -> b.serviceAccounts(sa)))
                .flatMap(b -> totalSpaces()
                        .map(s -> b.spaces(s)))
                .flatMap(b -> totalOrganizations()
                        .map(o -> b.organizations(o).build()));
    }

    private Mono<Long> totalOrganizations() {
        return orgService.findAll().count();
    }

    private Mono<Long> totalServiceAccounts() {
        return spaceUsersService.totalServiceAccounts();
    }

    private Mono<Long> totalSpaces() {
        return spaceService.findAll().count();
    }

    private Mono<Long> totalUserAccounts() {
        return spaceUsersService.totalUserAccounts();
    }
}


================================================
File: src/main/java/org/cftoolsuite/cfapp/service/DormantWorkloadsService.java
================================================
package org.cftoolsuite.cfapp.service;

import java.util.List;

import org.apache.commons.lang3.BooleanUtils;
import org.cftoolsuite.cfapp.domain.AppDetail;
import org.cftoolsuite.cfapp.domain.AppRelationship;
import org.cftoolsuite.cfapp.domain.HygienePolicy;
import org.cftoolsuite.cfapp.domain.ServiceInstanceDetail;
import org.cftoolsuite.cfapp.util.PolicyFilter;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

@Service
public class DormantWorkloadsService {

    private final EventsService eventsService;
    private final SnapshotService snapshotService;
    private final AppDetailService appDetailService;
    private final AppRelationshipService relationshipService;
    private final PolicyFilter filter;

    @Autowired
    public DormantWorkloadsService(
            EventsService eventsService,
            SnapshotService snapshotService,
            AppDetailService appDetailService,
            AppRelationshipService relationshipService,
            PolicyFilter filter
            ) {
        this.eventsService = eventsService;
        this.snapshotService = snapshotService;
        this.appDetailService = appDetailService;
        this.relationshipService = relationshipService;
        this.filter = filter;
    }

    private Mono<Boolean> areAnyRelationsDormant(ServiceInstanceDetail sid, Integer daysSinceLastUpdate) {
        // see if service instance has any bound applications
        Flux<AppRelationship> relations = relationshipService.findByServiceInstanceId(sid.getServiceInstanceId());
        return
                relations
                // get application details for each bound app id
                .flatMap(relation -> appDetailService.findByAppId(relation.getAppId()))
                // check whether or not the app is dormant
                .flatMap(appDetail -> eventsService
                        .isDormantApplication(appDetail, daysSinceLastUpdate))
                .collectList()
                // result is a union; service instance deemed not dormant if any one of the applications is not dormant
                .map(list -> list.isEmpty() ? Boolean.FALSE : BooleanUtils.or(list.toArray(Boolean[]::new)));
    }

    public Mono<List<AppDetail>> getDormantApplications(HygienePolicy policy) {
        return snapshotService
                .assembleSnapshotDetail()
                .flatMapMany(sd -> Flux.fromIterable(sd.getApplications()))
                .filter(app -> filter.isWhitelisted(policy, app.getOrganization()))
                .filter(app -> filter.isBlacklisted(app.getOrganization(), app.getSpace()))
                .filter(app -> app.getRequestedState().equalsIgnoreCase("started"))
                // @see https://github.com/reactor/reactor-core/issues/498
                .filterWhen(app -> eventsService.isDormantApplication(app, policy.getDaysSinceLastUpdate()))
                .collectList();
    }

    public Mono<List<AppDetail>> getDormantApplications(Integer daysSinceLastUpdate) {
        return getDormantApplications(HygienePolicy.builder().daysSinceLastUpdate(daysSinceLastUpdate).build());
    }

    public Mono<List<ServiceInstanceDetail>> getDormantServiceInstances(HygienePolicy policy) {
        return snapshotService
                .assembleSnapshotDetail()
                .flatMapMany(sd -> Flux.fromIterable(sd.getServiceInstances()))
                .filter(sid -> filter.isWhitelisted(policy, sid.getOrganization()))
                .filter(sid -> filter.isBlacklisted(sid.getOrganization(), sid.getSpace()))
                // @see https://github.com/reactor/reactor-core/issues/498
                .filterWhen(sid -> eventsService.isDormantServiceInstance(sid, policy.getDaysSinceLastUpdate()))
                // we should also check that if service instance is bound to one or more apps,
                // then use the event date associated with each relation (i.e., bound application) to determine whether or not service instance is dormant
                .filterWhen(sid -> areAnyRelationsDormant(sid, policy.getDaysSinceLastUpdate()))
                .collectList();
    }

    public Mono<List<ServiceInstanceDetail>> getDormantServiceInstances(Integer daysSinceLastUpdate) {
        return getDormantServiceInstances(HygienePolicy.builder().daysSinceLastUpdate(daysSinceLastUpdate).build());
    }

}


================================================
File: src/main/java/org/cftoolsuite/cfapp/service/DropletsService.java
================================================
package org.cftoolsuite.cfapp.service;

import org.cftoolsuite.cfapp.config.PasSettings;
import org.cftoolsuite.cfapp.util.DropletProcessingCondition;
import org.cftoolsuite.cfapp.util.RetryableTokenProvider;
import org.cloudfoundry.reactor.DefaultConnectionContext;
import org.cloudfoundry.reactor.TokenProvider;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Conditional;
import org.springframework.core.io.buffer.DataBuffer;
import org.springframework.http.HttpHeaders;
import org.springframework.stereotype.Service;
import org.springframework.util.Assert;
import org.springframework.web.reactive.function.client.WebClient;
import org.springframework.web.util.UriComponentsBuilder;

import lombok.extern.slf4j.Slf4j;
import reactor.core.publisher.Flux;

@Slf4j
@Service
@Conditional(DropletProcessingCondition.class)
// @see https://v3-apidocs.cloudfoundry.org/version/3.118.0/index.html#download-droplet-bits
public class DropletsService {

    private final WebClient webClient;
    private final DefaultConnectionContext connectionContext;
    private final TokenProvider tokenProvider;
    private final PasSettings settings;

    @Autowired
    public DropletsService(
            WebClient webClient,
            DefaultConnectionContext connectionContext,
            TokenProvider tokenProvider,
            PasSettings settings) {
        this.webClient = webClient;
        this.connectionContext = connectionContext;
        this.tokenProvider = tokenProvider;
        this.settings = settings;
    }

    public Flux<DataBuffer> downloadDroplet(String id) {
        Assert.hasText(id, "Global unique identifier for droplet must not be blank or null!");
        final String uri =
            UriComponentsBuilder
                .newInstance()
                .scheme("https")
                .host(settings.getApiHost())
                .path("/v3/droplets/{id}/download")
                .buildAndExpand(id)
                .encode()
                .toUriString();
        log.trace("Attempting to download droplet with GET {}", uri);
        return
            RetryableTokenProvider
                .getToken(tokenProvider, connectionContext)
                .flatMapMany(
                    t -> webClient
                        .get()
                        .uri(uri)
                        .header(HttpHeaders.AUTHORIZATION, t)
                        .retrieve()
                        .bodyToFlux(DataBuffer.class));
    }

}


================================================
File: src/main/java/org/cftoolsuite/cfapp/service/EventsService.java
================================================
package org.cftoolsuite.cfapp.service;

import java.time.LocalDateTime;
import java.time.ZoneOffset;
import java.time.temporal.ChronoUnit;
import java.util.stream.Collectors;

import org.cftoolsuite.cfapp.config.PasSettings;
import org.cftoolsuite.cfapp.domain.AppDetail;
import org.cftoolsuite.cfapp.domain.Event;
import org.cftoolsuite.cfapp.domain.ServiceInstanceDetail;
import org.cftoolsuite.cfapp.domain.event.EventType;
import org.cftoolsuite.cfapp.domain.event.Events;
import org.cftoolsuite.cfapp.domain.event.Resource;
import org.cftoolsuite.cfapp.util.RetryableTokenProvider;
import org.cloudfoundry.reactor.DefaultConnectionContext;
import org.cloudfoundry.reactor.TokenProvider;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpHeaders;
import org.springframework.stereotype.Service;
import org.springframework.util.Assert;
import org.springframework.web.reactive.function.client.WebClient;
import org.springframework.web.reactive.function.client.WebClientResponseException;
import org.springframework.web.util.UriComponentsBuilder;

import lombok.extern.slf4j.Slf4j;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

@Slf4j
@Service
// @see https://apidocs.cloudfoundry.org/287/events/list_all_events.html
public class EventsService {

    private static final int EVENTS_PER_PAGE = 10;
    private static final int MAX_NUMBER_OF_EVENTS = 250;

    private final WebClient webClient;
    private final DefaultConnectionContext connectionContext;
    private final TokenProvider tokenProvider;
    private final PasSettings settings;

    @Autowired
    public EventsService(
            WebClient webClient,
            DefaultConnectionContext connectionContext,
            TokenProvider tokenProvider,
            PasSettings settings) {
        this.webClient = webClient;
        this.connectionContext = connectionContext;
        this.tokenProvider = tokenProvider;
        this.settings = settings;
    }

    public Mono<Events> getEvents(String id, String type) {
        Assert.hasText(id, "Global unique identifier for application or service instance must not be blank or null!");
        EventType eventType = EventType.from(type);
        final String uri = UriComponentsBuilder
                .newInstance()
                .scheme("https")
                .host(settings.getApiHost())
                .path("/v2/events")
                .queryParam("q", "actee:{id}")
                .queryParam("q", "type:{type}")
                .queryParam("page", 1)
                .queryParam("results-per-page", 1)
                .queryParam("order-direction", "desc")
                .queryParam("order-by", "timestamp")
                .buildAndExpand(id, eventType.getId())
                .encode()
                .toUriString();
        return
            RetryableTokenProvider
                .getToken(tokenProvider, connectionContext)
                .flatMap(t -> webClient
                        .get()
                        .uri(uri)
                        .header(HttpHeaders.AUTHORIZATION, t)
                        .retrieve()
                        .bodyToMono(Events.class))
                        .timeout(settings.getTimeout(), Mono.just(Events.builder().build()))
                        .onErrorResume(
                            WebClientResponseException.class,
                            e -> {
                                log.warn(String.format("Could not obtain events from GET %s", uri), e);
                                return Mono.just(Events.builder().build());
                            }
                        );
    }

    public Mono<Events> getEvents(String id, Integer numberOfEvents) {
        Assert.hasText(id, "Global unique identifier for application or service instance must not be blank or null!");
        final int pageSize = getPageSize(numberOfEvents);
        final String uri = UriComponentsBuilder
                .newInstance()
                .scheme("https")
                .host(settings.getApiHost())
                .path("/v2/events")
                .queryParam("q", "actee:{id}")
                .queryParam("page", 1)
                .queryParam("results-per-page", "{pageSize}")
                .queryParam("order-direction", "desc")
                .queryParam("order-by", "timestamp")
                .buildAndExpand(id, pageSize)
                .encode()
                .toUriString();
        return
            RetryableTokenProvider
                .getToken(tokenProvider, connectionContext)
                .flatMap(t -> webClient
                        .get()
                        .uri(uri)
                        .header(HttpHeaders.AUTHORIZATION, t)
                        .retrieve()
                        .bodyToMono(Events.class))
                        .timeout(settings.getTimeout(), Mono.just(Events.builder().build()))
                        .onErrorResume(
                            WebClientResponseException.class,
                            e -> {
                                log.warn(String.format("Could not obtain events from GET %s", uri), e);
                                return Mono.just(Events.builder().build());
                            }
                        );
    }

    public Flux<Event> getEvents(String id, String[] types) {
        return Flux
                .fromArray(types)
                .concatMap(type -> getEvents(id, type))
                .flatMap(this::toFlux)
                .onBackpressureBuffer();
    }

    public Mono<Boolean> isDormantApplication(AppDetail detail, int daysSinceLastUpdate) {
        if (daysSinceLastUpdate == -1) {
            return Mono.just(Boolean.TRUE);
        } else {
            return getEvents(detail.getAppId(), 1)
                    .flatMap(
                            envelope -> envelope.hasNoEvents()
                            ? isDormant(detail.getLastPushed(), daysSinceLastUpdate)
                                    : toFlux(envelope)
                                    .filter(event -> ChronoUnit.DAYS.between(event.getTime(), LocalDateTime.now()) >= daysSinceLastUpdate)
                                    .collect(Collectors.toList())
                                    .map(list -> list.size() > 0)
                            );
        }
    }

    public Mono<Boolean> isDormantServiceInstance(ServiceInstanceDetail detail, int daysSinceLastUpdate) {
        if (daysSinceLastUpdate == -1) {
            return Mono.just(Boolean.TRUE);
        } else {
            return getEvents(detail.getServiceInstanceId(), 1)
                    .flatMap(
                            envelope -> envelope.hasNoEvents()
                            ? isDormant(detail.getLastUpdated(), daysSinceLastUpdate)
                                    : toFlux(envelope)
                                    .filter(event -> ChronoUnit.DAYS.between(event.getTime(), LocalDateTime.now()) >= daysSinceLastUpdate)
                                    .collect(Collectors.toList())
                                    .map(list -> list.size() > 0)
                            );
        }
    }

    public Flux<Event> toFlux(Events envelope) {
        return
                Flux
                .fromIterable(envelope.getResources())
                .map(Resource::getEntity)
                .map(entity -> Event
                        .builder()
                        .type(entity.getType())
                        .actee(entity.getActee())
                        .actor(entity.getActor())
                        .time(
                                entity.getTimestamp() != null
                                ? LocalDateTime.ofInstant(entity.getTimestamp(), ZoneOffset.UTC)
                                        : null)
                        .build()
                        );
    }

    private Integer getPageSize(Integer numberOfEvents) {
        Integer result = EVENTS_PER_PAGE;
        if (numberOfEvents != null) {
            result = numberOfEvents;
        }
        Assert.isTrue(result > 0, "Number of events requested must be greater than zero!");
        Assert.isTrue(result <= MAX_NUMBER_OF_EVENTS, String.format("The maximum number of events that may be requested is %d!", MAX_NUMBER_OF_EVENTS));
        return result;
    }

    private Mono<Boolean> isDormant(LocalDateTime dateTime, int daysSinceLastUpdate) {
        Mono<Boolean> result = Mono.just(Boolean.TRUE);
        if (dateTime != null) {
            result = Mono.just(ChronoUnit.DAYS.between(dateTime, LocalDateTime.now()) >= daysSinceLastUpdate);
        }
        return result;
    }

}


================================================
File: src/main/java/org/cftoolsuite/cfapp/service/HistoricalRecordService.java
================================================
package org.cftoolsuite.cfapp.service;

import java.time.LocalDate;

import org.cftoolsuite.cfapp.domain.HistoricalRecord;

import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

public interface HistoricalRecordService {

    Flux<HistoricalRecord> findAll();
    Flux<HistoricalRecord> findByDateRange(LocalDate start, LocalDate end);
    Mono<HistoricalRecord> save(HistoricalRecord entity);
}


================================================
File: src/main/java/org/cftoolsuite/cfapp/service/JavaAppDetailService.java
================================================
package org.cftoolsuite.cfapp.service;

import java.util.Map;

import org.cftoolsuite.cfapp.domain.JavaAppDetail;

import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

public interface JavaAppDetailService {

    Mono<Void> deleteAll();

    Flux<JavaAppDetail> findAll();

    public Flux<Map<String, String>> findSpringApplications();

    Mono<Map<String, Integer>> calculateSpringDependencyFrequency();

    Mono<JavaAppDetail> findByAppId(String appId);

    Mono<JavaAppDetail> save(JavaAppDetail entity);
}


================================================
File: src/main/java/org/cftoolsuite/cfapp/service/JavaArtifactRuntimeMetadataRetrievalService.java
================================================
package org.cftoolsuite.cfapp.service;

import java.util.Set;
import java.util.stream.Collectors;

import org.cftoolsuite.cfapp.domain.AppDetail;
import org.cftoolsuite.cfapp.domain.JavaAppDetail;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
import org.springframework.core.ParameterizedTypeReference;
import org.springframework.stereotype.Service;
import org.springframework.util.Assert;
import org.springframework.web.reactive.function.client.WebClient;
import org.springframework.web.util.UriComponentsBuilder;

import io.jsonwebtoken.lang.Collections;
import lombok.extern.slf4j.Slf4j;
import reactor.core.publisher.Mono;

@Service
@Slf4j
@ConditionalOnProperty(prefix = "java.artifacts.fetch", name= "mode", havingValue="obtain-jars-from-runtime-metadata")
public class JavaArtifactRuntimeMetadataRetrievalService {

    private final WebClient webClient;

    @Autowired
    public JavaArtifactRuntimeMetadataRetrievalService(
            WebClient webClient) {
        this.webClient = webClient;
    }

    public Mono<JavaAppDetail> obtainRuntimeMetadata(AppDetail detail) {
        Assert.state(
            detail != null && !Collections.isEmpty(detail.getUrls()),
            String.format("A route must be defined for %s/%s/%s in order to obtain runtime metadata",
                detail.getOrganization(), detail.getSpace(), detail.getAppName()));
        String route = detail.getUrls().get(0);
        final String uri =
            UriComponentsBuilder
                .newInstance()
                .scheme("https")
                .host(route)
                .path("/actuator/jars")
                .encode()
                .toUriString();
        log.trace("Attempting to fetch runtime metadata for {}/{}/{} with GET {}", detail.getOrganization(), detail.getSpace(), detail.getAppName(), route);
        return
            webClient
                .get()
                .uri(uri)
                .retrieve()
                .onStatus(
                    status -> status.isError(),
                    response -> Mono.error(new RuntimeException("Client or Server error")))
                .bodyToMono(new ParameterizedTypeReference<Set<String>>(){})
                .map(set -> set.stream().collect(Collectors.joining(System.getProperty("line.separator"))))
                .map(jars -> JavaAppDetail.from(detail).jars(jars).build())
                .onErrorResume(e -> {
                    log.error("Error fetching runtime metadata for {}/{}/{}: {}", detail.getOrganization(), detail.getSpace(), detail.getAppName(), e.getMessage());
                    return Mono.just(JavaAppDetail.from(detail).build());
                });
    }

}


================================================
File: src/main/java/org/cftoolsuite/cfapp/service/LegacyWorkloadsService.java
================================================
package org.cftoolsuite.cfapp.service;

import java.util.List;

import org.cftoolsuite.cfapp.domain.AppDetail;
import org.cftoolsuite.cfapp.domain.AppRelationship;
import org.cftoolsuite.cfapp.domain.LegacyPolicy;
import org.cftoolsuite.cfapp.domain.WorkloadsFilter;
import org.cftoolsuite.cfapp.util.PolicyFilter;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

@Service
public class LegacyWorkloadsService {

    private final SnapshotService snapshotService;
    private final PolicyFilter filter;

    @Autowired
    public LegacyWorkloadsService(
            SnapshotService snapshotService,
            PolicyFilter filter
            ) {
        this.snapshotService = snapshotService;
        this.filter = filter;
    }

    public Mono<List<AppRelationship>> getLegacyApplicationRelationships(LegacyPolicy policy) {
        return snapshotService
                .assembleSnapshotDetail()
                .flatMapMany(sd -> Flux.fromIterable(sd.getApplicationRelationships()))
                .filter(app -> filter.isWhitelisted(policy, app.getOrganization()))
                .filter(app -> filter.isBlacklisted(app.getOrganization(), app.getSpace()))
                .filter(app -> app.getServiceOffering()!=null ? policy.getServiceOfferings().contains(app.getServiceOffering()):false)
                .collectList();
    }

    public Mono<List<AppRelationship>> getLegacyApplicationRelationships(WorkloadsFilter workloadsFilter) {
        return getLegacyApplicationRelationships(LegacyPolicy.builder().serviceOfferings(workloadsFilter.getServiceOfferings()).build());
    }

    public Mono<List<AppDetail>> getLegacyApplications(LegacyPolicy policy) {
        return snapshotService
                .assembleSnapshotDetail()
                .flatMapMany(sd -> Flux.fromIterable(sd.getApplications()))
                .filter(app -> filter.isWhitelisted(policy, app.getOrganization()))
                .filter(app -> filter.isBlacklisted(app.getOrganization(), app.getSpace()))
                .filter(app -> policy.getStacks().contains(app.getStack()))
                .collectList();
    }

    public Mono<List<AppDetail>> getLegacyApplications(WorkloadsFilter workloadsFilter) {
        return getLegacyApplications(LegacyPolicy.builder().stacks(workloadsFilter.getStacks()).build());
    }   

}


================================================
File: src/main/java/org/cftoolsuite/cfapp/service/OrganizationService.java
================================================
package org.cftoolsuite.cfapp.service;

import org.cftoolsuite.cfapp.domain.Organization;

import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

public interface OrganizationService {

    Mono<Void> deleteAll();

    Flux<Organization> findAll();

    Mono<Organization> save(Organization entity);

}


================================================
File: src/main/java/org/cftoolsuite/cfapp/service/PoliciesService.java
================================================
package org.cftoolsuite.cfapp.service;

import java.util.Map;

import org.cftoolsuite.cfapp.domain.ApplicationOperation;
import org.cftoolsuite.cfapp.domain.Policies;
import org.cftoolsuite.cfapp.domain.ServiceInstanceOperation;
import org.cftoolsuite.cfapp.task.PolicyExecutorTask;

import reactor.core.publisher.Mono;

public interface PoliciesService {

    Mono<Void> deleteAll();
    Mono<Void> deleteApplicationPolicyById(String id);
    Mono<Void> deleteEndpointPolicyById(String id);
    Mono<Void> deleteHygienePolicyById(String id);
    Mono<Void> deleteResourceNotificationPolicyById(String id);
    Mono<Void> deleteLegacyPolicyById(String id);
    Mono<Void> deleteQueryPolicyById(String id);
    Mono<Void> deleteServiceInstancePolicyById(String id);
    Mono<Policies> findAll();
    Mono<Policies> findAllEndpointPolicies();
    Mono<Policies> findAllHygienePolicies();
    Mono<Policies> findAllResourceNotificationPolicies();
    Mono<Policies> findAllLegacyPolicies();
    Mono<Policies> findAllQueryPolicies();
    Mono<Policies> findApplicationPolicyById(String id);
    Mono<Policies> findByApplicationOperation(ApplicationOperation operation);
    Mono<Policies> findByServiceInstanceOperation(ServiceInstanceOperation operation);
    Mono<Policies> findEndpointPolicyById(String id);
    Mono<Policies> findHygienePolicyById(String id);
    Mono<Policies> findResourceNotificationPolicyById(String id);
    Mono<Policies> findLegacyPolicyById(String id);
    Mono<Policies> findQueryPolicyById(String id);
    Mono<Policies> findServiceInstancePolicyById(String id);
    Mono<Policies> save(Policies entity);
    Mono<Map<String, Class<? extends PolicyExecutorTask>>> getTaskMap();
}


================================================
File: src/main/java/org/cftoolsuite/cfapp/service/ProductMetricsService.java
================================================
package org.cftoolsuite.cfapp.service;

import java.util.List;
import java.util.function.Predicate;
import java.util.stream.Collectors;

import org.cftoolsuite.cfapp.client.OpsmanClient;
import org.cftoolsuite.cfapp.domain.product.PivnetCache;
import org.cftoolsuite.cfapp.domain.product.ProductMetric;
import org.cftoolsuite.cfapp.domain.product.ProductMetrics;
import org.cftoolsuite.cfapp.domain.product.ProductType;
import org.cloudfoundry.operations.DefaultCloudFoundryOperations;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.autoconfigure.condition.ConditionalOnExpression;
import org.springframework.stereotype.Service;

import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

@Service
@ConditionalOnExpression(
    "${om.enabled:false} and ${pivnet.enabled:false}"
)
public class ProductMetricsService {

    private final PivnetCache pivnetCache;
    private final OpsmanClient opsmanClient;
    private final DefaultCloudFoundryOperations cfClient;

    @Autowired
    public ProductMetricsService(
            PivnetCache pivnetCache,
            OpsmanClient opsmanClient,
            DefaultCloudFoundryOperations cfClient
            ) {
        this.pivnetCache = pivnetCache;
        this.opsmanClient = opsmanClient;
        this.cfClient = cfClient;
    }

    protected Flux<ProductMetric> getBuildpacks() {
        return cfClient
                .buildpacks()
                .list()
                .flatMap(b ->
                    Mono.justOrEmpty(
                        ProductMetric
                            .builder()
                            .name(refineName(b.getName()))
                            .currentlyInstalledVersion(obtainVersionFromBuildpackFilename(b.getFilename()))
                            .currentlyInstalledReleaseDate(
                                pivnetCache
                                    .findProductReleaseBySlugAndVersion(
                                        refineName(b.getName()), obtainVersionFromBuildpackFilename(b.getFilename())
                                    )
                                    .getReleaseDate()
                            )
                            .latestAvailableVersion(
                                pivnetCache
                                    .findLatestProductReleaseBySlug(
                                        refineName(b.getName())
                                    )
                                    .getVersion()
                            )
                            .latestAvailableReleaseDate(
                                pivnetCache
                                    .findLatestProductReleaseBySlug(
                                        refineName(b.getName())
                                    )
                                    .getReleaseDate()
                            )
                            .type(ProductType.from(refineName(b.getName())))
                            .endOfSupportDate(
                                pivnetCache
                                    .findProductReleaseBySlugAndVersion(
                                        refineName(b.getName()), obtainVersionFromBuildpackFilename(b.getFilename())
                                    )
                                    .getEndOfSupportDate()
                            )
                            .build()
                    )
                );
    }

    public Mono<ProductMetrics> getProductMetrics() {
        return Flux
                .concat(getTiles(), getBuildpacks(), getStemcells())
                .distinct()
                .collect(Collectors.toSet())
                .map(metrics ->
                        ProductMetrics
                            .builder()
                            .productMetrics(metrics)
                            .build()
                );
    }

    protected Flux<ProductMetric> getStemcells() {
        return opsmanClient
                .getStemcellAssociations()
                .flatMapMany(associations -> Flux.fromIterable(associations.getProducts()))
                .filter(sa -> sa.getDeployedStemcells().size() > 0)
                .map(sa ->
                    ProductMetric
                        .builder()
                        .name(String.format("%s:%s:%s", refineType(sa.getIdentifier()), sa.getDeployedProductVersion(), sa.getDeployedStemcells().get(0).getOs()))
                        .currentlyInstalledVersion(sa.getDeployedStemcells().get(0).getVersion())
                        .currentlyInstalledReleaseDate(
                            pivnetCache
                                .findProductReleaseBySlugAndVersion(
                                    refineType("stemcells-" + sa.getDeployedStemcells().get(0).getOs()), sa.getDeployedStemcells().get(0).getVersion()
                                )
                                .getReleaseDate()
                        )
                        .latestAvailableVersion(
                            pivnetCache
                                .findLatestMinorProductReleaseBySlugAndVersion(
                                    refineType("stemcells-" + sa.getDeployedStemcells().get(0).getOs()), sa.getDeployedStemcells().get(0).getVersion()
                                )
                                .getVersion()
                        )
                        .latestAvailableReleaseDate(
                            pivnetCache
                                .findLatestMinorProductReleaseBySlugAndVersion(
                                    refineType("stemcells-" + sa.getDeployedStemcells().get(0).getOs()), sa.getDeployedStemcells().get(0).getVersion()
                                )
                                .getReleaseDate()
                        )
                        .type(ProductType.STEMCELL)
                        .endOfSupportDate(
                            pivnetCache
                                .findProductReleaseBySlugAndVersion(
                                    refineType("stemcells-" + sa.getDeployedStemcells().get(0).getOs()), sa.getDeployedStemcells().get(0).getVersion()
                                )
                                .getEndOfSupportDate()
                        )
                        .build()
                )
                .filter(productExclusions());
    }

    protected Flux<ProductMetric> getTiles() {
        return opsmanClient
                .getDeployedProducts()
                .flatMapIterable(products -> products)
                .map(deployedProduct ->
                    ProductMetric
                        .builder()
                        .name(refineType(deployedProduct.getType()))
                        .currentlyInstalledVersion(deployedProduct.getProductVersion())
                        .currentlyInstalledReleaseDate(
                            pivnetCache
                                .findProductReleaseBySlugAndVersion(
                                    refineType(deployedProduct.getType()), deployedProduct.getProductVersion()
                                )
                                .getReleaseDate()
                        )
                        .latestAvailableVersion(
                            pivnetCache
                                .findLatestProductReleaseBySlug(
                                    refineType(deployedProduct.getType())
                                )
                                .getVersion()
                        )
                        .latestAvailableReleaseDate(
                            pivnetCache
                                .findLatestProductReleaseBySlug(
                                    refineType(deployedProduct.getType())
                                )
                                .getReleaseDate()
                        )
                        .type(ProductType.from(refineType(deployedProduct.getType())))
                        .endOfSupportDate(
                            pivnetCache
                                .findProductReleaseBySlugAndVersion(
                                    refineType(deployedProduct.getType()), deployedProduct.getProductVersion()
                                )
                                .getEndOfSupportDate()
                        )
                        .build()
                )
                .filter(productExclusions());
    }

    private static final List<String> EXCLUDES = List.of("p-bosh");

    private static String obtainVersionFromBuildpackFilename(String filename) {
        String rawVersion = filename.substring(filename.lastIndexOf("-") + 1);
        return rawVersion.replaceAll(".zip", "").replaceAll("v", "");
    }

    private static Predicate<ProductMetric> productExclusions() {
        return productMetric -> EXCLUDES.stream().filter(e -> productMetric.getName().startsWith(e)).collect(Collectors.toList()).isEmpty();
    }

    private static String refineName(String value) {
        return value.replaceAll("_", "-").replaceAll("-offline", "");
    }

    private static String refineType(String value) {
        String normalizedValue = value.replaceAll("_", "-");
        if (normalizedValue.startsWith("apm") || normalizedValue.startsWith("appMetrics")) {
            return "apm";
        } else if (normalizedValue.startsWith("cf")) {
            return "elastic-runtime";
        } else if (normalizedValue.startsWith("metric-store")) {
            return "p-metric-store";
        } else if (normalizedValue.startsWith("p-healthwatch2")) {
            return "p-healthwatch";
        } else if (normalizedValue.startsWith("stemcells-windows")) {
            return "stemcells-windows-server";
        }
        return normalizedValue;
    }

}


================================================
File: src/main/java/org/cftoolsuite/cfapp/service/QueryService.java
================================================
package org.cftoolsuite.cfapp.service;

import org.cftoolsuite.cfapp.domain.Query;

import io.r2dbc.spi.Row;
import io.r2dbc.spi.RowMetadata;
import reactor.core.publisher.Flux;
import reactor.util.function.Tuple2;

public interface QueryService {

    Flux<Tuple2<Row, RowMetadata>> executeQuery(Query query);
}


================================================
File: src/main/java/org/cftoolsuite/cfapp/service/R2dbcAppDetailService.java
================================================
package org.cftoolsuite.cfapp.service;

import java.time.LocalDate;

import org.cftoolsuite.cfapp.domain.AppDetail;
import org.cftoolsuite.cfapp.domain.ApplicationPolicy;
import org.cftoolsuite.cfapp.repository.R2dbcAppDetailRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import lombok.extern.slf4j.Slf4j;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;
import reactor.util.function.Tuple2;

@Slf4j
@Service
public class R2dbcAppDetailService implements AppDetailService {

    private R2dbcAppDetailRepository repo;

    @Autowired
    public R2dbcAppDetailService(R2dbcAppDetailRepository repo) {
        this.repo = repo;
    }

    @Override
    @Transactional
    public Mono<Void> deleteAll() {
        return repo.deleteAll();
    }

    @Override
    public Flux<AppDetail> findAll() {
        return repo.findAll();
    }

    @Override
    public Mono<AppDetail> findByAppId(String appId) {
        return repo.findByAppId(appId);
    }

    @Override
    public Flux<Tuple2<AppDetail, ApplicationPolicy>> findByApplicationPolicy(ApplicationPolicy policy, boolean mayHaveServiceBindings) {
        return repo.findByApplicationPolicy(policy, mayHaveServiceBindings);
    }

    @Override
    public Flux<AppDetail> findByDateRange(LocalDate start, LocalDate end) {
        return repo.findByDateRange(start, end);
    }

    @Override
    @Transactional
    public Mono<AppDetail> save(AppDetail entity) {
        return repo
                .save(entity)
                .onErrorContinue(
                        (ex, data) -> log.error(String.format("Problem saving application %s.", entity), ex));
    }

}


================================================
File: src/main/java/org/cftoolsuite/cfapp/service/R2dbcAppMetricsService.java
================================================
package org.cftoolsuite.cfapp.service;

import org.cftoolsuite.cfapp.repository.R2dbcAppMetricsRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;
import reactor.util.function.Tuple2;

@Service
public class R2dbcAppMetricsService implements AppMetricsService {

    private final R2dbcAppMetricsRepository repo;

    @Autowired
    public R2dbcAppMetricsService(R2dbcAppMetricsRepository repo) {
        this.repo = repo;
    }

    @Override
    public Flux<Tuple2<String, Long>> byBuildpack() {
        return repo.byBuildpack();
    }

    @Override
    public Flux<Tuple2<String, Long>> byDockerImage() {
        return repo.byDockerImage();
    }

    @Override
    public Flux<Tuple2<String, Long>> byOrganization() {
        return repo.byOrganization();
    }

    @Override
    public Flux<Tuple2<String, Long>> byStack() {
        return repo.byStack();
    }

    @Override
    public Flux<Tuple2<String, Long>> byStatus() {
        return repo.byStatus();
    }

    @Override
    public Mono<Long> totalApplicationInstances() {
        return repo.totalApplicationInstances();
    }

    @Override
    public Mono<Long> totalApplications() {
        return repo.totalApplications();
    }

    @Override
    public Mono<Long> totalCrashedApplicationInstances() {
        return repo.totalCrashedApplicationInstances();
    }

    @Override
    public Mono<Double> totalDiskUsed() {
        return repo.totalDiskUsed();
    }

    @Override
    public Mono<Double> totalMemoryUsed() {
        return repo.totalMemoryUsed();
    }

    @Override
    public Mono<Long> totalRunningApplicationInstances() {
        return repo.totalRunningApplicationInstances();
    }

    @Override
    public Mono<Long> totalStoppedApplicationInstances() {
        return repo.totalStoppedApplicationInstances();
    }

    @Override
    public Flux<Tuple2<String, Long>> totalVelocity() {
        return repo.totalVelocity();
    }

}


================================================
File: src/main/java/org/cftoolsuite/cfapp/service/R2dbcAppRelationshipService.java
================================================
package org.cftoolsuite.cfapp.service;

import org.cftoolsuite.cfapp.domain.AppRelationship;
import org.cftoolsuite.cfapp.repository.R2dbcAppRelationshipRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import lombok.extern.slf4j.Slf4j;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

@Slf4j
@Service
public class R2dbcAppRelationshipService implements AppRelationshipService {

    private R2dbcAppRelationshipRepository repo;

    @Autowired
    public R2dbcAppRelationshipService(R2dbcAppRelationshipRepository repo) {
        this.repo = repo;
    }

    @Override
    @Transactional
    public Mono<Void> deleteAll() {
        return repo.deleteAll();
    }

    @Override
    public Flux<AppRelationship> findAll() {
        return repo.findAll();
    }

    @Override
    public Flux<AppRelationship> findByApplicationId(String applicationId) {
        return repo.findByApplicationId(applicationId);
    }

    @Override
    public Flux<AppRelationship> findByServiceInstanceId(String serviceInstanceId) {
        return repo.findByServiceInstanceId(serviceInstanceId);
    }

    @Override
    @Transactional
    public Mono<AppRelationship> save(AppRelationship entity) {
        return repo
                .save(entity)
                .onErrorContinue(
                        (ex, data) -> log.error(String.format("Problem saving application relationship %s.", entity), ex));
    }

}


================================================
File: src/main/java/org/cftoolsuite/cfapp/service/R2dbcHistoricalRecordService.java
================================================
package org.cftoolsuite.cfapp.service;

import java.time.LocalDate;

import org.cftoolsuite.cfapp.domain.HistoricalRecord;
import org.cftoolsuite.cfapp.repository.R2dbcHistoricalRecordRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import lombok.extern.slf4j.Slf4j;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

@Slf4j
@Service
public class R2dbcHistoricalRecordService implements HistoricalRecordService {

    private final R2dbcHistoricalRecordRepository repo;

    @Autowired
    public R2dbcHistoricalRecordService(R2dbcHistoricalRecordRepository repo) {
        this.repo = repo;
    }

    @Override
    public Flux<HistoricalRecord> findAll() {
        return repo.findAll();
    }

    @Override
    public Flux<HistoricalRecord> findByDateRange(LocalDate start, LocalDate end) {
        return repo.findByDateRange(start, end);
    }

    @Override
    @Transactional
    public Mono<HistoricalRecord> save(HistoricalRecord entity) {
        return repo
                .save(entity)
                .onErrorContinue(
                        (ex, data) -> log.error(String.format("Problem saving historical record %s.", entity), ex));
    }

}


================================================
File: src/main/java/org/cftoolsuite/cfapp/service/R2dbcJavaAppDetailService.java
================================================
package org.cftoolsuite.cfapp.service;

import java.util.Arrays;
import java.util.Map;
import java.util.function.Function;
import java.util.stream.Collectors;

import org.apache.commons.lang3.StringUtils;
import org.cftoolsuite.cfapp.domain.JavaAppDetail;
import org.cftoolsuite.cfapp.repository.R2dbcJavaAppDetailRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import lombok.extern.slf4j.Slf4j;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

@Slf4j
@Service
public class R2dbcJavaAppDetailService implements JavaAppDetailService {

    private R2dbcJavaAppDetailRepository repo;

    @Autowired
    public R2dbcJavaAppDetailService(R2dbcJavaAppDetailRepository repo) {
        this.repo = repo;
    }

    @Override
    @Transactional
    public Mono<Void> deleteAll() {
        return repo.deleteAll();
    }

    @Override
    public Flux<JavaAppDetail> findAll() {
        return repo.findAll();
    }

    @Override
    public Flux<Map<String, String>> findSpringApplications() {
        return repo
                .findAll()
                .filter(jad -> StringUtils.isNotBlank(jad.getSpringDependencies()))
                .map(jad ->
                    Map.of("organization", jad.getOrganization(),
                        "space", jad.getSpace(),
                        "appId", jad.getAppId(),
                        "appName", jad.getAppName(),
                        "dropletId", jad.getDropletId(),
                        "springDependencies", jad.getSpringDependencies().replace("\n", ", ")
                    )
                );
    }

    public Mono<Map<String, Integer>> calculateSpringDependencyFrequency() {
        return findSpringApplications()
                .flatMapIterable(map -> Arrays.asList(map.get("springDependencies").split(",\\s*")))
                .collect(Collectors.groupingBy(Function.identity(), Collectors.reducing(0, e -> 1, Integer::sum)));
    }

    @Override
    public Mono<JavaAppDetail> findByAppId(String appId) {
        return repo.findByAppId(appId);
    }

    @Override
    @Transactional
    public Mono<JavaAppDetail> save(JavaAppDetail entity) {
        return repo
                .save(entity)
                .onErrorContinue(
                        (ex, data) -> log.error(String.format("Problem saving Java application %s.", entity), ex));
    }

}


================================================
File: src/main/java/org/cftoolsuite/cfapp/service/R2dbcOrganizationService.java
================================================
package org.cftoolsuite.cfapp.service;

import org.cftoolsuite.cfapp.domain.Organization;
import org.cftoolsuite.cfapp.repository.R2dbcOrganizationRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import lombok.extern.slf4j.Slf4j;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

@Slf4j
@Service
public class R2dbcOrganizationService implements OrganizationService {

    private final R2dbcOrganizationRepository repo;

    @Autowired
    public R2dbcOrganizationService(R2dbcOrganizationRepository repo) {
        this.repo = repo;
    }

    @Override
    @Transactional
    public Mono<Void> deleteAll() {
        return repo.deleteAll();
    }

    @Override
    public Flux<Organization> findAll() {
        return repo.findAll();
    }

    @Override
    @Transactional
    public Mono<Organization> save(Organization entity) {
        return repo
                .save(entity)
                .onErrorContinue(
                        (ex, data) -> log.error(String.format("Problem saving organization %s.", entity), ex));
    }
}


================================================
File: src/main/java/org/cftoolsuite/cfapp/service/R2dbcPoliciesService.java
================================================
package org.cftoolsuite.cfapp.service;

import java.util.HashMap;
import java.util.Map;

import org.cftoolsuite.cfapp.config.GitSettings;
import org.cftoolsuite.cfapp.domain.ApplicationOperation;
import org.cftoolsuite.cfapp.domain.ApplicationPolicy;
import org.cftoolsuite.cfapp.domain.EndpointPolicy;
import org.cftoolsuite.cfapp.domain.HygienePolicy;
import org.cftoolsuite.cfapp.domain.LegacyPolicy;
import org.cftoolsuite.cfapp.domain.Policies;
import org.cftoolsuite.cfapp.domain.QueryPolicy;
import org.cftoolsuite.cfapp.domain.ResourceNotificationPolicy;
import org.cftoolsuite.cfapp.domain.ServiceInstanceOperation;
import org.cftoolsuite.cfapp.domain.ServiceInstancePolicy;
import org.cftoolsuite.cfapp.repository.R2dbcPoliciesRepository;
import org.cftoolsuite.cfapp.task.EndpointPolicyExecutorTask;
import org.cftoolsuite.cfapp.task.HygienePolicyExecutorTask;
import org.cftoolsuite.cfapp.task.LegacyWorkloadReportingTask;
import org.cftoolsuite.cfapp.task.PolicyExecutorTask;
import org.cftoolsuite.cfapp.task.QueryPolicyExecutorTask;
import org.cftoolsuite.cfapp.task.ResourceNotificationPolicyExecutorTask;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

@Service
public class R2dbcPoliciesService implements PoliciesService {

    private static final String UNSUPPORTED_OP_MESSAGE = "Policies are managed in a git repository.";

    private final R2dbcPoliciesRepository repo;
    private final GitSettings settings;

    public R2dbcPoliciesService(
            R2dbcPoliciesRepository repo,
            GitSettings settings) {
        this.repo = repo;
        this.settings = settings;
    }

    @Override
    @Transactional
    public Mono<Void> deleteAll() {
        return repo.deleteAll();
    }

    @Override
    @Transactional
    public Mono<Void> deleteApplicationPolicyById(String id) {
        if (settings.isVersionManaged()) {
            throw new UnsupportedOperationException(UNSUPPORTED_OP_MESSAGE);
        }
        return repo.deleteApplicationPolicyById(id);
    }

    @Override
    @Transactional
    public Mono<Void> deleteEndpointPolicyById(String id) {
        if (settings.isVersionManaged()) {
            throw new UnsupportedOperationException(UNSUPPORTED_OP_MESSAGE);
        }
        return repo.deleteEndpointPolicyById(id);
    }

    @Override
    @Transactional
    public Mono<Void> deleteHygienePolicyById(String id) {
        if (settings.isVersionManaged()) {
            throw new UnsupportedOperationException(UNSUPPORTED_OP_MESSAGE);
        }
        return repo.deleteHygienePolicyById(id);
    }

    @Override
    @Transactional
    public Mono<Void> deleteResourceNotificationPolicyById(String id) {
        if (settings.isVersionManaged()) {
            throw new UnsupportedOperationException(UNSUPPORTED_OP_MESSAGE);
        }
        return repo.deleteResourceNotificationPolicyById(id);
    }

    @Override
    @Transactional
    public Mono<Void> deleteLegacyPolicyById(String id) {
        if (settings.isVersionManaged()) {
            throw new UnsupportedOperationException(UNSUPPORTED_OP_MESSAGE);
        }
        return repo.deleteLegacyPolicyById(id);
    }

    @Override
    @Transactional
    public Mono<Void> deleteQueryPolicyById(String id) {
        if (settings.isVersionManaged()) {
            throw new UnsupportedOperationException(UNSUPPORTED_OP_MESSAGE);
        }
        return repo.deleteQueryPolicyById(id);
    }

    @Override
    @Transactional
    public Mono<Void> deleteServiceInstancePolicyById(String id) {
        if (settings.isVersionManaged()) {
            throw new UnsupportedOperationException(UNSUPPORTED_OP_MESSAGE);
        }
        return repo.deleteServiceInstancePolicyById(id);
    }

    @Override
    public Mono<Policies> findAll() {
        return repo.findAll();
    }

    @Override
    public Mono<Policies> findAllEndpointPolicies() {
        return repo.findAllEndpointPolicies();
    }

    @Override
    public Mono<Policies> findAllHygienePolicies() {
        return repo.findAllHygienePolicies();
    }

    @Override
    public Mono<Policies> findAllResourceNotificationPolicies() {
        return repo.findAllResourceNotificationPolicies();
    }

    @Override
    public Mono<Policies> findAllLegacyPolicies() {
        return repo.findAllLegacyPolicies();
    }

    @Override
    public Mono<Policies> findAllQueryPolicies() {
        return repo.findAllQueryPolicies();
    }

    @Override
    public Mono<Policies> findApplicationPolicyById(String id) {
        return repo.findApplicationPolicyById(id);
    }

    @Override
    public Mono<Policies> findByApplicationOperation(ApplicationOperation operation) {
        return repo.findByApplicationOperation(operation);
    }

    @Override
    public Mono<Policies> findByServiceInstanceOperation(ServiceInstanceOperation operation) {
        return repo.findByServiceInstanceOperation(operation);
    }

    @Override
    public Mono<Policies> findEndpointPolicyById(String id) {
        return repo.findEndpointPolicyById(id);
    }

    @Override
    public Mono<Policies> findHygienePolicyById(String id) {
        return repo.findHygienePolicyById(id);
    }

    @Override
    public Mono<Policies> findResourceNotificationPolicyById(String id) {
        return repo.findResourceNotificationPolicyById(id);
    }

    @Override
    public Mono<Policies> findLegacyPolicyById(String id) {
        return repo.findLegacyPolicyById(id);
    }

    @Override
    public Mono<Policies> findQueryPolicyById(String id) {
        return repo.findQueryPolicyById(id);
    }

    @Override
    public Mono<Policies> findServiceInstancePolicyById(String id) {
        return repo.findServiceInstancePolicyById(id);
    }

    @Override
    @Transactional
    public Mono<Policies> save(Policies entity) {
        return repo.save(entity);
    }

    @Override
    public Mono<Map<String, Class<? extends PolicyExecutorTask>>> getTaskMap() {
        Mono<Policies> policiesMono = repo.findAll();
        Flux<Map<String, Class<? extends PolicyExecutorTask>>> mapsFlux = Flux.merge(
            policiesMono
                .flatMapMany(p -> Flux.fromIterable(p.getApplicationPolicies()))
                .collectMap(ApplicationPolicy::getId, ap -> ApplicationOperation.getTaskType(ap.getOperation())),
            policiesMono
                .flatMapMany(p -> Flux.fromIterable(p.getEndpointPolicies()))
                .collectMap(EndpointPolicy::getId, ep -> EndpointPolicyExecutorTask.class),
            policiesMono
                .flatMapMany(p -> Flux.fromIterable(p.getHygienePolicies()))
                .collectMap(HygienePolicy::getId, hp -> HygienePolicyExecutorTask.class),
            policiesMono
                .flatMapMany(p -> Flux.fromIterable(p.getLegacyPolicies()))
                .collectMap(LegacyPolicy::getId, lp -> LegacyWorkloadReportingTask.class),
            policiesMono
                .flatMapMany(p -> Flux.fromIterable(p.getQueryPolicies()))
                .collectMap(QueryPolicy::getId, qp -> QueryPolicyExecutorTask.class),
            policiesMono
                .flatMapMany(p -> Flux.fromIterable(p.getResourceNotificationPolicies()))
                .collectMap(ResourceNotificationPolicy::getId, rnp -> ResourceNotificationPolicyExecutorTask.class),
            policiesMono
                .flatMapMany(p -> Flux.fromIterable(p.getServiceInstancePolicies()))
                .collectMap(ServiceInstancePolicy::getId, sip -> ServiceInstanceOperation.getTaskType(sip.getOperation()))
        );
        return
            mapsFlux
                .reduce(
                    new HashMap<String, Class<? extends PolicyExecutorTask>>(), (acc, map) -> {
                        acc.putAll(map);
                        return acc;
                    }
                );
    }

}


================================================
File: src/main/java/org/cftoolsuite/cfapp/service/R2dbcQueryService.java
================================================
package org.cftoolsuite.cfapp.service;

import org.cftoolsuite.cfapp.domain.Query;
import org.cftoolsuite.cfapp.repository.R2dbcQueryRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import io.r2dbc.spi.Row;
import io.r2dbc.spi.RowMetadata;
import lombok.extern.slf4j.Slf4j;
import reactor.core.publisher.Flux;
import reactor.util.function.Tuple2;

@Slf4j
@Service
public class R2dbcQueryService implements QueryService {

    private final R2dbcQueryRepository repo;

    @Autowired
    public R2dbcQueryService(R2dbcQueryRepository repo) {
        this.repo = repo;
    }

    @Override
    @Transactional
    public Flux<Tuple2<Row, RowMetadata>> executeQuery(Query query) {
        log.trace(String.format("Attempting to execute a query named [ %s ] and the statement is [ %s ]", query.getName(), query.getSql()));
        return repo
                .executeQuery(query)
                .onErrorContinue(
                        (ex, data) -> log.error(String.format("Problem executing query %s.", query.getSql()), ex));
    }
}


================================================
File: src/main/java/org/cftoolsuite/cfapp/service/R2dbcServiceInstanceDetailService.java
================================================
package org.cftoolsuite.cfapp.service;

import java.time.LocalDate;

import org.cftoolsuite.cfapp.domain.ServiceInstanceDetail;
import org.cftoolsuite.cfapp.domain.ServiceInstancePolicy;
import org.cftoolsuite.cfapp.repository.R2dbcServiceInstanceDetailRepository;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import lombok.extern.slf4j.Slf4j;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;
import reactor.util.function.Tuple2;

@Slf4j
@Service
public class R2dbcServiceInstanceDetailService implements ServiceInstanceDetailService {

    private R2dbcServiceInstanceDetailRepository repo;

    public R2dbcServiceInstanceDetailService(R2dbcServiceInstanceDetailRepository repo) {
        this.repo = repo;
    }

    @Override
    @Transactional
    public Mono<Void> deleteAll() {
        return repo.deleteAll();
    }

    @Override
    public Flux<ServiceInstanceDetail> findAll() {
        return repo.findAll();
    }

    @Override
    public Flux<ServiceInstanceDetail> findByDateRange(LocalDate start, LocalDate end) {
        return repo.findByDateRange(start, end);
    }

    @Override
    public Flux<Tuple2<ServiceInstanceDetail, ServiceInstancePolicy>> findByServiceInstancePolicy(
            ServiceInstancePolicy policy) {
        return repo.findByServiceInstancePolicy(policy);
    }

    @Override
    @Transactional
    public Mono<ServiceInstanceDetail> save(ServiceInstanceDetail entity) {
        return repo
                .save(entity)
                .onErrorContinue(
                        (ex, data) -> log.error(String.format("Problem saving service instance %s.", entity), ex));
    }

}


================================================
File: src/main/java/org/cftoolsuite/cfapp/service/R2dbcServiceInstanceMetricsService.java
================================================
package org.cftoolsuite.cfapp.service;

import org.cftoolsuite.cfapp.repository.R2dbcServiceInstanceMetricsRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;
import reactor.util.function.Tuple2;

@Service
public class R2dbcServiceInstanceMetricsService implements ServiceInstanceMetricsService {

    private final R2dbcServiceInstanceMetricsRepository repo;

    @Autowired
    public R2dbcServiceInstanceMetricsService(R2dbcServiceInstanceMetricsRepository repo) {
        this.repo = repo;
    }

    @Override
    public Flux<Tuple2<String, Long>> byOrganization() {
        return repo.byOrganization();
    }

    @Override
    public Flux<Tuple2<String, Long>> byService() {
        return repo.byService();
    }

    @Override
    public Flux<Tuple2<String, Long>> byServiceAndPlan() {
        return repo.byServiceAndPlan();
    }

    @Override
    public Mono<Long> totalServiceInstances() {
        return repo.totalServiceInstances();
    }

    @Override
    public Flux<Tuple2<String, Long>> totalVelocity() {
        return repo.totalVelocity();
    }

}


================================================
File: src/main/java/org/cftoolsuite/cfapp/service/R2dbcSpaceService.java
================================================
package org.cftoolsuite.cfapp.service;

import org.cftoolsuite.cfapp.domain.Space;
import org.cftoolsuite.cfapp.repository.R2dbcSpaceRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import lombok.extern.slf4j.Slf4j;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

@Slf4j
@Service
public class R2dbcSpaceService implements SpaceService {

    private final R2dbcSpaceRepository repo;

    @Autowired
    public R2dbcSpaceService(R2dbcSpaceRepository repo) {
        this.repo = repo;
    }

    @Override
    @Transactional
    public Mono<Void> deleteAll() {
        return repo.deleteAll();
    }

    @Override
    public Flux<Space> findAll() {
        return repo.findAll();
    }

    @Override
    @Transactional
    public Mono<Space> save(Space entity) {
        return repo
                .save(entity)
                .onErrorContinue(
                        (ex, data) -> log.error(String.format("Problem saving space %s.", entity), ex));
    }
}


================================================
File: src/main/java/org/cftoolsuite/cfapp/service/R2dbcSpaceUsersService.java
================================================
package org.cftoolsuite.cfapp.service;

import static org.cftoolsuite.cfapp.config.PasSettings.SYSTEM_ORG;

import java.util.HashMap;
import java.util.Map;
import java.util.Set;
import java.util.TreeSet;
import java.util.stream.Collectors;

import org.cftoolsuite.cfapp.domain.SpaceUsers;
import org.cftoolsuite.cfapp.domain.UserAccounts;
import org.cftoolsuite.cfapp.repository.R2dbcSpaceUsersRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import lombok.extern.slf4j.Slf4j;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

@Slf4j
@Service
public class R2dbcSpaceUsersService implements SpaceUsersService {

    private final R2dbcSpaceUsersRepository repo;
    private final AccountMatcher matcher;

    @Autowired
    public R2dbcSpaceUsersService(
            R2dbcSpaceUsersRepository repo,
            AccountMatcher matcher) {
        this.repo = repo;
        this.matcher = matcher;
    }

    private Map<String, Set<String>> addOrgUsers(Map<String, Set<String>> map, String org, Set<String> usernames) {
        if (map.get(org) != null) {
            Set<String> u = map.get(org);
            u.addAll(usernames);
            map.put(org, u);
        } else {
            map.put(org, usernames);
        }
        return map;
    }

    @Override
    public Mono<Map<String, Integer>> countByOrganization() {
        // a single user may belong to multiple orgs/spaces
        // iterate spaces collecting unique usernames, ignore assigned roles
        final Map<String, Set<String>> usernames = new HashMap<>();
        return repo
                .findAll()
                .map(su -> addOrgUsers(usernames, su.getOrganization(), su.getUsers()))
                .then(Mono.just(usernames))
                .map(this::tallyOrgUsers);

    }

    @Override
    @Transactional
    public Mono<Void> deleteAll() {
        return repo.deleteAll();
    }

    @Override
    public Flux<SpaceUsers> findAll() {
        return repo.findAll();
    }

    @Override
    public Flux<SpaceUsers> findByAccountName(String name) {
        return repo
                .findAll()
                .filter(su -> su.getUsers().contains(name));

    }

    @Override
    public Mono<SpaceUsers> findByOrganizationAndSpace(String organization, String space) {
        return repo.findByOrganizationAndSpace(organization, space);
    }

    @Override
    public Flux<String> obtainAccountNames() {
        return Flux.concat(obtainUserAccountNames(), obtainServiceAccountNames());
    }

    @Override
    public Flux<String> obtainServiceAccountNames() {
        return
                repo
                .findAll()
                .flatMap(su -> Flux.fromIterable(su.getUsers()))
                .collect(Collectors.toCollection(TreeSet::new))
                .flatMapMany(Flux::fromIterable)
                .filter(m -> !matcher.matches(m));
    }

    @Override
    public Flux<String> obtainUserAccountNames() {
        // a single user may belong to multiple orgs/spaces
        // iterate spaces collecting unique usernames
        return
                repo
                .findAll()
                .flatMap(su -> Flux.fromIterable(su.getUsers()))
                .collect(Collectors.toCollection(TreeSet::new))
                .flatMapMany(Flux::fromIterable)
                .filter(m -> matcher.matches(m));
    }

    @Override
    public Flux<UserAccounts> obtainUserAccounts() {
        return
                repo
                .findAll()
                .filter(ua -> !ua.getOrganization().equalsIgnoreCase(SYSTEM_ORG))
                .map(su -> UserAccounts
                        .builder()
                        .organization(su.getOrganization())
                        .space(su.getSpace())
                        .accounts(su.getUsers()
                                .stream()
                                .filter(u -> matcher.matches(u))
                                .collect(Collectors.toSet()))
                        .build());
    }

    @Override
    @Transactional
    public Mono<SpaceUsers> save(SpaceUsers entity) {
        return repo
                .save(entity)
                .onErrorContinue(
                        (ex, data) -> log.error(String.format("Problem saving space user %s.", entity), ex));
    }

    private Map<String, Integer> tallyOrgUsers(Map<String, Set<String>> map) {
        final Map<String, Integer> result = new HashMap<>();
        map.forEach((k, v) -> result.put(k, v.size()));
        return result;
    }

    @Override
    public Mono<Long> totalServiceAccounts() {
        return obtainServiceAccountNames().count();
    }

    @Override
    public Mono<Long> totalUserAccounts() {
        return obtainUserAccountNames().count();
    }

}


================================================
File: src/main/java/org/cftoolsuite/cfapp/service/ReportRequest.java
================================================
package org.cftoolsuite.cfapp.service;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;

import lombok.Builder;
import lombok.Getter;

@Builder
@Getter
@JsonPropertyOrder({ "foundation", "environment", "period", "filename" })
class ReportRequest {

    @JsonProperty("foundation")
    private final String foundation;
    @JsonProperty("environment")
    private final String environment;
    @JsonProperty("period")
    private final String period;
    @JsonProperty("filename")
    private final String filename;

    @JsonCreator
    public ReportRequest(
            @JsonProperty("foundation") String foundation,
            @JsonProperty("environment") String environment,
            @JsonProperty("period") String period,
            @JsonProperty("filename") String filename) {
        this.foundation = foundation;
        this.environment = environment;
        this.period = period;
        this.filename = filename;
    }

}


================================================
File: src/main/java/org/cftoolsuite/cfapp/service/ResourceMetadataService.java
================================================
package org.cftoolsuite.cfapp.service;

import org.cftoolsuite.cfapp.config.PasSettings;
import org.cftoolsuite.cfapp.domain.Metadata;
import org.cftoolsuite.cfapp.domain.Resource;
import org.cftoolsuite.cfapp.domain.ResourceType;
import org.cftoolsuite.cfapp.domain.Resources;
import org.cftoolsuite.cfapp.util.RetryableTokenProvider;
import org.cloudfoundry.reactor.DefaultConnectionContext;
import org.cloudfoundry.reactor.TokenProvider;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpHeaders;
import org.springframework.stereotype.Service;
import org.springframework.util.Assert;
import org.springframework.web.reactive.function.client.WebClient;
import org.springframework.web.util.UriComponentsBuilder;

import reactor.core.publisher.Mono;

@Service
public class ResourceMetadataService {

    private final WebClient webClient;
    private final DefaultConnectionContext connectionContext;
    private final TokenProvider tokenProvider;
    private final PasSettings settings;

    @Autowired
    public ResourceMetadataService(
            WebClient webClient,
            DefaultConnectionContext connectionContext,
            TokenProvider tokenProvider,
            PasSettings settings) {
        this.webClient = webClient;
        this.connectionContext = connectionContext;
        this.tokenProvider = tokenProvider;
        this.settings = settings;
    }

    public Mono<Resources> getResources(String type) {
        ResourceType rt = ResourceType.from(type);
        final String uri =
            UriComponentsBuilder
                .newInstance()
                    .scheme("https")
                    .host(settings.getApiHost())
                    .path("/v3/{type}")
                    .buildAndExpand(rt.getId())
                    .encode()
                    .toUriString();
        return
            RetryableTokenProvider
                .getToken(tokenProvider, connectionContext)
                .flatMap(t -> webClient
                                .get()
                                    .uri(uri)
                                    .header(HttpHeaders.AUTHORIZATION, t)
                                        .retrieve()
                                            .bodyToMono(Resources.class));
    }

    // @see https://v3-apidocs.cloudfoundry.org/version/3.102.0/index.html#labels-and-selectors
    public Mono<Resources> getResources(String type, String labelSelector, Integer page, Integer perPage) {
        ResourceType rt = ResourceType.from(type);
        final String uri =
            UriComponentsBuilder
                .newInstance()
                    .scheme("https")
                    .host(settings.getApiHost())
                    .path("/v3/{type}")
                    .queryParam("label_selector", labelSelector)
                    .queryParam("page", "{page}")
                    .queryParam("per_page", "{perPage}")
                    .buildAndExpand(rt.getId(), page == null ? 1 : page, perPage == null ? 50 : perPage)
                    .toUriString();
        return
            RetryableTokenProvider
                .getToken(tokenProvider, connectionContext)
                .flatMap(t -> webClient
                                .get()
                                    .uri(uri)
                                    .header(HttpHeaders.AUTHORIZATION, t)
                                        .retrieve()
                                            .bodyToMono(Resources.class));
    }

    public Mono<Resource> getResource(String type, String id) {
        Assert.hasText(id, "Global unique identifier for application must not be blank or null!");
                ResourceType rt = ResourceType.from(type);
                final String uri =
                        UriComponentsBuilder
                        .newInstance()
                        .scheme("https")
                        .host(settings.getApiHost())
                        .path("/v3/{type}/{guid}")
                        .buildAndExpand(rt.getId(), id)
                        .encode()
                        .toUriString();
                return
                    RetryableTokenProvider
                        .getToken(tokenProvider, connectionContext)
                        .flatMap(t -> webClient
                                .get()
                                .uri(uri)
                                .header(HttpHeaders.AUTHORIZATION, t)
                                .retrieve()
                                .bodyToMono(Resource.class));
    }

    public Mono<Metadata> updateResource(String type, String id, Metadata metadata) {
        ResourceType rt = ResourceType.from(type);
        if (metadata.isValid()) {
            final String uri =
                    UriComponentsBuilder
                    .newInstance()
                    .scheme("https")
                    .host(settings.getApiHost())
                    .path("/v3/{type}/{id}")
                    .buildAndExpand(rt.getId(), id)
                    .encode()
                    .toUriString();
            return
                RetryableTokenProvider
                    .getToken(tokenProvider, connectionContext)
                    .flatMap(t -> webClient
                            .patch()
                            .uri(uri)
                            .bodyValue(metadata)
                            .header(HttpHeaders.AUTHORIZATION, t)
                            .retrieve()
                            .bodyToMono(Metadata.class));
        } else {
            return Mono.error(new IllegalArgumentException(String.format("Invalid metadata %s", metadata.toString())));
        }
    }

}


================================================
File: src/main/java/org/cftoolsuite/cfapp/service/ServiceInstanceDetailService.java
================================================
package org.cftoolsuite.cfapp.service;

import java.time.LocalDate;

import org.cftoolsuite.cfapp.domain.ServiceInstanceDetail;
import org.cftoolsuite.cfapp.domain.ServiceInstancePolicy;

import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;
import reactor.util.function.Tuple2;

public interface ServiceInstanceDetailService {

    Mono<Void> deleteAll();

    Flux<ServiceInstanceDetail> findAll();

    Flux<ServiceInstanceDetail> findByDateRange(LocalDate start, LocalDate end);

    Flux<Tuple2<ServiceInstanceDetail, ServiceInstancePolicy>> findByServiceInstancePolicy(ServiceInstancePolicy policy);

    Mono<ServiceInstanceDetail> save(ServiceInstanceDetail entity);

}


================================================
File: src/main/java/org/cftoolsuite/cfapp/service/ServiceInstanceMetricsService.java
================================================
package org.cftoolsuite.cfapp.service;

import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;
import reactor.util.function.Tuple2;

public interface ServiceInstanceMetricsService {

    Flux<Tuple2<String, Long>> byOrganization();

    Flux<Tuple2<String, Long>> byService();

    Flux<Tuple2<String, Long>> byServiceAndPlan();

    Mono<Long> totalServiceInstances();

    Flux<Tuple2<String, Long>> totalVelocity();

}


================================================
File: src/main/java/org/cftoolsuite/cfapp/service/ServiceInstanceReporter.java
================================================
package org.cftoolsuite.cfapp.service;

import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;

import org.apache.commons.lang3.StringUtils;
import org.cftoolsuite.cfapp.domain.accounting.service.NormalizedServicePlanMonthlyUsage;
import org.cftoolsuite.cfapp.domain.accounting.service.ServiceUsageReport;
import org.cftoolsuite.cfapp.domain.accounting.service.NormalizedServicePlanMonthlyUsage.NormalizedServicePlanMonthlyUsageBuilder;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.util.Assert;

import com.fasterxml.jackson.core.JsonParseException;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.JsonMappingException;
import com.fasterxml.jackson.databind.MappingIterator;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.dataformat.csv.CsvMapper;
import com.fasterxml.jackson.dataformat.csv.CsvParser;

import lombok.extern.slf4j.Slf4j;

@Slf4j
@Service
public class ServiceInstanceReporter {

    private static final String REPORT_HEADER = "foundation,environment,time_period,service_name,service_guid,service_plan_name,service_plan_guid,average_instances,maximum_instances,instance_hours\n";
    private final ObjectMapper mapper;

    @Autowired
    public ServiceInstanceReporter(ObjectMapper mapper) {
        this.mapper = mapper;
    }

    public String createReport(ReportRequest[] requests) {
        List<ReportRequest> list = Arrays.asList(requests);
        try { log.info(mapper.writeValueAsString(list)); } catch (JsonProcessingException jpe) {}
        StringBuilder result = new StringBuilder();
        result.append(REPORT_HEADER);
        for (ReportRequest r: list) {
            result.append(createReport(r.getFoundation(), r.getEnvironment(), r.getPeriod(), r.getFilename()));
        }
        return result.toString();
    }

    public void createReport(String outputFilename, ReportRequest[] requests) {
        Path path = Paths.get(outputFilename);
        try {
            Files.write(path, createReport(requests).getBytes());
        } catch (IOException ioe) {
            log.warn("Could not create report output file!", ioe);
        }
    }

    public String createReport(String foundation, String environment, String period, String filename) {
        Assert.hasText(foundation, "Foundation must be specified!");
        Assert.hasText(environment, "Environment must be specified!");
        Assert.hasText(period, "Time period must be specified! It should have the form YYYY-MM");
        Assert.hasText(filename, "Filename must be specified!");
        StringBuilder result = new StringBuilder();
        Integer year = Integer.valueOf(period.split("-")[0]);
        Integer month = Integer.valueOf(period.split("-")[1]);
        try {
            List<NormalizedServicePlanMonthlyUsage> usage = readServiceUsageReport(filename);
            List<NormalizedServicePlanMonthlyUsage> filtered =
                    usage
                    .stream()
                    .filter(u -> u.getYear().equals(year) && u.getMonth() != null && u.getMonth().equals(month))
                    .collect(Collectors.toList());
            for (NormalizedServicePlanMonthlyUsage u: filtered) {
                result.append(foundation + "," + environment + "," + period + "," + u.getServiceName() + "," + u.getServiceGuid() + "," + u.getServicePlanName() + "," + u.getServicePlanGuid() + "," + u.getAverageInstances() + "," + u.getMaximumInstances() + "," + u.getDurationInHours() + "\n");
            }
        } catch (JsonParseException jpe) {
            log.warn(String.format("Could not parse file contents of %s into a ServiceUsageReport!", filename), jpe);
        } catch (JsonMappingException jme) {
            log.warn(String.format("Could not map file contents in %s into JSON!", filename), jme);
        } catch (IOException ioe) {
            log.warn(String.format("Trouble creating report from %s!", filename), ioe);
        }
        return result.toString();
    }

    protected String readFile(String filename) {
        String content = "";
        try {
            content = new String(Files.readAllBytes(Paths.get(filename)));
        } catch (IOException ioe) {
            log.warn(String.format("Trouble reading file %s contents", filename), ioe);
        }
        return content;
    }

    protected List<NormalizedServicePlanMonthlyUsage> readServiceUsageReport(String filename) throws JsonParseException, JsonMappingException, IOException {
        String content = readFile(filename);
        if (filename.endsWith(".json")) {
            return NormalizedServicePlanMonthlyUsage.listOf(mapper.readValue(content, ServiceUsageReport.class));
        } else if (filename.endsWith(".csv")) {
            CsvMapper csvMapper = new CsvMapper();
            csvMapper.enable(CsvParser.Feature.WRAP_AS_ARRAY);
            File csvFile = new File(filename);
            MappingIterator<String[]> it = csvMapper.readerFor(String[].class).readValues(csvFile);
            List<NormalizedServicePlanMonthlyUsage> reports = new ArrayList<>();
            int rowNum = 0;
            while (it.hasNext()) {
                String[] row = it.next();
                if (rowNum > 0) {
                    NormalizedServicePlanMonthlyUsageBuilder amb = NormalizedServicePlanMonthlyUsage.builder();
                    for (int i = 0; i < row.length; i++) {
                        if (i == 0) {
                            String[] period = row[i].split("-");
                            if (period.length == 2) {
                                amb.month(Integer.valueOf(period[1]));
                            }
                            amb.year(Integer.valueOf(period[0]));
                        }
                        if (i == 1) {
                            amb.serviceName(row[i]);
                        }
                        if (i == 2) {
                            amb.serviceGuid(row[i]);
                        }
                        if (i == 3) {
                            amb.servicePlanName(row[i]);
                        }
                        if (i == 4) {
                            amb.servicePlanGuid(row[i]);
                        }
                        if (i == 5) {
                            amb.averageInstances(Double.valueOf(row[i]));
                        }
                        if (i == 6) {
                            amb.maximumInstances(Integer.valueOf(row[i]));
                        }
                        if (i == 7) {
                            amb.durationInHours(Double.valueOf(row[i]));
                        }
                    }
                    NormalizedServicePlanMonthlyUsage usage = amb.build();
                    if (StringUtils.isNotBlank(usage.getServicePlanGuid())) {
                        reports.add(usage);
                    }
                }
                rowNum++;
            }
            return reports;
        } else {
            return NormalizedServicePlanMonthlyUsage.listOf(ServiceUsageReport.builder().build());
        }
    }

}


================================================
File: src/main/java/org/cftoolsuite/cfapp/service/SnapshotService.java
================================================
package org.cftoolsuite.cfapp.service;

import java.time.LocalDateTime;
import java.util.TreeSet;
import java.util.stream.Collectors;

import org.cftoolsuite.cfapp.config.PasSettings;
import org.cftoolsuite.cfapp.domain.ApplicationCounts;
import org.cftoolsuite.cfapp.domain.ServiceInstanceCounts;
import org.cftoolsuite.cfapp.domain.SnapshotDetail;
import org.cftoolsuite.cfapp.domain.SnapshotSummary;
import org.cftoolsuite.cfapp.domain.UserCounts;
import org.cftoolsuite.cfapp.event.AppDetailRetrievedEvent;
import org.cftoolsuite.cfapp.event.AppRelationshipRetrievedEvent;
import org.cftoolsuite.cfapp.event.ServiceInstanceDetailRetrievedEvent;
import org.cftoolsuite.cfapp.event.UserAccountsRetrievedEvent;
import org.cftoolsuite.cfapp.report.AppDetailCsvReport;
import org.cftoolsuite.cfapp.report.AppRelationshipCsvReport;
import org.cftoolsuite.cfapp.report.ServiceInstanceDetailCsvReport;
import org.cftoolsuite.cfapp.report.UserAccountsCsvReport;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import reactor.core.publisher.Mono;
import reactor.util.function.Tuple2;

@Service
public class SnapshotService {

    private final AppDetailService appDetailService;
    private final ServiceInstanceDetailService siDetailService;
    private final AppRelationshipService appRelationshipService;
    private final SpaceUsersService spaceUsersService;
    private final AppMetricsService appMetricsService;
    private final ServiceInstanceMetricsService siMetricsService;
    private final AppDetailCsvReport appDetailCsvReport;
    private final ServiceInstanceDetailCsvReport siDetailCsvReport;
    private final AppRelationshipCsvReport appRelationsCsvReport;
    private final UserAccountsCsvReport uaCsvReport;

    @Autowired
    public SnapshotService(
            PasSettings settings,
            AppDetailService appDetailService,
            ServiceInstanceDetailService siDetailService,
            AppRelationshipService appRelationshipService,
            SpaceUsersService spaceUsersService,
            AppMetricsService appMetricsService,
            ServiceInstanceMetricsService siMetricsService
            ) {
        this.appDetailService = appDetailService;
        this.siDetailService = siDetailService;
        this.appRelationshipService = appRelationshipService;
        this.spaceUsersService = spaceUsersService;
        this.appMetricsService = appMetricsService;
        this.siMetricsService = siMetricsService;
        this.appDetailCsvReport = new AppDetailCsvReport(settings);
        this.appRelationsCsvReport = new AppRelationshipCsvReport(settings);
        this.siDetailCsvReport = new ServiceInstanceDetailCsvReport(settings);
        this.uaCsvReport = new UserAccountsCsvReport(settings);
    }

    protected Mono<ApplicationCounts> assembleApplicationCounts() {
        return
                appMetricsService.byOrganization().collect(Collectors.toMap(Tuple2::getT1, Tuple2::getT2)).map(bo -> ApplicationCounts.builder().byOrganization(bo))
                .flatMap(b -> appMetricsService.byBuildpack().collect(Collectors.toMap(Tuple2::getT1, Tuple2::getT2)).map(bb -> b.byBuildpack(bb)))
                .flatMap(b -> appMetricsService.byStack().collect(Collectors.toMap(Tuple2::getT1, Tuple2::getT2)).map(bs -> b.byStack(bs)))
                .flatMap(b -> appMetricsService.byDockerImage().collect(Collectors.toMap(Tuple2::getT1, Tuple2::getT2)).map(bdi -> b.byDockerImage(bdi)))
                .flatMap(b -> appMetricsService.byStatus().collect(Collectors.toMap(Tuple2::getT1, Tuple2::getT2)).map(bst -> b.byStatus(bst)))
                .flatMap(b -> appMetricsService.totalApplications().map(ta -> b.totalApplications(ta)))
                .flatMap(b -> appMetricsService.totalRunningApplicationInstances().map(trai -> b.totalRunningApplicationInstances(trai)))
                .flatMap(b -> appMetricsService.totalStoppedApplicationInstances().map(tsai -> b.totalStoppedApplicationInstances(tsai)))
                .flatMap(b -> appMetricsService.totalCrashedApplicationInstances().map(taai -> b.totalCrashedApplicationInstances(taai)))
                .flatMap(b -> appMetricsService.totalApplicationInstances().map(tai -> b.totalApplicationInstances(tai)))
                .flatMap(b -> appMetricsService.totalMemoryUsed().map(tmu -> b.totalMemoryUsed(tmu)))
                .flatMap(b -> appMetricsService.totalDiskUsed().map(tdu -> b.totalDiskUsed(tdu)))
                .flatMap(b -> appMetricsService.totalVelocity().collect(Collectors.toMap(Tuple2::getT1, Tuple2::getT2)).map(v -> b.velocity(v).build()));
    }

    public Mono<String> assembleCsvAIReport(LocalDateTime collectionTime) {
        return appDetailService
                .findAll()
                .collectList()
                .map(r -> new AppDetailRetrievedEvent(this)
                        .detail(r)
                        )
                .map(event ->
                String.join(
                        "\n\n",
                        appDetailCsvReport.generatePreamble(collectionTime),
                        appDetailCsvReport.generateDetail(event)));
    }

    public Mono<String> assembleCsvRelationshipsReport(LocalDateTime collectionTime) {
        return appRelationshipService
                .findAll()
                .collectList()
                .map(r -> new AppRelationshipRetrievedEvent(this)
                        .relations(r)
                        )
                .map(event ->
                String.join(
                        "\n\n",
                        appRelationsCsvReport.generatePreamble(collectionTime),
                        appRelationsCsvReport.generateDetail(event)));
    }

    public Mono<String> assembleCsvSIReport(LocalDateTime collectionTime) {
        return siDetailService
                .findAll()
                .collectList()
                .map(r -> new ServiceInstanceDetailRetrievedEvent(this)
                        .detail(r)
                        )
                .map(event ->
                String.join(
                        "\n\n",
                        siDetailCsvReport.generatePreamble(collectionTime),
                        siDetailCsvReport.generateDetail(event)));
    }

    public Mono<String> assembleCsvUserAccountReport(LocalDateTime collectionTime) {
        return spaceUsersService
                .obtainUserAccounts()
                .collectList()
                .map(r -> new UserAccountsRetrievedEvent(this)
                        .detail(r)
                        )
                .map(event ->
                String.join(
                        "\n\n",
                        uaCsvReport.generatePreamble(collectionTime),
                        uaCsvReport.generateDetail(event)));
    }

    protected Mono<ServiceInstanceCounts> assembleServiceInstanceCounts() {
        return
                siMetricsService.byOrganization().collect(Collectors.toMap(Tuple2::getT1, Tuple2::getT2)).map(bo -> ServiceInstanceCounts.builder().byOrganization(bo))
                .flatMap(b -> siMetricsService.byService().collect(Collectors.toMap(Tuple2::getT1, Tuple2::getT2)).map(bs -> b.byService(bs)))
                .flatMap(b -> siMetricsService.byServiceAndPlan().collect(Collectors.toMap(Tuple2::getT1, Tuple2::getT2)).map(bsap -> b.byServiceAndPlan(bsap)))
                .flatMap(b -> siMetricsService.totalServiceInstances().map(tsi -> b.totalServiceInstances(tsi)))
                .flatMap(b -> siMetricsService.totalVelocity().collect(Collectors.toMap(Tuple2::getT1, Tuple2::getT2)).map(v -> b.velocity(v).build()));
    }

    public Mono<SnapshotDetail> assembleSnapshotDetail() {
        return appDetailService
                .findAll()
                .collectList()
                .map(ad -> SnapshotDetail.builder().applications(ad))
                .flatMap(b -> siDetailService
                        .findAll()
                        .collectList()
                        .map(sid -> b.serviceInstances(sid)))
                .flatMap(b -> appRelationshipService
                        .findAll()
                        .collectList()
                        .map(ar -> b.applicationRelationships(ar)))
                .flatMap(b -> spaceUsersService
                        .obtainUserAccountNames()
                        .collect(Collectors.toCollection(TreeSet::new))
                        .map(u -> b.userAccounts(u)))
                .flatMap(b -> spaceUsersService
                        .obtainServiceAccountNames()
                        .collect(Collectors.toCollection(TreeSet::new))
                        .map(u -> b.serviceAccounts(u).build()));
    }

    public Mono<SnapshotSummary> assembleSnapshotSummary() {
        return assembleApplicationCounts()
                .map(ac -> SnapshotSummary.builder().applicationCounts(ac))
                .flatMap(b -> assembleServiceInstanceCounts().map(sic -> b.serviceInstanceCounts(sic)))
                .flatMap(b -> assembleUserCounts().map(uc -> b.userCounts(uc).build()));
    }

    protected Mono<UserCounts> assembleUserCounts() {
        return spaceUsersService
                .countByOrganization()
                .map(cbo -> UserCounts.builder().byOrganization(cbo))
                .flatMap(b -> spaceUsersService.totalUserAccounts().map(c -> b.totalUserAccounts(c)))
                .flatMap(b -> spaceUsersService.totalServiceAccounts().map(c -> b.totalServiceAccounts(c).build()));
    }
}


================================================
File: src/main/java/org/cftoolsuite/cfapp/service/SpaceService.java
================================================
package org.cftoolsuite.cfapp.service;

import org.cftoolsuite.cfapp.domain.Space;

import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

public interface SpaceService {

    Mono<Void> deleteAll();

    Flux<Space> findAll();

    Mono<Space> save(Space entity);

}


================================================
File: src/main/java/org/cftoolsuite/cfapp/service/SpaceUsersService.java
================================================
package org.cftoolsuite.cfapp.service;

import java.util.Map;

import org.cftoolsuite.cfapp.domain.SpaceUsers;
import org.cftoolsuite.cfapp.domain.UserAccounts;

import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

public interface SpaceUsersService {

    Mono<Map<String, Integer>> countByOrganization();

    Mono<Void> deleteAll();

    Flux<SpaceUsers> findAll();

    Flux<SpaceUsers> findByAccountName(String name);

    Mono<SpaceUsers> findByOrganizationAndSpace(String organization, String space);

    Flux<String> obtainAccountNames();

    Flux<String> obtainServiceAccountNames();

    Flux<String> obtainUserAccountNames();

    Flux<UserAccounts> obtainUserAccounts();

    Mono<SpaceUsers> save(SpaceUsers entity);

    Mono<Long> totalServiceAccounts();

    Mono<Long> totalUserAccounts();

}


================================================
File: src/main/java/org/cftoolsuite/cfapp/service/StacksCache.java
================================================
package org.cftoolsuite.cfapp.service;

import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.TreeMap;

import org.apache.commons.lang3.StringUtils;
import org.cftoolsuite.cfapp.domain.Stack;
import org.springframework.stereotype.Component;
import org.springframework.util.Assert;

@Component
public class StacksCache {

    private final Map<String, Stack> stacksByName = new TreeMap<>();
    private final Map<String, Stack> stacksById = new HashMap<>();

    public boolean contains(String name) {
        return stacksByName.containsKey(name);
    }

    public Map<String, Stack> from(List<org.cloudfoundry.operations.stacks.Stack> input) {
        stacksByName.clear();
        stacksById.clear();
        input.forEach(
                s -> {
                    Stack stack = Stack.builder().id(s.getId()).name(s.getName()).description(s.getDescription()).build();
                    stacksByName.put(s.getName(), stack);
                    stacksById.put(s.getId(), stack);
                });
        return stacksByName;
    }

    public Stack getStackById(String id) {
        Assert.isTrue(StringUtils.isNotBlank(id), "Stack id must not be blank.");
        return stacksById.get(id);
    }

    public Stack getStackByName(String name) {
        Assert.isTrue(StringUtils.isNotBlank(name), "Stack name must not be blank.");
        return stacksByName.get(name);
    }
}


================================================
File: src/main/java/org/cftoolsuite/cfapp/service/TimeKeeperService.java
================================================
package org.cftoolsuite.cfapp.service;

import java.time.LocalDateTime;

import org.cftoolsuite.cfapp.domain.TimeKeeper;
import org.cftoolsuite.cfapp.repository.R2dbcTimeKeeperRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import lombok.extern.slf4j.Slf4j;
import reactor.core.publisher.Mono;

@Slf4j
@Service
public class TimeKeeperService {

    private final R2dbcTimeKeeperRepository repo;

    @Autowired
    public TimeKeeperService(R2dbcTimeKeeperRepository repo) {
        this.repo = repo;
    }

    @Transactional
    public Mono<Void> deleteOne() {
        return repo.deleteOne();
    }

    public Mono<LocalDateTime> findOne() {
        return repo.findOne();
    }

    @Transactional
    public Mono<TimeKeeper> save() {
        LocalDateTime collectionTime = LocalDateTime.now();
        return
                repo
                .save(collectionTime)
                .onErrorContinue(
                        (ex, data) -> log.error(String.format("Problem saving collectime time %s.", collectionTime), ex));
    }
}


================================================
File: src/main/java/org/cftoolsuite/cfapp/service/TkServiceUtil.java
================================================
package org.cftoolsuite.cfapp.service;

import java.time.LocalDateTime;

import org.springframework.http.HttpHeaders;

import reactor.core.publisher.Mono;

public class TkServiceUtil {

    private static final String LAST_TIME_COLLECTED = "X-DateTime-Collected";

    private final TimeKeeperService tkService;

    public TkServiceUtil(TimeKeeperService tkService) {
        this.tkService = tkService;
    }

    public Mono<HttpHeaders> getHeaders() {
        return
            tkService
                .findOne()
                .map(lc -> {
                    HttpHeaders headers = new HttpHeaders();
                    headers.add(LAST_TIME_COLLECTED, lc.toString());
                    return headers;
                });
    }

    public Mono<LocalDateTime> getTimeCollected() {
        return
            tkService
                .findOne();
    }

}


================================================
File: src/main/java/org/cftoolsuite/cfapp/service/UsageCache.java
================================================
package org.cftoolsuite.cfapp.service;

import org.cftoolsuite.cfapp.domain.accounting.application.AppUsageReport;
import org.cftoolsuite.cfapp.domain.accounting.service.ServiceUsageReport;
import org.cftoolsuite.cfapp.domain.accounting.task.TaskUsageReport;
import org.springframework.stereotype.Component;

import lombok.Data;

@Data
@Component
public class UsageCache {

    private AppUsageReport applicationReport;
    private ServiceUsageReport serviceReport;
    private TaskUsageReport taskReport;

}


================================================
File: src/main/java/org/cftoolsuite/cfapp/service/UsageService.java
================================================
package org.cftoolsuite.cfapp.service;

import java.time.LocalDate;

import org.cftoolsuite.cfapp.config.PasSettings;
import org.cftoolsuite.cfapp.domain.accounting.application.AppUsageReport;
import org.cftoolsuite.cfapp.domain.accounting.service.ServiceUsageReport;
import org.cftoolsuite.cfapp.domain.accounting.task.TaskUsageReport;
import org.cftoolsuite.cfapp.util.RetryableTokenProvider;
import org.cloudfoundry.reactor.DefaultConnectionContext;
import org.cloudfoundry.reactor.TokenProvider;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpHeaders;
import org.springframework.stereotype.Service;
import org.springframework.util.Assert;
import org.springframework.web.reactive.function.client.WebClient;

import reactor.core.publisher.Mono;

// @see https://docs.vmware.com/en/VMware-Tanzu-Application-Service/3.0/tas-for-vms/accounting-report.html#obtain-system-usage-information-1

@Service
public class UsageService {

    private final OrganizationService orgService;
    private final WebClient webClient;
    private final DefaultConnectionContext connectionContext;
    private final TokenProvider tokenProvider;
    private final PasSettings settings;

    @Autowired
    public UsageService(
            OrganizationService orgService,
            WebClient webClient,
            DefaultConnectionContext connectionContext,
            TokenProvider tokenProvider,
            PasSettings settings,
            UsageCache cache) {
        this.orgService = orgService;
        this.webClient = webClient;
        this.connectionContext = connectionContext;
        this.tokenProvider = tokenProvider;
        this.settings = settings;
    }

    public Mono<AppUsageReport> getApplicationReport() {
        String uri = settings.getUsageDomain() + "/system_report/app_usages";
        return
            RetryableTokenProvider
                .getToken(tokenProvider, connectionContext)
                .flatMap(t -> webClient
                        .get()
                        .uri(uri)
                        .header(HttpHeaders.AUTHORIZATION, t)
                        .retrieve()
                        .bodyToMono(AppUsageReport.class));
    }

    public Mono<ServiceUsageReport> getServiceReport() {
        String uri = settings.getUsageDomain() + "/system_report/service_usages";
        return
            RetryableTokenProvider
                .getToken(tokenProvider, connectionContext)
                .flatMap(t -> webClient
                        .get()
                        .uri(uri)
                        .header(HttpHeaders.AUTHORIZATION, t)
                        .retrieve()
                        .bodyToMono(ServiceUsageReport.class));
    }

    public Mono<TaskUsageReport> getTaskReport() {
        String uri = settings.getUsageDomain() + "/system_report/task_usages";
        return
            RetryableTokenProvider
                .getToken(tokenProvider, connectionContext)
                .flatMap(t -> webClient
                        .get()
                        .uri(uri)
                        .header(HttpHeaders.AUTHORIZATION, t)
                        .retrieve()
                        .bodyToMono(TaskUsageReport.class));
    }


    // FIXME Refactor Mono<String> JSON-like output to domain objects so we can start to drive aggregate calculations

    public Mono<String> getApplicationUsage(String orgName, LocalDate start, LocalDate end) {
        return
                orgService
                .findAll()
                .filter(org -> org.getName().equalsIgnoreCase(orgName))
                .single()
                .flatMap(org -> getUsage("app_usages", org.getId(), start, end));
    }

    public Mono<String> getServiceUsage(String orgName, LocalDate start, LocalDate end) {
        return
                orgService
                .findAll()
                .filter(org -> org.getName().equalsIgnoreCase(orgName))
                .single()
                .flatMap(org -> getUsage("service_usages", org.getId(), start, end));
    }

    public Mono<String> getTaskUsage(String orgName, LocalDate start, LocalDate end) {
        return
                orgService
                .findAll()
                .filter(org -> org.getName().equalsIgnoreCase(orgName))
                .single()
                .flatMap(org -> getUsage("task_usages", org.getId(), start, end));
    }

    private Mono<String> getUsage(String usageType, String orgGuid, LocalDate start, LocalDate end) {
        Assert.hasText(orgGuid, "Global unique identifier for organization must not be blank or null!");
        Assert.notNull(start, "Start of date range must be specified!");
        Assert.notNull(end, "End of date range must be specified!");
        Assert.isTrue(end.isAfter(start), "Date range is invalid!");
        String uri = settings.getUsageDomain() + "/organizations/{orgGuid}/{usageType}?start={start}&end={end}";
        return
            RetryableTokenProvider
                .getToken(tokenProvider, connectionContext)
                .flatMap(t -> webClient
                        .get()
                        .uri(uri, orgGuid, usageType, start.toString(), end.toString())
                        .header(HttpHeaders.AUTHORIZATION, t)
                        .retrieve()
                        .bodyToMono(String.class));
    }

    //----------
}


================================================
File: src/main/java/org/cftoolsuite/cfapp/service/UserSpacesService.java
================================================
package org.cftoolsuite.cfapp.service;

import org.cftoolsuite.cfapp.domain.Space;
import org.cftoolsuite.cfapp.domain.UserSpaces;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import reactor.core.publisher.Mono;

@Service
public class UserSpacesService {

    private static Space buildSpace(String organization, String space) {
        return Space
                .builder()
                .organizationName(organization)
                .spaceName(space)
                .build();
    }

    private final SpaceUsersService service;

    @Autowired
    public UserSpacesService(SpaceUsersService service) {
        this.service = service;
    }

    public Mono<UserSpaces> getUserSpaces(String name) {
        return service
                .findByAccountName(name)
                .map(su -> buildSpace(su.getOrganization(), su.getSpace()))
                .collectList()
                .map(spaces -> UserSpaces.builder().accountName(name).spaces(spaces).build());
    }
}


================================================
File: src/main/java/org/cftoolsuite/cfapp/task/AppDetailReadyToBeCollectedDecider.java
================================================
package org.cftoolsuite.cfapp.task;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.atomic.AtomicInteger;

import org.cftoolsuite.cfapp.config.PivnetSettings;
import org.cftoolsuite.cfapp.domain.Space;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

@Component
public class AppDetailReadyToBeCollectedDecider {

    private PivnetSettings settings;
    private AtomicInteger decision = new AtomicInteger();
    private List<Space> spaces = new ArrayList<>();

    @Autowired
    public AppDetailReadyToBeCollectedDecider(PivnetSettings settings) {
        this.settings = settings;
    }

    public List<Space> getSpaces() {
        return List.copyOf(spaces);
    }

    public int informDecision() {
        return decision.incrementAndGet();
    }

    public boolean isDecided() {
        return settings.isEnabled() ? decision.get() == 2: decision.get() == 1;
    }

    public void reset() {
        spaces.clear();
        decision.set(0);
    }

    public void setSpaces(List<Space> spaces) {
        this.spaces = spaces;
    }

}


================================================
File: src/main/java/org/cftoolsuite/cfapp/task/AppDetailTask.java
================================================
package org.cftoolsuite.cfapp.task;

import java.time.Instant;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.ZoneId;
import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;

import org.apache.commons.lang3.StringUtils;
import org.cftoolsuite.cfapp.config.PasSettings;
import org.cftoolsuite.cfapp.domain.AppDetail;
import org.cftoolsuite.cfapp.domain.Buildpack;
import org.cftoolsuite.cfapp.domain.Space;
import org.cftoolsuite.cfapp.domain.Stack;
import org.cftoolsuite.cfapp.domain.product.PivnetCache;
import org.cftoolsuite.cfapp.event.AppDetailReadyToBeRetrievedEvent;
import org.cftoolsuite.cfapp.event.AppDetailRetrievedEvent;
import org.cftoolsuite.cfapp.service.AppDetailService;
import org.cftoolsuite.cfapp.service.BuildpacksCache;
import org.cftoolsuite.cfapp.service.EventsService;
import org.cftoolsuite.cfapp.service.StacksCache;
import org.cloudfoundry.client.v2.ClientV2Exception;
import org.cloudfoundry.client.v2.applications.SummaryApplicationRequest;
import org.cloudfoundry.client.v3.ClientV3Exception;
import org.cloudfoundry.client.v3.applications.GetApplicationCurrentDropletRequest;
import org.cloudfoundry.client.v3.applications.GetApplicationCurrentDropletResponse;
import org.cloudfoundry.client.v3.applications.GetApplicationProcessStatisticsRequest;
import org.cloudfoundry.client.v3.processes.ProcessState;
import org.cloudfoundry.operations.DefaultCloudFoundryOperations;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.ApplicationEventPublisher;
import org.springframework.context.ApplicationListener;
import org.springframework.stereotype.Component;
import org.springframework.util.CollectionUtils;

import lombok.extern.slf4j.Slf4j;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

@Slf4j
@Component
public class AppDetailTask implements ApplicationListener<AppDetailReadyToBeRetrievedEvent> {

    private final PasSettings settings;
    private final DefaultCloudFoundryOperations opsClient;
    private final AppDetailService appDetailsService;
    private final EventsService eventsService;
    private final BuildpacksCache buildpacksCache;
    private final StacksCache stacksCache;
    private final ApplicationEventPublisher publisher;
    private final PivnetCache pivnetCache;
    private final AppDetailReadyToBeCollectedDecider appDetailReadyToBeCollectedDecider;

    @Autowired
    public AppDetailTask(
            PivnetCache pivnetCache,
            PasSettings settings,
            DefaultCloudFoundryOperations opsClient,
            AppDetailService appDetailsService,
            EventsService eventsService,
            BuildpacksCache buildpacksCache,
            StacksCache stacksCache,
            ApplicationEventPublisher publisher,
            AppDetailReadyToBeCollectedDecider appDetailReadyToBeCollectedDecider) {
        this.pivnetCache = pivnetCache;
        this.settings = settings;
        this.opsClient = opsClient;
        this.appDetailsService = appDetailsService;
        this.eventsService = eventsService;
        this.buildpacksCache = buildpacksCache;
        this.stacksCache = stacksCache;
        this.publisher = publisher;
        this.appDetailReadyToBeCollectedDecider = appDetailReadyToBeCollectedDecider;
    }

    private DefaultCloudFoundryOperations buildClient(Space target) {
        return DefaultCloudFoundryOperations
                .builder()
                .from(opsClient)
                .organization(target.getOrganizationName())
                .space(target.getSpaceName())
                .build();
    }

    public void collect(List<Space> spaces) {
        log.info("AppDetailTask started");
        appDetailsService
            .deleteAll()
            .thenMany(Flux.fromIterable(spaces))
            .concatMap(this::listApplications)
            .flatMap(this::getSummaryInfo)
            .flatMap(this::getBuildpackFromApplicationCurrentDroplet)
            .flatMap(this::getUsageAndQuotas)
            .flatMap(this::getLastEvent)
            .flatMap(appDetailsService::save)
            .thenMany(appDetailsService.findAll())
            .collectList()
            .subscribe(
                result -> {
                    publisher.publishEvent(new AppDetailRetrievedEvent(this).detail(result));
                    log.info("AppDetailTask completed. {} applications found.", result.size());
                },
                error -> {
                    log.error("AppDetailTask terminated with error", error);
                }
            );
    }

    private String getBuildpack(String buildpackId) {
        Buildpack buildpack = buildpacksCache.getBuildpackById(buildpackId);
        if (buildpack != null) {
            return settings.getBuildpack(buildpack.getName());
        }
        return null;
    }

    private String getBuildpackLatestVersion(String buildpackId) {
        return pivnetCache.findLatestProductReleaseBySlug(getBuildpack(buildpackId) + "-buildpack").getVersion();
    }

    private LocalDateTime getBuildpackReleaseDate(String buildpackId) {
        LocalDate releaseDate = pivnetCache.findLatestProductReleaseBySlug(getBuildpack(buildpackId) + "-buildpack").getReleaseDate();
        if (releaseDate != null){
            return releaseDate.atStartOfDay();
        }
        return null;
    }

    private String getBuildpackReleaseNotesUrl(String buildpackId) {
        return pivnetCache.findLatestProductReleaseBySlug(getBuildpack(buildpackId) + "-buildpack").getReleaseNotesUrl();
    }

    private String getBuildpackReleaseType(String buildpackId) {
        return pivnetCache.findLatestProductReleaseBySlug(getBuildpack(buildpackId) + "-buildpack").getReleaseType();
    }

    private String getBuildpackVersion(String buildpackId) {
        Buildpack buildpack = buildpacksCache.getBuildpackById(buildpackId);
        if (buildpack != null) {
            return buildpack.getVersion();
        }
        return null;
    }

    private String getCurrentDropletBuildpackVersion(String raw) {
        String version = raw;
        if (version != null) {
            if (version.contains("-")) {
                version = raw.substring(0, raw.indexOf("-"));
            }
        }
        return version;
    }

    protected Mono<AppDetail> getLastEvent(AppDetail fragment) {
        log.trace("Fetching last event for application id={}, name={} in org={}, space={}", fragment.getAppId(), fragment.getAppName(), fragment.getOrganization(), fragment.getSpace());
        return eventsService.getEvents(fragment.getAppId(), 1)
                .flatMapMany(envelope -> eventsService.toFlux(envelope))
                .next()
                .map(e ->
                    AppDetail
                        .from(fragment)
                        .lastEvent(e.getType())
                        .lastEventActor(e.getActor())
                        .lastEventTime(e.getTime())
                        .build()
                )
                .defaultIfEmpty(fragment);
    }


    protected Mono<AppDetail> getUsageAndQuotas(AppDetail fragment) {
        log.trace("Fetching application usage stats and quotas for org={}, space={}, id={}, name={}",
                fragment.getOrganization(), fragment.getSpace(), fragment.getAppId(), fragment.getAppName());

        return buildClient(buildSpace(fragment.getOrganization(), fragment.getSpace()))
                .getCloudFoundryClient()
                .applicationsV3()
                .getProcessStatistics(GetApplicationProcessStatisticsRequest.builder()
                        .applicationId(fragment.getAppId())
                        .type("web")
                        .build())
                .map(stats -> {
                    Long diskUsage = stats.getResources().stream()
                            .filter(r -> r.getState().equals(ProcessState.RUNNING))
                            .findFirst()
                            .map(r -> nullSafeLong(r.getUsage().getDisk()))
                            .orElse(0L);
                    Long memoryUsage = stats.getResources().stream()
                            .filter(r -> r.getState().equals(ProcessState.RUNNING))
                            .findFirst()
                            .map(r -> nullSafeLong(r.getUsage().getMemory()))
                            .orElse(0L);
                    Long diskQuota = stats.getResources().stream()
                            .filter(r -> r.getState().equals(ProcessState.RUNNING))
                            .findFirst()
                            .map(r -> nullSafeLong(r.getDiskQuota()))
                            .orElse(0L);
                    Long memoryQuota = stats.getResources().stream()
                            .filter(r -> r.getState().equals(ProcessState.RUNNING))
                            .findFirst()
                            .map(r -> nullSafeLong(r.getMemoryQuota()))
                            .orElse(0L);
                    return
                        AppDetail
                        .from(fragment)
                        .memoryUsed(memoryUsage)
                        .diskUsed(diskUsage)
                        .diskQuota(diskQuota)
                        .memoryQuota(memoryQuota)
                        .build();
                })
                .onErrorResume(ClientV3Exception.class, e -> Mono.just(fragment));
    }

    protected Mono<AppDetail> getSummaryInfo(AppDetail fragment) {
        log.trace("Fetching application summary for org={}, space={}, id={}, name={}", fragment.getOrganization(), fragment.getSpace(), fragment.getAppId(), fragment.getAppName());
        return opsClient
                .getCloudFoundryClient()
                .applicationsV2()
                .summary(SummaryApplicationRequest.builder().applicationId(fragment.getAppId()).build())
                .map(sar ->
                    AppDetail
                        .from(fragment)
                        .buildpack(getBuildpack(sar.getDetectedBuildpackId()))
                        .buildpackVersion(getBuildpackVersion(sar.getDetectedBuildpackId()))
                        .image(sar.getDockerImage())
                        .stack(nullSafeStack(sar.getStackId()))
                        .lastPushed(nullSafeLocalDateTime(sar.getPackageUpdatedAt()))
                        .buildpackReleaseType(getBuildpackReleaseType(sar.getDetectedBuildpackId()))
                        .buildpackReleaseDate(getBuildpackReleaseDate(sar.getDetectedBuildpackId()))
                        .buildpackLatestVersion(getBuildpackLatestVersion(sar.getDetectedBuildpackId()))
                        .buildpackLatestUrl(getBuildpackReleaseNotesUrl(sar.getDetectedBuildpackId()))
                        .build()
                )
                .onErrorResume(ClientV2Exception.class, e -> Mono.just(fragment));
    }

    protected Mono<AppDetail> getBuildpackFromApplicationCurrentDroplet(AppDetail fragment) {
        if (StringUtils.isNotBlank(fragment.getBuildpack())) {
            log.trace("Fetching application current droplet buildpack for org={}, space={}, id={}, name={}", fragment.getOrganization(), fragment.getSpace(), fragment.getAppId(), fragment.getAppName());
            return opsClient
                    .getCloudFoundryClient()
                    .applicationsV3()
                    .getCurrentDroplet(GetApplicationCurrentDropletRequest.builder().applicationId(fragment.getAppId()).build())
                    .map(acd -> refineBuildpackFromApplicationCurrentDroplet(fragment, acd))
                    .onErrorResume(ClientV3Exception.class, e -> Mono.just(fragment));
        }
        return Mono.just(fragment);
    }

    private AppDetail refineBuildpackFromApplicationCurrentDroplet(AppDetail fragment, GetApplicationCurrentDropletResponse response) {
        if (fragment.getBuildpack().equals("meta")) {
            List<String> buildpackNameFragments = Arrays.asList(response.getBuildpacks().get(0).getBuildpackName().split(" "));
            if (!CollectionUtils.isEmpty(buildpackNameFragments)) {
                String buildpack = buildpackNameFragments.stream().filter(bnf -> bnf.contains("buildpack")).collect(Collectors.toList()).get(0);
                String[] parts = buildpack.split("=");
                if (parts.length == 2) {
                    return
                        AppDetail
                            .from(fragment)
                            .buildpack(settings.getBuildpack(parts[0]))
                            .buildpackVersion(getCurrentDropletBuildpackVersion(parts[1]))
                            .build();
                }
            }
        }
        return
            AppDetail
                .from(fragment)
                .buildpack(settings.getBuildpack(response.getBuildpacks().get(0).getBuildpackName()))
                .buildpackVersion(getCurrentDropletBuildpackVersion(response.getBuildpacks().get(0).getVersion()))
                .build();
    }

    @Override
    public void onApplicationEvent(AppDetailReadyToBeRetrievedEvent event) {
        if (appDetailReadyToBeCollectedDecider.isDecided()) {
            collect(List.copyOf(appDetailReadyToBeCollectedDecider.getSpaces()));
            appDetailReadyToBeCollectedDecider.reset();
        }
    }

    protected Flux<AppDetail> listApplications(Space target) {
        return
            buildClient(target)
                .applications()
                .list()
                .map(as ->
                    AppDetail
                        .builder()
                        .appId(as.getId())
                        .appName(as.getName())
                        .organization(target.getOrganizationName())
                        .space(target.getSpaceName())
                        .runningInstances(nullSafeInteger(as.getRunningInstances()))
                        .totalInstances(nullSafeInteger(as.getInstances()))
                        .requestedState(as.getRequestedState().toLowerCase())
                        .urls(as.getUrls())
                        .build()
                );
    }

    private String nullSafeStack(String stackId) {
        Stack stack = stacksCache.getStackById(stackId);
        if (stack != null) {
            return stack.getName();
        }
        return "unknown";
    }

    private static Space buildSpace(String organization, String space) {
        return Space
                .builder()
                .organizationName(organization)
                .spaceName(space)
                .build();
    }

    private static Integer nullSafeInteger(Integer value) {
        return value != null ? value: 0;
    }

    private static Long nullSafeLong(Long value) {
        return value != null ? value: 0L;
    }

    private static LocalDateTime nullSafeLocalDateTime(String value) {
        return StringUtils.isNotBlank(value)
                ? Instant.parse(value).atZone(ZoneId.systemDefault()).toLocalDateTime()
                        : null;
    }

}


================================================
File: src/main/java/org/cftoolsuite/cfapp/task/AppRelationshipTask.java
================================================
package org.cftoolsuite.cfapp.task;

import java.util.Arrays;
import java.util.List;

import org.cftoolsuite.cfapp.domain.AppRelationship;
import org.cftoolsuite.cfapp.domain.AppRelationshipRequest;
import org.cftoolsuite.cfapp.domain.ServiceInstanceDetail;
import org.cftoolsuite.cfapp.event.AppRelationshipRetrievedEvent;
import org.cftoolsuite.cfapp.event.ServiceInstanceDetailRetrievedEvent;
import org.cftoolsuite.cfapp.service.AppRelationshipService;
import org.cloudfoundry.client.v3.applications.ApplicationResource;
import org.cloudfoundry.client.v3.applications.ListApplicationsRequest;
import org.cloudfoundry.operations.DefaultCloudFoundryOperations;
import org.cloudfoundry.util.PaginationUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.ApplicationEventPublisher;
import org.springframework.context.ApplicationListener;
import org.springframework.stereotype.Component;
import org.springframework.util.CollectionUtils;

import lombok.extern.slf4j.Slf4j;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

@Slf4j
@Component
public class AppRelationshipTask implements ApplicationListener<ServiceInstanceDetailRetrievedEvent> {

    private DefaultCloudFoundryOperations opsClient;
    private AppRelationshipService service;
    private ApplicationEventPublisher publisher;

    @Autowired
    public AppRelationshipTask(
            DefaultCloudFoundryOperations opsClient,
            AppRelationshipService service,
            ApplicationEventPublisher publisher
            ) {
        this.opsClient = opsClient;
        this.service = service;
        this.publisher = publisher;
    }

    public void collect(List<ServiceInstanceDetail> serviceInstances) {
        log.info("AppRelationshipTask started");
        service
            .deleteAll()
            .thenMany(Flux.fromIterable(serviceInstances))
            .filter(sid -> !CollectionUtils.isEmpty(sid.getApplications()))
            .flatMap(si -> Flux.fromIterable(AppRelationshipRequest.listOf(si)))
            .flatMap(this::getAppRelationship)
            .flatMap(service::save)
            .thenMany(service.findAll())
            .collectList()
            .subscribe(
                result -> {
                    publisher.publishEvent(new AppRelationshipRetrievedEvent(this).relations(result));
                    log.info("AppRelationshipTask completed. {} application to service instance binding relationships found.", result.size());
                },
                error -> {
                    log.error("AppRelationshipTask terminated with error", error);
                }
            );
    }

    protected Mono<AppRelationship> getAppRelationship(AppRelationshipRequest request) {
        Flux<ApplicationResource> resources =
                PaginationUtils.requestClientV3Resources(
                        page -> DefaultCloudFoundryOperations
                        .builder()
                        .from(opsClient)
                        .organization(request.getOrganization())
                        .space(request.getSpace())
                        .build()
                        .getCloudFoundryClient()
                        .applicationsV3()
                        .list(ListApplicationsRequest.builder().page(page).addAllNames(Arrays.asList(new String[] { request.getApplicationName() })).build()));
        return resources
                .next()
                .map(ar ->
                    AppRelationship
                        .builder()
                        .organization(request.getOrganization())
                        .space(request.getSpace())
                        .appId(ar.getId())
                        .appName(request.getApplicationName())
                        .serviceInstanceId(request.getServiceInstanceId())
                        .serviceName(request.getServiceName())
                        .serviceOffering(request.getServiceOffering())
                        .servicePlan(request.getServicePlan())
                        .serviceType(request.getServiceType())
                        .build());
    }

    @Override
    public void onApplicationEvent(ServiceInstanceDetailRetrievedEvent event) {
        collect(List.copyOf(event.getDetail()));
    }

}


================================================
File: src/main/java/org/cftoolsuite/cfapp/task/BuildpacksTask.java
================================================
package org.cftoolsuite.cfapp.task;

import org.cftoolsuite.cfapp.event.BuildpacksRetrievedEvent;
import org.cftoolsuite.cfapp.event.TkRetrievedEvent;
import org.cftoolsuite.cfapp.service.BuildpacksCache;
import org.cloudfoundry.operations.DefaultCloudFoundryOperations;
import org.cloudfoundry.operations.buildpacks.Buildpack;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.ApplicationEventPublisher;
import org.springframework.context.ApplicationListener;
import org.springframework.stereotype.Component;

import lombok.extern.slf4j.Slf4j;
import reactor.core.publisher.Flux;

@Slf4j
@Component
public class BuildpacksTask implements ApplicationListener<TkRetrievedEvent> {

    private final DefaultCloudFoundryOperations opsClient;
    private final BuildpacksCache cache;
    private final ApplicationEventPublisher publisher;

    @Autowired
    public BuildpacksTask(
            DefaultCloudFoundryOperations opsClient,
            BuildpacksCache cache,
            ApplicationEventPublisher publisher) {
        this.opsClient = opsClient;
        this.cache = cache;
        this.publisher = publisher;
    }

    public void collect() {
        log.info("BuildpacksTask started");
        getBuildpacks()
        .collectList()
        .map(list -> cache.from(list))
        .subscribe(
            result -> {
                publisher.publishEvent(new BuildpacksRetrievedEvent(this));
                log.trace("Buildpack cache contains {}", result);
                log.info("BuildpacksTask completed. {} buildpacks found.", result.size());
            },
            error -> {
                log.error("BuildpacksTask terminated with error", error);
            }
        );
    }

    protected Flux<Buildpack> getBuildpacks() {
        return opsClient
                .buildpacks()
                .list();
    }

    @Override
    public void onApplicationEvent(TkRetrievedEvent event) {
        collect();
    }

}


================================================
File: src/main/java/org/cftoolsuite/cfapp/task/DatabaseCreator.java
================================================
package org.cftoolsuite.cfapp.task;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;

import org.cftoolsuite.cfapp.config.DbmsSettings;
import org.cftoolsuite.cfapp.event.DatabaseCreatedEvent;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.ApplicationArguments;
import org.springframework.boot.ApplicationRunner;
import org.springframework.context.ApplicationEventPublisher;
import org.springframework.core.io.Resource;
import org.springframework.core.io.ResourceLoader;
import org.springframework.data.r2dbc.core.R2dbcEntityOperations;
import org.springframework.stereotype.Component;

import lombok.extern.slf4j.Slf4j;

@Slf4j
@Component
public class DatabaseCreator implements ApplicationRunner {

    private final R2dbcEntityOperations client;
    private final ResourceLoader resourceLoader;
    private final DbmsSettings settings;
    private final ApplicationEventPublisher publisher;

    @Autowired
    public DatabaseCreator(
            R2dbcEntityOperations client,
            ResourceLoader resourceLoader,
            DbmsSettings settings,
            ApplicationEventPublisher publisher) {
        this.client = client;
        this.resourceLoader = resourceLoader;
        this.settings = settings;
        this.publisher = publisher;
    }

    @Override
    public void run(ApplicationArguments args) {
        String path = "";
        try {
            path = obtainPathToSchemaFile("schema.ddl");
            createTablesAndViews(path);
            publisher.publishEvent(new DatabaseCreatedEvent(this));
        } catch (IOException ioe) {
            log.error(String.format("Failed trying to read %s\n", path), ioe);
            System.exit(1);
        }
    }

    private String obtainPathToSchemaFile(String filename) {
        String provider = settings.getProvider().toLowerCase().replaceAll("\\s","");
        String path = String.join("/", "classpath:db", provider, filename);
        return path;
    }

    private void createTablesAndViews(String path) throws IOException {
        String line = ""; String ddl = "";
        Resource schema = resourceLoader.getResource(path);
        log.info("DatabaseCreator started");
        try (
            InputStream is = schema.getInputStream();
            BufferedReader br = new BufferedReader(new InputStreamReader(is))
            ) {
                while ((line = br.readLine()) != null) {
                    if (!line.isBlank()) {
                        ddl = line.strip().replace(";","");
                        log.info("-- Executed [ {} ]", ddl);
                        client
                            .getDatabaseClient()
                            .sql(ddl)
                            .then()
                            .doOnError(
                                error -> {
                                    log.error("DatabaseCreator terminated with error", error);
                                    System.exit(1);
                                }
                            )
                            .subscribe();
                    }
                }
        }
    }

}


================================================
File: src/main/java/org/cftoolsuite/cfapp/task/DeleteAppPolicyExecutorTask.java
================================================
package org.cftoolsuite.cfapp.task;

import java.time.LocalDateTime;

import org.cftoolsuite.cfapp.domain.AppDetail;
import org.cftoolsuite.cfapp.domain.AppRelationship;
import org.cftoolsuite.cfapp.domain.ApplicationOperation;
import org.cftoolsuite.cfapp.domain.HistoricalRecord;
import org.cftoolsuite.cfapp.service.AppDetailService;
import org.cftoolsuite.cfapp.service.AppRelationshipService;
import org.cftoolsuite.cfapp.service.HistoricalRecordService;
import org.cftoolsuite.cfapp.service.PoliciesService;
import org.cftoolsuite.cfapp.util.PolicyFilter;
import org.cloudfoundry.operations.DefaultCloudFoundryOperations;
import org.cloudfoundry.operations.applications.DeleteApplicationRequest;
import org.cloudfoundry.operations.services.DeleteServiceInstanceRequest;
import org.cloudfoundry.operations.services.UnbindServiceInstanceRequest;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import lombok.extern.slf4j.Slf4j;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

@Slf4j
@Component
public class DeleteAppPolicyExecutorTask implements PolicyExecutorTask {

    private PolicyFilter filter;
    private DefaultCloudFoundryOperations opsClient;
    private AppDetailService appInfoService;
    private AppRelationshipService appRelationshipService;
    private PoliciesService policiesService;
    private HistoricalRecordService historicalRecordService;

    @Autowired
    public DeleteAppPolicyExecutorTask(
            PolicyFilter filter,
            DefaultCloudFoundryOperations opsClient,
            AppDetailService appInfoService,
            AppRelationshipService appRelationshipService,
            PoliciesService policiesService,
            HistoricalRecordService historicalRecordService
            ) {
        this.filter = filter;
        this.opsClient = opsClient;
        this.appInfoService = appInfoService;
        this.appRelationshipService = appRelationshipService;
        this.policiesService = policiesService;
        this.historicalRecordService = historicalRecordService;
    }

    protected Mono<HistoricalRecord> deleteApplication(AppDetail detail) {
        return DefaultCloudFoundryOperations.builder()
                .from(opsClient)
                .organization(detail.getOrganization())
                .space(detail.getSpace())
                .build()
                .applications()
                .delete(
                    DeleteApplicationRequest
                        .builder()
                        .name(detail.getAppName())
                        .deleteRoutes(true)
                        .build()
                )
                .then(
                    Mono.just(
                        HistoricalRecord
                            .builder()
                            .transactionDateTime(LocalDateTime.now())
                            .actionTaken("delete")
                            .organization(detail.getOrganization())
                            .space(detail.getSpace())
                            .appId(detail.getAppId())
                            .type("application")
                            .name(detail.getAppName())
                            .build()
                    )
                );
    }

    protected Flux<HistoricalRecord> deleteApplicationsWithNoServiceBindings(String id) {
        // these are the applications with no service bindings
        // we can delete each one without having to first unbind it from one or more service instances
        return policiesService
                .findByApplicationOperation(ApplicationOperation.DELETE)
                .flux()
                .flatMap(p -> Flux.fromIterable(p.getApplicationPolicies()))
                .filter(ap -> ap.getId().equals(id))
                .flatMap(ap -> appInfoService.findByApplicationPolicy(ap, false))
                .filter(wl -> filter.isWhitelisted(wl.getT2(), wl.getT1().getOrganization()))
                .filter(bl -> filter.isBlacklisted(bl.getT1().getOrganization(), bl.getT1().getSpace()))
                .flatMap(ad -> deleteApplication(ad.getT1()))
                .flatMap(historicalRecordService::save);
    }

    protected Flux<HistoricalRecord> deleteApplicationsWithServiceBindingsAndDeleteBoundServiceInstances(String id) {
        // these are the applications with service bindings
        // in this case the application policy has been configured with delete-services = true
        // so we:  a) unbind one or more service instances from each application, b) delete each application,
        // and c) delete each formerly bound service instance
        return policiesService
                .findByApplicationOperation(ApplicationOperation.DELETE)
                .flux()
                .flatMap(p -> Flux.fromIterable(p.getApplicationPolicies()))
                .filter(ap -> ap.getId().equals(id))
                .filter(f -> f.getOption("delete-services", Boolean.class) == true)
                .flatMap(ap -> appInfoService.findByApplicationPolicy(ap, true))
                .filter(wl -> filter.isWhitelisted(wl.getT2(), wl.getT1().getOrganization()))
                .filter(bl -> filter.isBlacklisted(bl.getT1().getOrganization(), bl.getT1().getSpace()))
                .flatMap(ar -> appRelationshipService.findByApplicationId(ar.getT1().getAppId()))
                .flatMap(this::unbindServiceInstance)
                .flatMap(historicalRecordService::save)
                .flatMap(ad -> appInfoService.findByAppId(ad.getAppId()))
                .distinct()
                .flatMap(this::deleteApplication)
                .flatMap(historicalRecordService::save)
                .flatMap(dad -> appRelationshipService.findByApplicationId(dad.getAppId()))
                .flatMap(this::deleteServiceInstance)
                .flatMap(historicalRecordService::save);
    }

    protected Flux<HistoricalRecord> deleteApplicationsWithServiceBindingsButDoNotDeleteBoundServiceInstances(String id) {
        // these are the applications with service bindings
        // in this case the application policy has been configured with delete-services = false
        // so we:  a) unbind one or more service instances from each application, b) delete each application
        return policiesService
                .findByApplicationOperation(ApplicationOperation.DELETE)
                .flux()
                .flatMap(p -> Flux.fromIterable(p.getApplicationPolicies()))
                .filter(ap -> ap.getId().equals(id))
                .filter(f -> f.getOption("delete-services", Boolean.class) == false)
                .flatMap(ap -> appInfoService.findByApplicationPolicy(ap, true))
                .filter(wl -> filter.isWhitelisted(wl.getT2(), wl.getT1().getOrganization()))
                .filter(bl -> filter.isBlacklisted(bl.getT1().getOrganization(), bl.getT1().getSpace()))
                .flatMap(ar -> appRelationshipService.findByApplicationId(ar.getT1().getAppId()))
                .flatMap(this::unbindServiceInstance)
                .flatMap(historicalRecordService::save)
                .flatMap(ad -> appInfoService.findByAppId(ad.getAppId()))
                .distinct()
                .flatMap(this::deleteApplication)
                .flatMap(historicalRecordService::save);
    }

    protected Mono<HistoricalRecord> deleteServiceInstance(AppRelationship relationship) {
        return DefaultCloudFoundryOperations.builder()
                .from(opsClient)
                .organization(relationship.getOrganization())
                .space(relationship.getSpace())
                .build()
                .services()
                .deleteInstance(DeleteServiceInstanceRequest.builder().name(relationship.getServiceName()).build())
                .then(
                    Mono.just(
                        HistoricalRecord
                            .builder()
                            .transactionDateTime(LocalDateTime.now())
                            .actionTaken("delete")
                            .organization(relationship.getOrganization())
                            .space(relationship.getSpace())
                            .appId(relationship.getAppId())
                            .serviceInstanceId(relationship.getServiceInstanceId())
                            .type("service-instance")
                            .name(serviceInstanceName(relationship))
                            .build()
                    )
                );
    }

    @Override
    public void execute(String id) {
        log.info("DeleteAppPolicyExecutorTask with id={} started", id);
        Flux.concat(
            deleteApplicationsWithNoServiceBindings(id),
            deleteApplicationsWithServiceBindingsButDoNotDeleteBoundServiceInstances(id),
            deleteApplicationsWithServiceBindingsAndDeleteBoundServiceInstances(id)
        )
        .collectList()
        .subscribe(
            result -> {
                log.info("DeleteAppPolicyExecutorTask with id={} completed", id);
                log.info("-- {} applications deleted.", result.size());
            },
            error -> {
                log.error(String.format("DeleteAppPolicyExecutorTask with id=%s terminated with error", id), error);
            }
        );
    }

    private String serviceInstanceName(AppRelationship relationship) {
        return String.join("__", relationship.getServiceName(), relationship.getServiceType(), relationship.getServicePlan());
    }

    protected Mono<HistoricalRecord> unbindServiceInstance(AppRelationship relationship) {
        return DefaultCloudFoundryOperations.builder()
                .from(opsClient)
                .organization(relationship.getOrganization())
                .space(relationship.getSpace())
                .build()
                .services()
                .unbind(
                    UnbindServiceInstanceRequest
                        .builder()
                        .applicationName(relationship.getAppName())
                        .serviceInstanceName(relationship.getServiceName())
                        .build()
                )
                .then(
                    Mono.just(
                        HistoricalRecord
                            .builder()
                            .transactionDateTime(LocalDateTime.now())
                            .actionTaken("unbind")
                            .organization(relationship.getOrganization())
                            .space(relationship.getSpace())
                            .appId(relationship.getAppId())
                            .serviceInstanceId(relationship.getServiceInstanceId())
                            .type("service-instance")
                            .name(serviceInstanceName(relationship))
                            .build()
                    )
                );
    }
}


================================================
File: src/main/java/org/cftoolsuite/cfapp/task/DeleteServiceInstancePolicyExecutorTask.java
================================================
package org.cftoolsuite.cfapp.task;

import java.time.LocalDateTime;

import org.cftoolsuite.cfapp.domain.HistoricalRecord;
import org.cftoolsuite.cfapp.domain.ServiceInstanceDetail;
import org.cftoolsuite.cfapp.domain.ServiceInstanceOperation;
import org.cftoolsuite.cfapp.service.HistoricalRecordService;
import org.cftoolsuite.cfapp.service.PoliciesService;
import org.cftoolsuite.cfapp.service.ServiceInstanceDetailService;
import org.cftoolsuite.cfapp.util.PolicyFilter;
import org.cloudfoundry.operations.DefaultCloudFoundryOperations;
import org.cloudfoundry.operations.services.DeleteServiceInstanceRequest;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import lombok.extern.slf4j.Slf4j;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

@Slf4j
@Component
public class DeleteServiceInstancePolicyExecutorTask implements PolicyExecutorTask {

    private PolicyFilter filter;
    private DefaultCloudFoundryOperations opsClient;
    private ServiceInstanceDetailService serviceInfoService;
    private PoliciesService policiesService;
    private HistoricalRecordService historicalRecordService;

    @Autowired
    public DeleteServiceInstancePolicyExecutorTask(
            PolicyFilter filter,
            DefaultCloudFoundryOperations opsClient,
            ServiceInstanceDetailService serviceInfoService,
            PoliciesService policiesService,
            HistoricalRecordService historicalRecordService
            ) {
        this.filter = filter;
        this.opsClient = opsClient;
        this.serviceInfoService = serviceInfoService;
        this.policiesService = policiesService;
        this.historicalRecordService = historicalRecordService;
    }

    protected Mono<HistoricalRecord> deleteServiceInstance(ServiceInstanceDetail sd) {
        return DefaultCloudFoundryOperations.builder()
                .from(opsClient)
                .organization(sd.getOrganization())
                .space(sd.getSpace())
                .build()
                .services()
                .deleteInstance(DeleteServiceInstanceRequest.builder().name(sd.getName()).build())
                .then(
                    Mono.just(
                        HistoricalRecord
                            .builder()
                            .transactionDateTime(LocalDateTime.now())
                            .actionTaken("delete")
                            .organization(sd.getOrganization())
                            .space(sd.getSpace())
                            .serviceInstanceId(sd.getServiceInstanceId())
                            .type("service-instance")
                            .name(String.join("__", sd.getName(), sd.getType(), sd.getPlan()))
                            .build()
                    )
                );
    }

    @Override
    public void execute(String id) {
        log.info("DeleteServiceInstancePolicyExecutorTask with id={} started", id);
        policiesService
            .findByServiceInstanceOperation(ServiceInstanceOperation.DELETE)
            .flux()
            .flatMap(p -> Flux.fromIterable(p.getServiceInstancePolicies()))
            .filter(sp -> sp.getId().equals(id))
            .flatMap(sp -> serviceInfoService.findByServiceInstancePolicy(sp))
            .filter(wl -> filter.isWhitelisted(wl.getT2(), wl.getT1().getOrganization()))
            .filter(bl -> filter.isBlacklisted(bl.getT1().getOrganization(), bl.getT1().getSpace()))
            .flatMap(ds -> deleteServiceInstance(ds.getT1()))
            .flatMap(historicalRecordService::save)
            .collectList()
            .subscribe(
                result -> {
                    log.info("DeleteServiceInstancePolicyExecutorTask with id={} completed", id);
                    log.info("-- {} service instances deleted.", result.size());
                },
                error -> {
                    log.error(String.format("DeleteServiceInstancePolicyExecutorTask with id=%s terminated with error", id), error);
                }
            );
    }

}


================================================
File: src/main/java/org/cftoolsuite/cfapp/task/EndpointPolicyExecutorTask.java
================================================
package org.cftoolsuite.cfapp.task;

import java.util.ArrayList;
import java.util.List;

import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.exception.ExceptionUtils;
import org.cftoolsuite.cfapp.config.PasSettings;
import org.cftoolsuite.cfapp.domain.EmailAttachment;
import org.cftoolsuite.cfapp.domain.EndpointPolicy;
import org.cftoolsuite.cfapp.domain.EndpointRequest;
import org.cftoolsuite.cfapp.event.EmailNotificationEvent;
import org.cftoolsuite.cfapp.service.PoliciesService;
import org.cftoolsuite.cfapp.util.JsonToCsvConverter;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.ApplicationEventPublisher;
import org.springframework.core.env.Environment;
import org.springframework.http.HttpHeaders;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Component;
import org.springframework.web.reactive.function.client.WebClient;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.jayway.jsonpath.Configuration;
import com.jayway.jsonpath.JsonPath;
import com.jayway.jsonpath.spi.json.JacksonJsonProvider;
import com.jayway.jsonpath.spi.mapper.JacksonMappingProvider;

import lombok.extern.slf4j.Slf4j;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;
import reactor.util.function.Tuple2;
import reactor.util.function.Tuples;

@Slf4j
@Component
public class EndpointPolicyExecutorTask implements PolicyExecutorTask {

    private final PasSettings settings;
    private final PoliciesService policiesService;
    private final JsonToCsvConverter converter;
    private final WebClient client;
    private final ApplicationEventPublisher publisher;
    private final Environment env;

    @Autowired
    public EndpointPolicyExecutorTask(
            PasSettings settings,
            PoliciesService policiesService,
            JsonToCsvConverter converter,
            WebClient client,
            ApplicationEventPublisher publisher,
            Environment env) {
        this.settings = settings;
        this.policiesService = policiesService;
        this.converter = converter;
        this.client = client;
        this.publisher = publisher;
        this.env = env;
    }

    @Override
    public void execute(String id) {
        log.info("EndpointPolicyExecutorTask with id={} started", id);
        fetchEndpointPolicy(id)
            .concatMap(ep -> exerciseEndpoints(ep).collectList().map(result -> Tuples.of(ep, result)))
            .collectList()
            .subscribe(
                results -> handleSuccess(results, id),
                error -> log.error("EndpointPolicyExecutorTask with id={} terminated with error", id, error)
            );
    }

    private void handleSuccess(List<Tuple2<EndpointPolicy, List<Tuple2<EndpointRequest, ResponseEntity<String>>>>> results, String id) {
        results.forEach(result -> {
            EndpointPolicy policy = result.getT1();
            List<Tuple2<EndpointRequest, ResponseEntity<String>>> endpointResults = result.getT2();
            publisher.publishEvent(buildEmailNotificationEvent(policy, endpointResults));
        });
        log.info("EndpointPolicyExecutorTask with id={} completed", id);
    }

    private EmailNotificationEvent buildEmailNotificationEvent(EndpointPolicy policy, List<Tuple2<EndpointRequest, ResponseEntity<String>>> endpointResults) {
        return new EmailNotificationEvent(this)
            .domain(settings.getAppsDomain())
            .from(policy.getEmailNotificationTemplate().getFrom())
            .recipients(policy.getEmailNotificationTemplate().getTo())
            .carbonCopyRecipients(policy.getEmailNotificationTemplate().getCc())
            .blindCarbonCopyRecipients(policy.getEmailNotificationTemplate().getBcc())
            .subject(policy.getEmailNotificationTemplate().getSubject())
            .body(policy.getEmailNotificationTemplate().getBody())
            .attachments(buildAttachments(endpointResults));
    }

    protected Mono<ResponseEntity<String>> exerciseEndpoint(String endpoint) {
        String[] routes = env.getProperty("vcap.application.uris", String[].class);
        String port = env.getProperty("local.server.port", String.class);
        String host = routes != null ? routes[0] : "localhost:" + port;
        String scheme = host.startsWith("localhost") ? "http://" : "https://";
        String uri = scheme + host + endpoint;
        return client.get().uri(uri).retrieve().toEntity(String.class);
    }

    protected Flux<Tuple2<EndpointRequest, ResponseEntity<String>>> exerciseEndpoints(EndpointPolicy policy) {
        return
            Flux
                .fromIterable(policy.getEndpointRequests())
                .flatMap(request ->
                    exerciseEndpoint(request.getEndpoint())
                        .map(response -> Tuples.of(request, response))
                );
    }

    protected Flux<EndpointPolicy> fetchEndpointPolicy(String id) {
        return policiesService.findEndpointPolicyById(id)
            .flatMapMany(policy -> Flux.fromIterable(policy.getEndpointPolicies()));
    }

    private String formatEndpointName(String endpoint) {
        return endpoint.replaceFirst("/", "")
            .replace("/", "-")
            .replace("?q=", "-")
            .replace("?", "-")
            .replace("[]", "")
            .replace("=", "-equal-");
    }

    private String determineFilename(EndpointRequest request) {
        String result = "";
        if (StringUtils.isNotBlank(request.getJsonPathExpression())) {
            result =
                request
                    .getJsonPathExpression()
                    .replaceAll("\\s+|[\\p{Punct}&&[^._]]|[._]", "-")
                    .replaceAll("-+", "-")
                    .replaceAll("^-+", "")
                    .replaceAll("-+$", "");
        } else {
            result = formatEndpointName(request.getEndpoint());
        }
        return result;
    }

    private List<EmailAttachment> buildAttachments(List<Tuple2<EndpointRequest, ResponseEntity<String>>> endpointResults) {
        List<EmailAttachment> attachments = new ArrayList<>();
        for (Tuple2<EndpointRequest, ResponseEntity<String>> result : endpointResults) {
            String filename = determineFilename(result.getT1());
            String jsonPathExpression = result.getT1().getJsonPathExpression();
            boolean applyConverter = result.getT1().isApplyJsonToCsvConverter();
            String content = result.getT2().getBody();
            String mimeType = result.getT2().getHeaders().getFirst(HttpHeaders.CONTENT_TYPE);

            if (StringUtils.isNotBlank(mimeType) && StringUtils.isNotBlank(content)) {
                attachments.add(createAttachment(filename, content, mimeType, jsonPathExpression, applyConverter));
            } else {
                attachments.add(createDefaultAttachment(filename));
            }
        }
        return attachments;
    }

    private EmailAttachment createAttachment(String filename, String data, String mimeType, String jsonPathExpression, boolean applyConverter) {
        log.info("Attempting to create an email attachment named {} with mimetype {}", filename, mimeType);
        log.trace("-- containing {}", data);
        String content = data;
        if (mimeType.startsWith(MediaType.APPLICATION_JSON_VALUE) && StringUtils.isNotBlank(jsonPathExpression)) {
            try {
                ObjectMapper mapper = new ObjectMapper();
                Configuration conf =
                    Configuration
                        .builder()
                        .jsonProvider(new JacksonJsonProvider(mapper))
                        .mappingProvider(new JacksonMappingProvider())
                        .build();
                log.info("Attempting to extract fragment using JsonPath expression {}", jsonPathExpression);
                Object fragment = JsonPath.using(conf).parse(data).read(jsonPathExpression);
                content = mapper.writeValueAsString(fragment);
            } catch (JsonProcessingException iae) {
                throw new IllegalArgumentException("Could not parse fragment", iae);
            }
        }
        try {
            if (mimeType.startsWith(MediaType.APPLICATION_JSON_VALUE) && applyConverter) {
                log.info("Attempting to convert JSON to CSV.");
                return EmailAttachment.builder()
                    .filename(filename)
                    .content(converter.convert(content))
                    .extension(".csv")
                    .mimeType(MediaType.TEXT_PLAIN_VALUE)
                    .build();
            } else {
                String extension = mimeType.startsWith(MediaType.APPLICATION_JSON_VALUE) ? ".json" : ".txt";
                return EmailAttachment.builder()
                    .filename(filename)
                    .content(content)
                    .extension(extension)
                    .mimeType(mimeType)
                    .build();
            }
        } catch (IllegalArgumentException | JsonProcessingException e) {
            return EmailAttachment.builder()
                .filename(filename)
                .content("Trouble processing results.\n" + ExceptionUtils.getStackTrace(e))
                .extension(".txt")
                .mimeType(MediaType.TEXT_PLAIN_VALUE)
                .build();
        }
    }

    private EmailAttachment createDefaultAttachment(String filename) {
        return EmailAttachment.builder()
            .filename(filename)
            .content("No results")
            .extension(".txt")
            .mimeType(MediaType.TEXT_PLAIN_VALUE)
            .build();
    }
}



================================================
File: src/main/java/org/cftoolsuite/cfapp/task/ExtractJavaArtifactsFromDropletTask.java
================================================
package org.cftoolsuite.cfapp.task;

import java.io.IOException;

import java.util.List;
import java.util.stream.Collectors;

import org.apache.commons.lang3.StringUtils;
import org.cftoolsuite.cfapp.domain.AppDetail;
import org.cftoolsuite.cfapp.domain.JavaAppDetail;
import org.cftoolsuite.cfapp.event.AppDetailRetrievedEvent;
import org.cftoolsuite.cfapp.service.DropletsService;
import org.cftoolsuite.cfapp.service.JavaAppDetailService;
import org.cftoolsuite.cfapp.util.DropletProcessingCondition;
import org.cftoolsuite.cfapp.util.JarManifestUtil;
import org.cftoolsuite.cfapp.util.JavaArtifactReader;
import org.cftoolsuite.cfapp.util.TgzUtil;
import org.cloudfoundry.client.v3.applications.GetApplicationCurrentDropletRequest;
import org.cloudfoundry.client.v3.applications.GetApplicationCurrentDropletResponse;
import org.cloudfoundry.client.v3.droplets.DropletResource;
import org.cloudfoundry.client.v3.droplets.DropletState;
import org.cloudfoundry.client.v3.droplets.ListDropletsRequest;
import org.cloudfoundry.operations.DefaultCloudFoundryOperations;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.ApplicationListener;
import org.springframework.context.annotation.Conditional;
import org.springframework.core.env.Environment;
import org.springframework.core.io.buffer.DataBuffer;
import org.springframework.stereotype.Component;

import lombok.extern.slf4j.Slf4j;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

@Slf4j
@Component
@Conditional(DropletProcessingCondition.class)
public class ExtractJavaArtifactsFromDropletTask implements ApplicationListener<AppDetailRetrievedEvent> {

    private DefaultCloudFoundryOperations opsClient;
    private DropletsService dropletsService;
    private JavaAppDetailService jadService;
    private JavaArtifactReader javaArtifactReader;

    @Autowired
    public ExtractJavaArtifactsFromDropletTask(
            DefaultCloudFoundryOperations opsClient,
            DropletsService dropletsService,
            JavaAppDetailService jadService,
            JavaArtifactReader javaArtifactReader,
            Environment env) {
        this.opsClient = opsClient;
        this.dropletsService = dropletsService;
        this.jadService = jadService;
        this.javaArtifactReader = javaArtifactReader;
    }

    public void collect(List<AppDetail> detail) {
        log.info("ExtractJavaArtifactsFromDropletTask started");
        jadService
                .deleteAll()
                .thenMany(Flux.fromIterable(detail))
                .filter(ad -> StringUtils.isNotBlank(ad.getBuildpack()) && ad.getBuildpack().contains("java"))
                .flatMap(jad -> associateDropletWithApplication(jad))
                .flatMap(sd -> ascertainSpringDependencies(sd))
                .flatMap(jadService::save)
                .thenMany(jadService.findAll())
                .collectList()
                .subscribe(
                        result -> {
                            log.info("ExtractJavaArtifactsFromDropletTask completed. {} droplets processed.",
                                    result.size());
                        },
                        error -> {
                            log.error("ExtractJavaArtifactsFromDropletTask terminated with error", error);
                        });
    }

    private Mono<JavaAppDetail> associateDropletWithApplication(AppDetail detail) {
        log.trace("Attempting to fetch droplet id for {}/{}/{} whose state is {}", detail.getOrganization(),
                detail.getSpace(), detail.getAppName(), detail.getRequestedState());
        if (detail.getRequestedState().equalsIgnoreCase("started")) {
            Mono<GetApplicationCurrentDropletResponse> currentResponse = DefaultCloudFoundryOperations.builder()
                    .from(opsClient)
                    .organization(detail.getOrganization())
                    .space(detail.getSpace())
                    .build()
                    .getCloudFoundryClient()
                    .applicationsV3()
                    .getCurrentDroplet(
                            GetApplicationCurrentDropletRequest.builder().applicationId(detail.getAppId()).build());
            return currentResponse
                    .map(dr -> JavaAppDetail.from(detail).dropletId(dr.getId()).build());
        } else if (detail.getRequestedState().equalsIgnoreCase("stopped")) {
            Mono<DropletResource> stagedResponse = DefaultCloudFoundryOperations.builder()
                    .from(opsClient)
                    .organization(detail.getOrganization())
                    .space(detail.getSpace())
                    .build()
                    .getCloudFoundryClient()
                    .droplets()
                    .list(ListDropletsRequest.builder().applicationId(detail.getAppId()).build())
                    .flatMapMany(response -> Flux.fromIterable(response.getResources()))
                    .filter(resource -> resource.getState().equals(DropletState.STAGED))
                    .next();
            return stagedResponse
                    .map(dr -> JavaAppDetail.from(detail).dropletId(dr.getId()).build());
        } else {
            log.trace("No droplet found for {}/{}/{}", detail.getOrganization(), detail.getSpace(),
                    detail.getAppName());
            return Mono.just(JavaAppDetail.from(detail).build());
        }
    }

    private Mono<JavaAppDetail> ascertainSpringDependencies(JavaAppDetail detail) {
        Flux<DataBuffer> fdb = dropletsService.downloadDroplet(detail.getDropletId());

        Mono<String> manifestContentMono =
            TgzUtil
                .extractFileContent(fdb, "META-INF/MANIFEST.MF")
                .defaultIfEmpty("");

        if (javaArtifactReader.mode().equalsIgnoreCase("list-jars")) {
            return manifestContentMono.flatMap(manifestContent -> {
                Integer buildJdkSpec = extractBuildJdkSpec(manifestContent);

                return TgzUtil.findMatchingFiles(fdb, ".jar")
                        .map(s -> StringUtils.isNotBlank(s)
                                ? JavaAppDetail
                                        .from(detail)
                                        .jars(s)
                                        .buildJdkSpec(buildJdkSpec)
                                        .springDependencies(
                                                javaArtifactReader.read(s).stream().collect(Collectors.joining("\n")))
                                        .build()
                                : detail)
                        .onErrorResume(e -> {
                            log.error(String.format("Trouble ascertaining Spring dependencies for %s/%s/%s",
                                    detail.getOrganization(), detail.getSpace(), detail.getAppName()), e);
                            return Mono.just(detail);
                        });
            });
        } else if (javaArtifactReader.mode().equalsIgnoreCase("unpack-pom-contents-in-droplet")) {
            return manifestContentMono.flatMap(manifestContent -> {
                Integer buildJdkSpec = extractBuildJdkSpec(manifestContent);

                return TgzUtil.extractFileContent(fdb, "pom.xml")
                        .map(s -> StringUtils.isNotBlank(s)
                                ? JavaAppDetail
                                        .from(detail)
                                        .pomContents(s)
                                        .buildJdkSpec(buildJdkSpec)
                                        .springDependencies(
                                                javaArtifactReader.read(s).stream().collect(Collectors.joining("\n")))
                                        .build()
                                : detail)
                        .onErrorResume(e -> {
                            log.error(String.format("Trouble ascertaining Spring dependencies for %s/%s/%s",
                                    detail.getOrganization(), detail.getSpace(), detail.getAppName()), e);
                            return Mono.just(detail);
                        });
            });
        } else {
            log.warn("Not configured to ascertain Spring dependencies");
            return Mono.just(detail);
        }
    }

    private Integer extractBuildJdkSpec(String manifestContent) {
        if (manifestContent.isEmpty()) {
            return null;
        }
        try {
            String buildJdkSpecStr = JarManifestUtil.obtainAttributeValue(manifestContent, "Build-Jdk-Spec");
            return buildJdkSpecStr != null ? Integer.valueOf(buildJdkSpecStr) : null;
        } catch (IOException e) {
            log.error("Error reading MANIFEST.MF", e);
            return null;
        }
    }

    @Override
    public void onApplicationEvent(AppDetailRetrievedEvent event) {
        collect(List.copyOf(event.getDetail()));
    }

}


================================================
File: src/main/java/org/cftoolsuite/cfapp/task/HygienePolicyExecutorTask.java
================================================
package org.cftoolsuite.cfapp.task;

import java.time.Duration;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;

import org.cftoolsuite.cfapp.config.PasSettings;
import org.cftoolsuite.cfapp.domain.AppDetail;
import org.cftoolsuite.cfapp.domain.EmailAttachment;
import org.cftoolsuite.cfapp.domain.EmailValidator;
import org.cftoolsuite.cfapp.domain.HygienePolicy;
import org.cftoolsuite.cfapp.domain.ServiceInstanceDetail;
import org.cftoolsuite.cfapp.domain.Space;
import org.cftoolsuite.cfapp.domain.UserSpaces;
import org.cftoolsuite.cfapp.domain.Workloads;
import org.cftoolsuite.cfapp.domain.Workloads.WorkloadsBuilder;
import org.cftoolsuite.cfapp.event.EmailNotificationEvent;
import org.cftoolsuite.cfapp.service.DormantWorkloadsService;
import org.cftoolsuite.cfapp.service.PoliciesService;
import org.cftoolsuite.cfapp.service.SpaceUsersService;
import org.cftoolsuite.cfapp.service.UserSpacesService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.ApplicationEventPublisher;
import org.springframework.stereotype.Component;

import lombok.extern.slf4j.Slf4j;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;
import reactor.util.function.Tuple2;
import reactor.util.function.Tuples;

@Slf4j
@Component
public class HygienePolicyExecutorTask implements PolicyExecutorTask {

    private final PasSettings settings;
    private final PoliciesService policiesService;
    private final SpaceUsersService spaceUsersService;
    private final UserSpacesService userSpacesService;
    private final DormantWorkloadsService dormantWorkloadsService;
    private final ApplicationEventPublisher publisher;

    @Autowired
    public HygienePolicyExecutorTask(
            PasSettings settings,
            PoliciesService policiesService,
            SpaceUsersService spaceUsersService,
            UserSpacesService userSpacesService,
            DormantWorkloadsService dormantWorkloadsService,
            ApplicationEventPublisher publisher
            ) {
        this.settings = settings;
        this.policiesService = policiesService;
        this.spaceUsersService = spaceUsersService;
        this.userSpacesService = userSpacesService;
        this.dormantWorkloadsService = dormantWorkloadsService;
        this.publisher = publisher;
    }

    @Override
    public void execute(String id) {
        log.info("HygienePolicyExecutorTask with id={} started", id);
        fetchHygienePolicy(id)
        .concatMap(hp -> executeHygienePolicy(hp).map(result -> Tuples.of(hp, result)))
        .collectList()
        .subscribe(
            results -> {
                results.forEach(tuple -> {
                    notifyOperator(tuple);
                    notifyUsers(tuple);
                });
                log.info("HygienePolicyExecutorTask with id={} completed", id);
            },
            error -> {
                log.error(String.format("HygienePolicyExecutorTask with id=%s terminated with error", id), error);
            }
        );
    }

    protected Mono<Workloads> executeHygienePolicy(HygienePolicy policy) {
        final WorkloadsBuilder builder = Workloads.builder();
        return dormantWorkloadsService
                .getDormantApplications(policy)
                .map(list -> builder.applications(list))
                .then(dormantWorkloadsService.getDormantServiceInstances(policy))
                .map(list -> builder.serviceInstances(list).build());
    }

    protected Flux<HygienePolicy> fetchHygienePolicy(String id) {
        return
            policiesService
                .findHygienePolicyById(id)
                .flatMapMany(policy -> Flux.fromIterable(policy.getHygienePolicies()));
    }

    private void notifyOperator(Tuple2<HygienePolicy, Workloads> tuple) {
        log.trace("User: admin, " + tuple.getT2().toString());
        publisher.publishEvent(
            new EmailNotificationEvent(this)
                .domain(settings.getAppsDomain())
                .from(tuple.getT1().getOperatorTemplate().getFrom())
                .recipients(tuple.getT1().getOperatorTemplate().getTo())
                .carbonCopyRecipients(tuple.getT1().getOperatorTemplate().getCc())
                .blindCarbonCopyRecipients(tuple.getT1().getOperatorTemplate().getBcc())
                .subject(tuple.getT1().getOperatorTemplate().getSubject())
                .body(tuple.getT1().getOperatorTemplate().getBody())
                .attachments(buildAttachments(tuple))
        );
    }

    private void notifyUsers(Tuple2<HygienePolicy, Workloads> tuple) {
        if (tuple.getT1().getNotifyeeTemplate() != null) {
            // Pull distinct Set<Space> from applications and service instances
            Flux
            .fromIterable(getSpaces(tuple.getT2()))
            // For each Space in Set<Space>, obtain SpaceUsers#getUsers()
            .concatMap(space -> spaceUsersService.findByOrganizationAndSpace(space.getOrganizationName(), space.getSpaceName()))
            // then pair with matching space(s) that contain applications and service instances
            .concatMap(spaceUser -> Flux.fromIterable(spaceUser.getUsers()))
            .distinct()
            // filter out account names that are not email addresses
            .filter(EmailValidator::isValid)
            .concatMap(userName -> userSpacesService.getUserSpaces(userName))
            // Create a list where each item is a tuple of user account and filtered workloads
            .concatMap(userSpace -> filterWorkloads(userSpace, tuple.getT2()))
            .delayElements(Duration.ofMillis(250))
            .doOnNext(
                userWorkloads -> {
                    publisher.publishEvent(
                        new EmailNotificationEvent(this)
                            .domain(settings.getAppsDomain())
                            .from(tuple.getT1().getNotifyeeTemplate().getFrom())
                            .recipient(userWorkloads.getT1().getAccountName())
                            .subject(tuple.getT1().getNotifyeeTemplate().getSubject())
                            .body(tuple.getT1().getNotifyeeTemplate().getBody())
                            .attachments(buildAttachments(Tuples.of(tuple.getT1(), userWorkloads.getT2())))
                    );
                }
            )
            .subscribe();
        }
    }

    private static List<EmailAttachment> buildAttachments(Tuple2<HygienePolicy, Workloads> tuple) {
        String cr = System.getProperty("line.separator");
        List<EmailAttachment> result = new ArrayList<>();
        StringBuilder applications = new StringBuilder();
        StringBuilder serviceInstances = new StringBuilder();
        if (tuple.getT1().isIncludeApplications()) {
            tuple
                .getT2()
                .getApplications()
                .forEach(app -> applications.append(app.toCsv()).append(cr));
            result.add(
                EmailAttachment
                    .builder()
                    .filename(getFileNamePrefix(tuple.getT1()) + "applications")
                    .extension(".csv")
                    .mimeType("text/plain;charset=UTF-8")
                    .content(applications.toString())
                    .headers(AppDetail.headers())
                    .build()
            );
        }
        if (tuple.getT1().isIncludeServiceInstances()) {
            tuple
                .getT2()
                .getServiceInstances()
                .forEach(sid -> serviceInstances.append(sid.toCsv()).append(cr));
            result.add(
                EmailAttachment
                    .builder()
                    .filename(getFileNamePrefix(tuple.getT1()) + "service-instances")
                    .extension(".csv")
                    .mimeType("text/plain;charset=UTF-8")
                    .content(serviceInstances.toString())
                    .headers(ServiceInstanceDetail.headers())
                    .build()
            );
        }
        return result;
    }

    private static Space buildSpace(String organization, String space) {
        return Space
                .builder()
                .organizationName(organization)
                .spaceName(space)
                .build();
    }

    private static Mono<Tuple2<UserSpaces, Workloads>> filterWorkloads(UserSpaces userSpaces, Workloads input){
        Workloads workloads = input.matchBySpace(userSpaces.getSpaces());
        log.trace(userSpaces.toString() + ", " + workloads.toString());
        return Mono.just(Tuples.of(userSpaces, workloads));

    }

    private static String getFileNamePrefix(HygienePolicy policy) {
        String prefix = "";
        if (policy.getDaysSinceLastUpdate() != -1) {
            prefix = "dormant-";
        }
        return prefix;
    }

    private static Set<Space> getSpaces(Workloads workloads) {
        Set<Space> applicationSpaces =
            workloads
                .getApplications()
                .stream()
                .map(app -> buildSpace(app.getOrganization(), app.getSpace()))
                .collect(Collectors.toSet());
        Set<Space> serviceInstanceSpaces =
            workloads
                .getServiceInstances()
                .stream()
                .map(app -> buildSpace(app.getOrganization(), app.getSpace()))
                .collect(Collectors.toSet());
        Set<Space> result = new HashSet<>();
        result.addAll(applicationSpaces);
        result.addAll(serviceInstanceSpaces);
        return result;
    }

}


================================================
File: src/main/java/org/cftoolsuite/cfapp/task/LegacyWorkloadReportingTask.java
================================================
package org.cftoolsuite.cfapp.task;

import java.time.Duration;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;

import org.cftoolsuite.cfapp.config.PasSettings;
import org.cftoolsuite.cfapp.domain.AppDetail;
import org.cftoolsuite.cfapp.domain.AppRelationship;
import org.cftoolsuite.cfapp.domain.EmailAttachment;
import org.cftoolsuite.cfapp.domain.EmailValidator;
import org.cftoolsuite.cfapp.domain.LegacyPolicy;
import org.cftoolsuite.cfapp.domain.Space;
import org.cftoolsuite.cfapp.domain.UserSpaces;
import org.cftoolsuite.cfapp.domain.Workloads;
import org.cftoolsuite.cfapp.domain.Workloads.WorkloadsBuilder;
import org.cftoolsuite.cfapp.event.EmailNotificationEvent;
import org.cftoolsuite.cfapp.service.LegacyWorkloadsService;
import org.cftoolsuite.cfapp.service.PoliciesService;
import org.cftoolsuite.cfapp.service.SpaceUsersService;
import org.cftoolsuite.cfapp.service.UserSpacesService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.ApplicationEventPublisher;
import org.springframework.stereotype.Component;

import lombok.extern.slf4j.Slf4j;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;
import reactor.util.function.Tuple2;
import reactor.util.function.Tuples;

@Slf4j
@Component
public class LegacyWorkloadReportingTask implements PolicyExecutorTask {

    private final PasSettings settings;
    private final PoliciesService policiesService;
    private final SpaceUsersService spaceUsersService;
    private final UserSpacesService userSpacesService;
    private final LegacyWorkloadsService legacyWorkloadsService;
    private final ApplicationEventPublisher publisher;

    @Autowired
    public LegacyWorkloadReportingTask(
            PasSettings settings,
            PoliciesService policiesService,
            SpaceUsersService spaceUsersService,
            UserSpacesService userSpacesService,
            LegacyWorkloadsService legacyWorkloadsService,
            ApplicationEventPublisher publisher
            ) {
        this.settings = settings;
        this.policiesService = policiesService;
        this.spaceUsersService = spaceUsersService;
        this.userSpacesService = userSpacesService;
        this.legacyWorkloadsService = legacyWorkloadsService;
        this.publisher = publisher;
    }

    @Override
    public void execute(String id) {
        log.info("LegacyWorkloadReportingTask with id={} started", id);
        fetchLegacyPolicy(id)
        .concatMap(hp -> executePolicy(hp).map(result -> Tuples.of(hp, result)))
        .collectList()
        .subscribe(
            results -> {
                results.forEach(tuple -> {
                    notifyOperator(tuple);
                    notifyUsers(tuple);
                });
                log.info("LegacyWorkloadReportingTask with id={} completed", id);
            },
            error -> {
                log.error(String.format("LegacyWorkloadReportingTask with id=%s terminated with error", id), error);
            }
        );
    }

    protected Mono<Workloads> executePolicy(LegacyPolicy policy) {
        final WorkloadsBuilder builder = Workloads.builder();
        return legacyWorkloadsService
                .getLegacyApplications(policy)
                .map(list -> builder.applications(list))
                .then(legacyWorkloadsService.getLegacyApplicationRelationships(policy))
                .map(list -> builder.appRelationships(list).build());
    }

    protected Flux<LegacyPolicy> fetchLegacyPolicy(String id) {
        return
            policiesService
                .findLegacyPolicyById(id)
                .flatMapMany(policy -> Flux.fromIterable(policy.getLegacyPolicies()));
    }

    private void notifyOperator(Tuple2<LegacyPolicy, Workloads> tuple) {
        log.trace("User: admin, " + tuple.getT2().toString());
        publisher.publishEvent(
            new EmailNotificationEvent(this)
                .domain(settings.getAppsDomain())
                .from(tuple.getT1().getOperatorTemplate().getFrom())
                .recipients(tuple.getT1().getOperatorTemplate().getTo())
                .carbonCopyRecipients(tuple.getT1().getOperatorTemplate().getCc())
                .blindCarbonCopyRecipients(tuple.getT1().getOperatorTemplate().getBcc())
                .subject(tuple.getT1().getOperatorTemplate().getSubject())
                .body(tuple.getT1().getOperatorTemplate().getBody())
                .attachments(buildAttachments(tuple))
        );
    }

    private void notifyUsers(Tuple2<LegacyPolicy, Workloads> tuple) {
        if (tuple.getT1().getNotifyeeTemplate() != null) {
            // Pull distinct Set<Space> from applications and service instances
            Flux
            .fromIterable(getSpaces(tuple.getT2()))
            // For each Space in Set<Space>, obtain SpaceUsers#getUsers()
            .concatMap(space -> spaceUsersService.findByOrganizationAndSpace(space.getOrganizationName(), space.getSpaceName()))
            // then pair with matching space(s) that contain applications and service instances
            .concatMap(spaceUser -> Flux.fromIterable(spaceUser.getDevelopers()))
            .distinct()
            // filter out account names that are not email addresses
            .filter(EmailValidator::isValid)
            .concatMap(userName -> userSpacesService.getUserSpaces(userName))
            // Create a list where each item is a tuple of user account and filtered workloads
            .concatMap(userSpace -> filterWorkloads(userSpace, tuple.getT2()))
            .delayElements(Duration.ofMillis(250))
            .doOnNext(
                userWorkloads -> {
                        publisher.publishEvent(
                            new EmailNotificationEvent(this)
                                .domain(settings.getAppsDomain())
                                .from(tuple.getT1().getNotifyeeTemplate().getFrom())
                                .recipient(userWorkloads.getT1().getAccountName())
                                .subject(tuple.getT1().getNotifyeeTemplate().getSubject())
                                .body(tuple.getT1().getNotifyeeTemplate().getBody())
                                .attachments(buildAttachments(Tuples.of(tuple.getT1(), userWorkloads.getT2())))
                        );
                }
            )
            .subscribe();
        }
    }

    private static List<EmailAttachment> buildAttachments(Tuple2<LegacyPolicy, Workloads> tuple) {
        String cr = System.getProperty("line.separator");
        List<EmailAttachment> result = new ArrayList<>();
        StringBuilder content = new StringBuilder();
        if (!tuple.getT2().getApplications().isEmpty()){
            tuple
                .getT2()
                .getApplications()
                .forEach(app -> content.append(app.toCsv()).append(cr));
            result.add(
                EmailAttachment
                    .builder()
                    .filename(getFileNamePrefix(tuple.getT1()) + "applications")
                    .extension(".csv")
                    .mimeType("text/plain;charset=UTF-8")
                    .content(content.toString())
                    .headers(AppDetail.headers())
                    .build()
            );
        }
        if (!tuple.getT2().getAppRelationships().isEmpty()){
            tuple
                .getT2()
                .getAppRelationships()
                .forEach(app -> content.append(app.toCsv()).append(cr));
            result.add(
                EmailAttachment
                    .builder()
                    .filename(getFileNamePrefix(tuple.getT1()) + "applications")
                    .extension(".csv")
                    .mimeType("text/plain;charset=UTF-8")
                    .content(content.toString())
                    .headers(AppRelationship.headers())
                    .build()
            );
        }
        return result;
    }

    private static Mono<Tuple2<UserSpaces, Workloads>> filterWorkloads(UserSpaces userSpaces, Workloads input){
        Workloads workloads = input.matchBySpace(userSpaces.getSpaces());
        log.trace(userSpaces.toString() + ", " + workloads.toString());
        return Mono.just(Tuples.of(userSpaces, workloads));

    }

    private static String getFileNamePrefix(LegacyPolicy policy) {
        return "legacy-";
    }

    private static Set<Space> getSpaces(Workloads workloads) {
        Set<Space> applicationSpaces =
            workloads
                .getApplications()
                .stream()
                .map(app ->
                    Space
                        .builder()
                        .organizationName(app.getOrganization())
                        .spaceName(app.getSpace())
                        .build()
                )
                .collect(Collectors.toSet());
        Set<Space> appRelationshipsSpaces =
            workloads
                .getAppRelationships()
                .stream()
                .map(rel ->
                    Space
                        .builder()
                        .organizationName(rel.getOrganization())
                        .spaceName(rel.getSpace())
                        .build())
                .collect(Collectors.toSet());
        Set<Space> result = new HashSet<>();
        result.addAll(applicationSpaces);
        result.addAll(appRelationshipsSpaces);
        return result;
    }
}


================================================
File: src/main/java/org/cftoolsuite/cfapp/task/ObtainJavaArtifactsFromAppRuntimeMetadataTask.java
================================================
package org.cftoolsuite.cfapp.task;

import java.util.List;
import java.util.stream.Collectors;

import org.apache.commons.lang3.StringUtils;
import org.cftoolsuite.cfapp.domain.AppDetail;
import org.cftoolsuite.cfapp.domain.JavaAppDetail;
import org.cftoolsuite.cfapp.event.AppDetailRetrievedEvent;
import org.cftoolsuite.cfapp.service.JavaAppDetailService;
import org.cftoolsuite.cfapp.service.JavaArtifactRuntimeMetadataRetrievalService;
import org.cftoolsuite.cfapp.util.JavaArtifactReader;
import org.cloudfoundry.client.v3.applications.GetApplicationCurrentDropletRequest;
import org.cloudfoundry.client.v3.applications.GetApplicationCurrentDropletResponse;
import org.cloudfoundry.operations.DefaultCloudFoundryOperations;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
import org.springframework.context.ApplicationListener;
import org.springframework.core.env.Environment;
import org.springframework.stereotype.Component;

import lombok.extern.slf4j.Slf4j;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;
import reactor.util.function.Tuple2;
import reactor.util.function.Tuples;

@Slf4j
@Component
@ConditionalOnProperty(prefix = "java.artifacts.fetch", name= "mode", havingValue="obtain-jars-from-runtime-metadata")
public class ObtainJavaArtifactsFromAppRuntimeMetadataTask implements ApplicationListener<AppDetailRetrievedEvent> {

    private DefaultCloudFoundryOperations opsClient;
    private JavaArtifactRuntimeMetadataRetrievalService artifactService;
    private JavaAppDetailService jadService;
    private JavaArtifactReader javaArtifactReader;

    @Autowired
    public ObtainJavaArtifactsFromAppRuntimeMetadataTask(
            DefaultCloudFoundryOperations opsClient,
            JavaArtifactRuntimeMetadataRetrievalService artifactService,
            JavaAppDetailService jadService,
            JavaArtifactReader javaArtifactReader,
            Environment env
            ) {
        this.opsClient = opsClient;
        this.artifactService = artifactService;
        this.jadService = jadService;
        this.javaArtifactReader = javaArtifactReader;
    }

    public void collect(List<AppDetail> detail) {
        log.info("ObtainJavaArtifactsFromAppRuntimeMetadataTask started");
        jadService
            .deleteAll()
            .thenMany(Flux.fromIterable(detail))
            .filter(ad -> StringUtils.isNotBlank(ad.getBuildpack()) && ad.getBuildpack().contains("java") && ad.getRequestedState().equalsIgnoreCase("started"))
            .flatMap(ad -> associateDropletWithApplication(ad))
            .flatMap(sd -> ascertainSpringDependencies(sd))
            .flatMap(jadService::save)
            .thenMany(jadService.findAll())
            .collectList()
            .subscribe(
                result -> {
                    log.info("ObtainJavaArtifactsFromAppRuntimeMetadataTask completed. {} running applications processed.", result.size());
                },
                error -> {
                    log.error("ObtainJavaArtifactsFromAppRuntimeMetadataTask terminated with error", error);
                }
            );
    }

    private Mono<Tuple2<AppDetail, JavaAppDetail>> associateDropletWithApplication(AppDetail detail) {
        log.trace("Attempting to fetch droplet id for {}/{}/{} whose state is {}", detail.getOrganization(), detail.getSpace(), detail.getAppName(), detail.getRequestedState());
            Mono<GetApplicationCurrentDropletResponse> currentResponse =
                DefaultCloudFoundryOperations.builder()
                    .from(opsClient)
                        .organization(detail.getOrganization())
                        .space(detail.getSpace())
                        .build()
                        .getCloudFoundryClient()
                        .applicationsV3()
                        .getCurrentDroplet(GetApplicationCurrentDropletRequest.builder().applicationId(detail.getAppId()).build());
            return currentResponse
                    .map(dr -> Tuples.of(detail, JavaAppDetail.from(detail).dropletId(dr.getId()).build()));
    }

    private Mono<JavaAppDetail> ascertainSpringDependencies(Tuple2<AppDetail, JavaAppDetail> tuple) {
        if (javaArtifactReader.mode().equalsIgnoreCase("list-jars")) {
            return
                artifactService
                    .obtainRuntimeMetadata(tuple.getT1())
                    .map(jad -> JavaAppDetail
                                    .from(tuple.getT2())
                                    .jars(jad.getJars())
                                    .springDependencies(javaArtifactReader.read(jad.getJars()).stream().collect(Collectors.joining("\n")))
                                    .build())
                    .onErrorResume(e -> {
                        log.error(String.format("Trouble ascertaining Spring dependencies for %s/%s/%s", tuple.getT2().getOrganization(), tuple.getT2().getSpace(), tuple.getT2().getAppName()), e);
                        return Mono.just(JavaAppDetail.from(tuple.getT2()).build());
                    });
        } else {
            log.warn("Not configured to ascertain Spring dependencies");
            return Mono.just(JavaAppDetail.from(tuple.getT2()).build());
        }
    }

    @Override
    public void onApplicationEvent(AppDetailRetrievedEvent event) {
        collect(List.copyOf(event.getDetail()));
    }

}


================================================
File: src/main/java/org/cftoolsuite/cfapp/task/OrganizationsTask.java
================================================
package org.cftoolsuite.cfapp.task;

import org.cftoolsuite.cfapp.domain.Organization;
import org.cftoolsuite.cfapp.event.OrganizationsRetrievedEvent;
import org.cftoolsuite.cfapp.event.TkRetrievedEvent;
import org.cftoolsuite.cfapp.service.OrganizationService;
import org.cloudfoundry.client.v3.organizations.ListOrganizationsRequest;
import org.cloudfoundry.operations.DefaultCloudFoundryOperations;
import org.cloudfoundry.util.PaginationUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.ApplicationEventPublisher;
import org.springframework.context.ApplicationListener;
import org.springframework.stereotype.Component;

import lombok.extern.slf4j.Slf4j;
import reactor.core.publisher.Flux;

@Slf4j
@Component
public class OrganizationsTask implements ApplicationListener<TkRetrievedEvent> {

    private final DefaultCloudFoundryOperations opsClient;
    private final OrganizationService organizationService;
    private ApplicationEventPublisher publisher;

    @Autowired
    public OrganizationsTask(
            DefaultCloudFoundryOperations opsClient,
            OrganizationService organizationService,
            ApplicationEventPublisher publisher) {
        this.opsClient = opsClient;
        this.organizationService = organizationService;
        this.publisher = publisher;
    }

    public void collect() {
        log.info("OrganizationTask started");
        organizationService
            .deleteAll()
            .thenMany(getOrganizations())
            .flatMap(organizationService::save)
            .thenMany(organizationService.findAll())
            .collectList()
            .subscribe(
                result -> {
                    publisher.publishEvent(new OrganizationsRetrievedEvent(this).organizations(result));
                    log.info("OrganizationTask completed. {} organizations found.", result.size());
                },
                error -> {
                    log.error("OrganizationTask terminated with error", error);
                }
            );
    }

    protected Flux<Organization> getOrganizations() {
        return PaginationUtils.requestClientV3Resources(
                page -> opsClient
                .getCloudFoundryClient()
                .organizationsV3()
                .list(ListOrganizationsRequest.builder().page(page).build()))
                .map(os -> new Organization(os.getId(), os.getName()));
    }

    @Override
    public void onApplicationEvent(TkRetrievedEvent event) {
        collect();
    }

}


================================================
File: src/main/java/org/cftoolsuite/cfapp/task/PoliciesLoader.java
================================================
package org.cftoolsuite.cfapp.task;

import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

import org.apache.commons.lang3.exception.ExceptionUtils;
import org.cftoolsuite.cfapp.client.GitClient;
import org.cftoolsuite.cfapp.config.GitSettings;
import org.cftoolsuite.cfapp.domain.ApplicationPolicy;
import org.cftoolsuite.cfapp.domain.EndpointPolicy;
import org.cftoolsuite.cfapp.domain.HygienePolicy;
import org.cftoolsuite.cfapp.domain.LegacyPolicy;
import org.cftoolsuite.cfapp.domain.Policies;
import org.cftoolsuite.cfapp.domain.PoliciesValidator;
import org.cftoolsuite.cfapp.domain.QueryPolicy;
import org.cftoolsuite.cfapp.domain.ResourceNotificationPolicy;
import org.cftoolsuite.cfapp.domain.ServiceInstancePolicy;
import org.cftoolsuite.cfapp.event.PoliciesLoadedEvent;
import org.cftoolsuite.cfapp.event.StacksRetrievedEvent;
import org.cftoolsuite.cfapp.service.PoliciesService;
import org.eclipse.jgit.lib.Repository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
import org.springframework.context.ApplicationEventPublisher;
import org.springframework.context.ApplicationListener;
import org.springframework.stereotype.Component;

import com.fasterxml.jackson.databind.ObjectMapper;

import lombok.extern.slf4j.Slf4j;

@Slf4j
@Component
@ConditionalOnProperty(
        prefix = "cf.policies.git", name = "uri"
        )
public class PoliciesLoader implements ApplicationListener<StacksRetrievedEvent> {

    private static final String APPLICATION_POLICY_SUFFIX = "-AP.json";
    private static final String SERVICE_INSTANCE_POLICY_SUFFIX = "-SIP.json";
    private static final String ENDPOINT_POLICY_SUFFIX = "-EP.json";
    private static final String QUERY_POLICY_SUFFIX = "-QP.json";
    private static final String HYGIENE_POLICY_SUFFIX = "-HP.json";
    private static final String RESOURCE_NOTIFICATION_POLICY_SUFFIX = "-RNP.json";
    private static final String LEGACY_POLICY_SUFFIX = "-LP.json";

    private final GitClient client;
    private final PoliciesService service;
    private final GitSettings settings;
    private final PoliciesValidator validator;
    private final ObjectMapper mapper;
    private ApplicationEventPublisher publisher;

    @Autowired
    public PoliciesLoader(
        GitClient client,
        PoliciesService service,
        GitSettings settings,
        PoliciesValidator validator,
        ObjectMapper mapper,
        ApplicationEventPublisher publisher
    ) {
        this.client = client;
        this.service = service;
        this.settings = settings;
        this.validator = validator;
        this.mapper = mapper;
        this.publisher = publisher;
    }

    public void load() {
        log.info("PoliciesLoader started");
        Repository repo = client.getRepository(settings);
        if (repo != null) {
            String uri = settings.getUri();
            List<ApplicationPolicy> applicationPolicies = new ArrayList<>();
            List<ServiceInstancePolicy> serviceInstancePolicies = new ArrayList<>();
            List<EndpointPolicy> endpointPolicies = new ArrayList<>();
            List<QueryPolicy> queryPolicies = new ArrayList<>();
            List<HygienePolicy> hygienePolicies = new ArrayList<>();
            List<ResourceNotificationPolicy> resourceNotificationPolicies = new ArrayList<>();
            List<LegacyPolicy> legacyPolicies = new ArrayList<>();
            String commit = client.orLatestCommit(settings.getCommit(), repo);
            log.info("-- Fetching policies from {} using commit {}", uri, commit);
            settings
            .getFilePaths()
            .stream()
            .filter(fp -> !fp.startsWith("#"))
            .forEach(fp -> {
                String fileContent;
                try {
                    fileContent = client.readFile(repo, commit, fp);
                    if (fp.endsWith(APPLICATION_POLICY_SUFFIX)) {
                        ApplicationPolicy policy = mapper.readValue(fileContent, ApplicationPolicy.class);
                        if (validator.validate(policy)) {
                            applicationPolicies.add(policy);
                        }
                    } else if (fp.endsWith(SERVICE_INSTANCE_POLICY_SUFFIX)) {
                        ServiceInstancePolicy policy = mapper.readValue(fileContent, ServiceInstancePolicy.class);
                        if (validator.validate(policy)) {
                            serviceInstancePolicies.add(policy);
                        }
                    } else if (fp.endsWith(ENDPOINT_POLICY_SUFFIX)) {
                        EndpointPolicy policy = mapper.readValue(fileContent, EndpointPolicy.class);
                        if (validator.validate(policy)) {
                            endpointPolicies.add(policy);
                        }
                    } else if (fp.endsWith(QUERY_POLICY_SUFFIX)) {
                        QueryPolicy policy = mapper.readValue(fileContent, QueryPolicy.class);
                        if (validator.validate(policy)) {
                            queryPolicies.add(policy);
                        }
                    } else if (fp.endsWith(HYGIENE_POLICY_SUFFIX)) {
                        HygienePolicy policy = mapper.readValue(fileContent, HygienePolicy.class);
                        if (validator.validate(policy)) {
                            hygienePolicies.add(policy);
                        }
                    } else if (fp.endsWith(RESOURCE_NOTIFICATION_POLICY_SUFFIX)) {
                        ResourceNotificationPolicy policy = mapper.readValue(fileContent, ResourceNotificationPolicy.class);
                        if (validator.validate(policy)) {
                            resourceNotificationPolicies.add(policy);
                        }
                    } else if (fp.endsWith(LEGACY_POLICY_SUFFIX)) {
                        LegacyPolicy policy = mapper.readValue(fileContent, LegacyPolicy.class);
                        if (validator.validate(policy)) {
                            legacyPolicies.add(policy);
                        }
                    } else {
                        log.warn(
                                "Policy file {} does not adhere to naming convention. File name must end with one of {}.",
                                fp, List.of(APPLICATION_POLICY_SUFFIX, SERVICE_INSTANCE_POLICY_SUFFIX, QUERY_POLICY_SUFFIX, HYGIENE_POLICY_SUFFIX, RESOURCE_NOTIFICATION_POLICY_SUFFIX, LEGACY_POLICY_SUFFIX));
                    }
                } catch (IOException e1) {
                    log.warn("Could not read {} from {} with commit {}. \n{} ", fp, uri, commit, ExceptionUtils.getMessage(e1));
                }
            });
            service
            .deleteAll()
            .then(service.save(
                    Policies
                    .builder()
                    .applicationPolicies(applicationPolicies)
                    .serviceInstancePolicies(serviceInstancePolicies)
                    .endpointPolicies(endpointPolicies)
                    .queryPolicies(queryPolicies)
                    .hygienePolicies(hygienePolicies)
                    .resourceNotificationPolicies(resourceNotificationPolicies)
                    .legacyPolicies(legacyPolicies)
                    .build()
                    ))
            .then(service.findAll())
            .subscribe(
                    result -> {
                        publisher.publishEvent(new PoliciesLoadedEvent(this).policies(result));
                        log.info("PoliciesLoader completed");
                        log.info(
                                String.format("-- Loaded %d application policies, %d service instance policies, %d endpoint policies, %d query policies, %d hygiene policies, %d resource notification policies, and %d legacy policies.",
                                        result.getApplicationPolicies().size(),
                                        result.getServiceInstancePolicies().size(),
                                        result.getEndpointPolicies().size(),
                                        result.getQueryPolicies().size(),
                                        result.getHygienePolicies().size(),
                                        result.getResourceNotificationPolicies().size(),
                                        result.getLegacyPolicies().size()
                                        )
                                );
                    },
                    error -> {
                        log.error("PoliciesLoader terminated with error", error);
                    }
                    );
        } else {
            log.error("PoliciesLoader terminated because it could not connect to Git repository");
        }
    }

    @Override
    public void onApplicationEvent(StacksRetrievedEvent event) {
        load();
    }

}


================================================
File: src/main/java/org/cftoolsuite/cfapp/task/PolicyExecutorTask.java
================================================
package org.cftoolsuite.cfapp.task;

public interface PolicyExecutorTask {
    void execute(String policyId);
}


================================================
File: src/main/java/org/cftoolsuite/cfapp/task/PolicyExecutorTaskScheduler.java
================================================
package org.cftoolsuite.cfapp.task;

import org.cftoolsuite.cfapp.domain.Policies;
import org.cftoolsuite.cfapp.domain.Policy;
import org.cftoolsuite.cfapp.event.PoliciesLoadedEvent;
import org.cftoolsuite.cfapp.service.PoliciesService;
import org.springframework.beans.factory.BeanFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.ApplicationListener;
import org.springframework.scheduling.TaskScheduler;
import org.springframework.scheduling.annotation.EnableScheduling;
import org.springframework.scheduling.support.CronTrigger;
import org.springframework.stereotype.Service;

import lombok.extern.slf4j.Slf4j;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

@Slf4j
@Service
@EnableScheduling
public class PolicyExecutorTaskScheduler implements ApplicationListener<PoliciesLoadedEvent> {

    private final BeanFactory factory;
    private final PoliciesService service;
    private final TaskScheduler scheduler;

    @Autowired
    public PolicyExecutorTaskScheduler(
        BeanFactory factory,
        PoliciesService service,
        TaskScheduler scheduler) {
        this.factory = factory;
        this.service = service;
        this.scheduler = scheduler;
    }

    public void scheduleTasks(Policies policies) {
        log.info("PolicyExecutorTaskScheduler started");
        service
            .getTaskMap()
            .flatMapMany(taskTypeMap ->
                Flux.fromIterable(taskTypeMap.entrySet())
                    .flatMap(entry -> {
                        String policyId = entry.getKey();
                        Class<? extends PolicyExecutorTask> taskClass = entry.getValue();
                        PolicyExecutorTask task = factory.getBean(taskClass);
                        Policy policy = policies.getById(policyId);
                        return
                            Mono
                                .fromRunnable(() ->
                                    scheduler.schedule(() ->
                                        task.execute(policyId), new CronTrigger(policy.getCronExpression())
                                    )
                                );
                    }))
            .count()
            .subscribe(
                result -> {
                    log.info("PolicyExecutorTaskScheduler completed. {} policies scheduled.", result);
                },
                error -> {
                    log.error("PolicyExecutorTaskScheduler terminated with error", error);
                }
            );
    }

    @Override
    public void onApplicationEvent(PoliciesLoadedEvent event) {
        scheduleTasks(event.getPolicies());
    }

}


================================================
File: src/main/java/org/cftoolsuite/cfapp/task/ProductsAndReleasesRetrievedListener.java
================================================
package org.cftoolsuite.cfapp.task;

import org.cftoolsuite.cfapp.event.AppDetailReadyToBeRetrievedEvent;
import org.cftoolsuite.cfapp.event.ProductsAndReleasesRetrievedEvent;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.ApplicationEventPublisher;
import org.springframework.context.ApplicationListener;
import org.springframework.stereotype.Component;

@Component
public class ProductsAndReleasesRetrievedListener implements ApplicationListener<ProductsAndReleasesRetrievedEvent> {

    private final ApplicationEventPublisher publisher;
    private final AppDetailReadyToBeCollectedDecider appDetailReadyToBeCollectedDecider;

    @Autowired
    public ProductsAndReleasesRetrievedListener(
            ApplicationEventPublisher publisher,
            AppDetailReadyToBeCollectedDecider appDetailReadyToBeCollectedDecider) {
        this.publisher = publisher;
        this.appDetailReadyToBeCollectedDecider = appDetailReadyToBeCollectedDecider;
    }

    @Override
    public void onApplicationEvent(ProductsAndReleasesRetrievedEvent event) {
        appDetailReadyToBeCollectedDecider.informDecision();
        publisher.publishEvent(new AppDetailReadyToBeRetrievedEvent(this));
    }

}


================================================
File: src/main/java/org/cftoolsuite/cfapp/task/ProductsAndReleasesTask.java
================================================
package org.cftoolsuite.cfapp.task;

import org.cftoolsuite.cfapp.client.PivnetClient;
import org.cftoolsuite.cfapp.domain.product.PivnetCache;
import org.cftoolsuite.cfapp.event.ProductsAndReleasesRetrievedEvent;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.ApplicationArguments;
import org.springframework.boot.ApplicationRunner;
import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
import org.springframework.context.ApplicationEventPublisher;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Component;

import lombok.extern.slf4j.Slf4j;
import reactor.core.publisher.Mono;

@Slf4j
@Component
@ConditionalOnProperty(name = "pivnet.enabled", havingValue = "true")
public class ProductsAndReleasesTask implements ApplicationRunner {

    private final PivnetClient client;
    private final PivnetCache cache;
    private final ApplicationEventPublisher publisher;

    @Autowired
    public ProductsAndReleasesTask(
            PivnetClient client,
            PivnetCache cache,
            ApplicationEventPublisher publisher) {
        this.client = client;
        this.cache = cache;
        this.publisher = publisher;
    }

    public void collect() {
        log.info("ProductsAndReleasesTask started");
        client
            .getProducts()
            .flatMap(products -> {
                cache.setProducts(products);
                return Mono.empty();
            })
            .then(
                client
                    .getAllProductReleases()
                    .collectList()
                    .flatMap(releases -> {
                        cache.setAllProductReleases(releases);
                        return Mono.empty();
                    })
            )
            .then(
                client
                    .getLatestProductReleases()
                    .collectList()
                    .flatMap(releases -> {
                        cache.setLatestProductReleases(releases);
                        return Mono.justOrEmpty(releases);
                    })
            )
            .subscribe(
                result -> {
                    publisher.publishEvent(
                        new ProductsAndReleasesRetrievedEvent(this)
                            .products(cache.getProducts())
                            .allReleases(cache.getAllProductReleases())
                            .latestReleases(cache.getLatestProductReleases()));
                    log.info("ProductsAndReleasesTask completed");
                },
                error -> {
                    log.error("ProductsAndReleasesTask terminated with error", error);
                }
            );
    }

    @Override
    public void run(ApplicationArguments args) throws Exception {
        collect();
    }

    @Scheduled(cron = "${cron.collection}")
    protected void runTask() {
        collect();
    }
}


================================================
File: src/main/java/org/cftoolsuite/cfapp/task/QueryPolicyExecutorTask.java
================================================
package org.cftoolsuite.cfapp.task;

import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import java.util.stream.Collectors;

import org.apache.commons.lang3.StringUtils;
import org.cftoolsuite.cfapp.config.PasSettings;
import org.cftoolsuite.cfapp.domain.Defaults;
import org.cftoolsuite.cfapp.domain.EmailAttachment;
import org.cftoolsuite.cfapp.domain.Query;
import org.cftoolsuite.cfapp.domain.QueryPolicy;
import org.cftoolsuite.cfapp.event.EmailNotificationEvent;
import org.cftoolsuite.cfapp.service.PoliciesService;
import org.cftoolsuite.cfapp.service.QueryService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.ApplicationEventPublisher;
import org.springframework.stereotype.Component;

import io.r2dbc.spi.Row;
import io.r2dbc.spi.RowMetadata;
import lombok.extern.slf4j.Slf4j;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;
import reactor.util.function.Tuple2;
import reactor.util.function.Tuples;

@Slf4j
@Component
public class QueryPolicyExecutorTask implements PolicyExecutorTask {

    private final PasSettings settings;
    private final PoliciesService policiesService;
    private final QueryService queryService;
    private final ApplicationEventPublisher publisher;

    @Autowired
    public QueryPolicyExecutorTask(
            PasSettings settings,
            PoliciesService policiesService,
            QueryService queryService,
            ApplicationEventPublisher publisher
            ) {
        this.settings = settings;
        this.policiesService = policiesService;
        this.queryService = queryService;
        this.publisher = publisher;
    }

    @Override
    public void execute(String id) {
        log.info("QueryPolicyExecutorTask with id={} started", id);
        fetchQueryPolicy(id)
        .concatMap(qp -> executeQueries(qp).collectList().map(result -> Tuples.of(qp, result)))
        .collectList()
        .subscribe(
            results -> {
                results.forEach(
                        result ->
                        publisher.publishEvent(
                                new EmailNotificationEvent(this)
                                .domain(settings.getAppsDomain())
                                .from(result.getT1().getEmailNotificationTemplate().getFrom())
                                .recipients(result.getT1().getEmailNotificationTemplate().getTo())
                                .carbonCopyRecipients(result.getT1().getEmailNotificationTemplate().getCc())
                                .blindCarbonCopyRecipients(result.getT1().getEmailNotificationTemplate().getBcc())
                                .subject(result.getT1().getEmailNotificationTemplate().getSubject())
                                .body(result.getT1().getEmailNotificationTemplate().getBody())
                                .attachments(buildAttachments(result.getT2()))
                                )
                        );
                log.info("QueryPolicyExecutorTask with id={} completed", id);
            },
            error -> {
                log.error(String.format("QueryPolicyExecutorTask with id=%s terminated with error", id), error);
            }
        );
    }

    protected Flux<Tuple2<String, String>> executeQueries(QueryPolicy policy) {
        return Flux
                .fromIterable(policy.getQueries())
                .concatMap(q -> executeQuery(q).map(result -> Tuples.of(q.getName(), result)));
    }

    protected Mono<String> executeQuery(Query query) {
        Flux<Tuple2<Row, RowMetadata>> results =
            queryService
                .executeQuery(query);
        return results
                .flatMap(QueryPolicyExecutorTask::toCommaSeparatedValue)
                .collectList()
                .flatMap(QueryPolicyExecutorTask::constructCsvOutput);
    }

    protected Flux<QueryPolicy> fetchQueryPolicy(String id) {
        return
            policiesService
                .findQueryPolicyById(id)
                .flatMapMany(policy -> Flux.fromIterable(policy.getQueryPolicies()));
    }

    private static List<EmailAttachment> buildAttachments(List<Tuple2<String, String>> tuples) {
        List<EmailAttachment> result = new ArrayList<>();
        for (Tuple2<String, String> t: tuples) {
            if (StringUtils.isNotBlank(t.getT2())) {
                result.add(
                        EmailAttachment
                        .builder()
                        .filename(t.getT1())
                        .content(t.getT2())
                        .extension(".csv")
                        .mimeType("text/plain")
                        .build()
                        );
            } else {
                result.add(
                        EmailAttachment
                        .builder()
                        .filename(t.getT1())
                        .content("No results.")
                        .extension(".csv")
                        .mimeType("text/plain")
                        .build()
                        );
            }
        }
        return result;
    }

    private static Mono<String> constructCsvOutput(List<Tuple2<Collection<String>, String>> columnNamesAndRows) {
        StringBuilder builder = new StringBuilder();
        int i = 0;
        for (Tuple2<Collection<String>, String> tuple: columnNamesAndRows) {
            if (i == 0) {
                List<String> headerRow = new ArrayList<>();
                headerRow.addAll(tuple.getT1());
                builder.append(String.join(",", headerRow));
            }
            builder.append(System.getProperty("line.separator"));
            builder.append(tuple.getT2());
            i++;
        }
        return Mono.just(builder.toString());
    }

    private static Mono<Tuple2<Collection<String>, String>> toCommaSeparatedValue(Tuple2<Row, RowMetadata> tuple) {
        Collection<String> columnNames = tuple.getT2().getColumnMetadatas().stream().map(columnName -> columnName.getName()).toList();
        List<String> rawValueList =
            columnNames
                .stream()
                .map(columnName -> wrap(Defaults.getColumnValueOrDefault(tuple.getT1(), columnName, "").toString()))
                .collect(Collectors.toList());
        return Mono.just(Tuples.of(columnNames, String.join(",", rawValueList)));
    }

    private static String wrap(String value) {
        return value != null ? StringUtils.wrap(value, '"') : StringUtils.wrap("", '"');
    }
}


================================================
File: src/main/java/org/cftoolsuite/cfapp/task/ResourceNotificationPolicyExecutorTask.java
================================================
package org.cftoolsuite.cfapp.task;

import java.time.Duration;
import java.util.HashSet;
import java.util.Set;
import java.util.stream.Collectors;

import org.cftoolsuite.cfapp.config.PasSettings;
import org.cftoolsuite.cfapp.domain.ResourceNotificationPolicy;
import org.cftoolsuite.cfapp.event.EmailNotificationEvent;
import org.cftoolsuite.cfapp.service.PoliciesService;
import org.cftoolsuite.cfapp.service.ResourceMetadataService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.ApplicationEventPublisher;
import org.springframework.stereotype.Component;
import org.springframework.util.CollectionUtils;

import lombok.extern.slf4j.Slf4j;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

@Slf4j
@Component
public class ResourceNotificationPolicyExecutorTask implements PolicyExecutorTask {

    private final PasSettings settings;

    private final PoliciesService policiesService;

    private final ApplicationEventPublisher publisher;

    private final ResourceMetadataService resourceMetadataService;


    @Autowired
    public ResourceNotificationPolicyExecutorTask(
        PasSettings settings,
        PoliciesService policiesService,
        ApplicationEventPublisher publisher,
        ResourceMetadataService resourceMetadataService) {
                this.settings = settings;
                this.policiesService = policiesService;
                this.publisher = publisher;
                this.resourceMetadataService = resourceMetadataService;
        }

    @Override
    public void execute(String id) {
        log.info("ResourceNotificationPolicyExecutorTask with id={} started", id);
        fetchResourceNotificationPolicy(id)
            .collectList()
            .subscribe(
                results -> {
                    results.forEach(mp -> {
                        mp.getResourceEmailMetadata().getLabels().forEach(label -> {
                            notifyOwners(mp,label);
                        });
                    });
                    log.info("ResourceNotificationPolicyExecutorTask with id={} completed", id);
                },
                error -> {
                    log.error(String.format("ResourceNotificationPolicyExecutorTask with id=%s terminated with error", id), error);
                }
            );
    }

    protected Flux<ResourceNotificationPolicy> fetchResourceNotificationPolicy(String id) {
        return
            policiesService
                .findResourceNotificationPolicyById(id)
                .flatMapMany(policy -> Flux.fromIterable(policy.getResourceNotificationPolicies()));
    }

    private Mono<Set<String>> fetchRecipientList(ResourceNotificationPolicy resourceNotificationPolicy, String label, Integer page, Integer perPage){
        return
            resourceMetadataService.getResources(resourceNotificationPolicy.getResourceEmailMetadata().getResource(), label, page, perPage)
                .flatMapMany(resources -> Flux.fromIterable(resources.getResources()))
                .delayElements(Duration.ofMillis(250))
                .filter(resource -> isBlacklisted(resourceNotificationPolicy, resource.getName()))
                .filter(resource -> isWhitelisted(resourceNotificationPolicy, resource.getName()))
                .map(resource -> new String(resource.getMetadata().getLabels().get(label) + "@" + resourceNotificationPolicy.getResourceEmailMetadata().getEmailDomain()))
                .collect(Collectors.toSet());
    }

    private void notifyOwners(ResourceNotificationPolicy resourceNotificationPolicy, String label) {
        resourceMetadataService.getResources(resourceNotificationPolicy.getResourceEmailMetadata().getResource(), label , null , null)
            .delayElement(Duration.ofMillis(250))
            .doOnNext(resources -> {
                for (Integer page=1; page <= resources.getPagination().getTotalPages(); page++) {
                    fetchRecipientList(resourceNotificationPolicy, label, page, null)
                        .doOnNext(
                                recipients -> {
                                    publisher.publishEvent(
                                        new EmailNotificationEvent(this)
                                            .domain(settings.getAppsDomain())
                                            .from(resourceNotificationPolicy.getResourceEmailTemplate().getFrom())
                                            .recipients(recipients)
                                            .subject(resourceNotificationPolicy.getResourceEmailTemplate().getSubject())
                                            .body(resourceNotificationPolicy.getResourceEmailTemplate().getBody()));
                                })
                        .subscribe();
                    }
                })
            .subscribe();
    }

    private boolean isBlacklisted(ResourceNotificationPolicy policy, String resource) {
        return !policy.getResourceBlackList().contains(resource);
    }


    private boolean isWhitelisted(ResourceNotificationPolicy policy, String resource) {
        Set<String> prunedSet = new HashSet<>(policy.getResourceWhiteList());
        while (prunedSet.remove(""));
        Set<String> whitelist =
                CollectionUtils.isEmpty(prunedSet) ?
                        prunedSet: policy.getResourceWhiteList();
        return
                whitelist.isEmpty() ? true: policy.getResourceWhiteList().contains(resource);
    }

}

================================================
File: src/main/java/org/cftoolsuite/cfapp/task/ScaleAppInstancesPolicyExecutorTask.java
================================================
package org.cftoolsuite.cfapp.task;

import java.time.LocalDateTime;
import java.util.List;

import org.cftoolsuite.cfapp.domain.AppDetail;
import org.cftoolsuite.cfapp.domain.ApplicationOperation;
import org.cftoolsuite.cfapp.domain.ApplicationPolicy;
import org.cftoolsuite.cfapp.domain.HistoricalRecord;
import org.cftoolsuite.cfapp.service.AppDetailService;
import org.cftoolsuite.cfapp.service.HistoricalRecordService;
import org.cftoolsuite.cfapp.service.PoliciesService;
import org.cftoolsuite.cfapp.util.PolicyFilter;
import org.cloudfoundry.operations.DefaultCloudFoundryOperations;
import org.cloudfoundry.operations.applications.ScaleApplicationRequest;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import lombok.extern.slf4j.Slf4j;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

@Slf4j
@Component
public class ScaleAppInstancesPolicyExecutorTask implements PolicyExecutorTask {

    private PolicyFilter filter;
    private DefaultCloudFoundryOperations opsClient;
    private AppDetailService appInfoService;
    private PoliciesService policiesService;
    private HistoricalRecordService historicalRecordService;

    @Autowired
    public ScaleAppInstancesPolicyExecutorTask(
        PolicyFilter filter,
            DefaultCloudFoundryOperations opsClient,
            AppDetailService appInfoService,
            PoliciesService policiesService,
            HistoricalRecordService historicalRecordService
            ) {
        this.filter = filter;
        this.opsClient = opsClient;
        this.appInfoService = appInfoService;
        this.policiesService = policiesService;
        this.historicalRecordService = historicalRecordService;
    }

    @Override
    public void execute(String id) {
        log.info("ScaleAppInstancesPolicyExecutorTask with id={} started", id);
        scaleApplications(id)
            .subscribe(
                result -> {
                    log.info("ScaleAppInstancesPolicyExecutorTask with id={} completed", id);
                    log.info("-- {} applications scaled.", result.size());
                },
                error -> {
                    log.error(String.format("ScaleAppInstancesPolicyExecutorTask with id=%s terminated with error", id), error);
                }
            );
    }

    protected Mono<HistoricalRecord> scaleApplication(ApplicationPolicy policy, AppDetail detail) {
        return DefaultCloudFoundryOperations.builder()
                .from(opsClient)
                .organization(detail.getOrganization())
                .space(detail.getSpace())
                .build()
                .applications()
                .scale(
                    ScaleApplicationRequest
                        .builder()
                        .name(detail.getAppName())
                        .instances(policy.getOption("instances-to", Integer.class))
                        .build()
                )
                .then(
                    Mono.just(
                        HistoricalRecord
                            .builder()
                            .transactionDateTime(LocalDateTime.now())
                            .actionTaken("scale-instances")
                            .organization(detail.getOrganization())
                            .space(detail.getSpace())
                            .appId(detail.getAppId())
                            .type("application")
                            .name(detail.getAppName())
                            .build()
                    )
                );
    }

    protected Mono<List<HistoricalRecord>> scaleApplications(String id) {
        return
            policiesService
                .findByApplicationOperation(ApplicationOperation.SCALE_INSTANCES)
                .flux()
                .flatMap(p -> Flux.fromIterable(p.getApplicationPolicies()))
                .filter(ap -> ap.getId().equals(id))
                .flatMap(ap -> Flux.concat(appInfoService.findByApplicationPolicy(ap, false), appInfoService.findByApplicationPolicy(ap, true)))
                .distinct()
                .filter(wl -> filter.isWhitelisted(wl.getT2(), wl.getT1().getOrganization()))
                .filter(bl -> filter.isBlacklisted(bl.getT1().getOrganization(), bl.getT1().getSpace()))
                .filter(from -> from.getT1().getRunningInstances() >= from.getT2().getOption("instances-from", Integer.class))
                .flatMap(ad -> scaleApplication(ad.getT2(), ad.getT1()))
                .flatMap(historicalRecordService::save)
                .collectList();
    }
}


================================================
File: src/main/java/org/cftoolsuite/cfapp/task/ServiceInstanceDetailTask.java
================================================
package org.cftoolsuite.cfapp.task;

import java.time.Instant;
import java.time.ZoneId;
import java.util.List;

import org.apache.commons.lang3.StringUtils;
import org.cftoolsuite.cfapp.domain.ServiceInstanceDetail;
import org.cftoolsuite.cfapp.domain.Space;
import org.cftoolsuite.cfapp.event.ServiceInstanceDetailRetrievedEvent;
import org.cftoolsuite.cfapp.event.SpacesRetrievedEvent;
import org.cftoolsuite.cfapp.service.ServiceInstanceDetailService;
import org.cloudfoundry.operations.DefaultCloudFoundryOperations;
import org.cloudfoundry.operations.services.GetServiceInstanceRequest;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.ApplicationEventPublisher;
import org.springframework.context.ApplicationListener;
import org.springframework.stereotype.Component;

import lombok.extern.slf4j.Slf4j;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

@Slf4j
@Component
public class ServiceInstanceDetailTask implements ApplicationListener<SpacesRetrievedEvent> {

    private DefaultCloudFoundryOperations opsClient;
    private ServiceInstanceDetailService service;
    private ApplicationEventPublisher publisher;

    @Autowired
    public ServiceInstanceDetailTask(
            DefaultCloudFoundryOperations opsClient,
            ServiceInstanceDetailService service,
            ApplicationEventPublisher publisher
            ) {
        this.opsClient = opsClient;
        this.service = service;
        this.publisher = publisher;
    }

    private DefaultCloudFoundryOperations buildClient(Space target) {
        return DefaultCloudFoundryOperations
                .builder()
                .from(opsClient)
                .organization(target.getOrganizationName())
                .space(target.getSpaceName())
                .build();
    }

    public void collect(List<Space> spaces) {
        log.info("ServiceInstanceDetailTask started");
        service
            .deleteAll()
            .thenMany(Flux.fromIterable(spaces))
            .concatMap(this::listServiceInstances)
            .flatMap(this::getServiceInstanceDetail)
            .flatMap(service::save)
            .thenMany(service.findAll())
            .collectList()
            .subscribe(
                result -> {
                    publisher.publishEvent(new ServiceInstanceDetailRetrievedEvent(this).detail(result));
                    log.info("ServiceInstanceDetailTask completed. {} service instances found.", result.size());
                },
                error -> {
                    log.error("ServiceInstanceDetailTask terminated with error", error);
                }
            );
    }

    protected Mono<ServiceInstanceDetail> getServiceInstanceDetail(ServiceInstanceDetail fragment) {
        log.trace("Fetching service instance detail for org={}, space={}, id={}, name={}", fragment.getOrganization(), fragment.getSpace(), fragment.getServiceInstanceId(), fragment.getName());
        return buildClient(buildSpace(fragment.getOrganization(), fragment.getSpace()))
                .services()
                .getInstance(GetServiceInstanceRequest.builder().name(fragment.getName()).build())
                .map(sid ->
                    ServiceInstanceDetail
                        .from(fragment)
                        .description(sid.getDescription())
                        .type(sid.getType() != null ? sid.getType().getValue(): null)
                        .lastOperation(sid.getLastOperation())
                        .lastUpdated(StringUtils.isNotBlank(sid.getUpdatedAt()) ? Instant.parse(sid.getUpdatedAt())
                                .atZone(ZoneId.systemDefault())
                                .toLocalDateTime() : null)
                        .dashboardUrl(sid.getDashboardUrl())
                        .requestedState(StringUtils.isNotBlank(sid.getStatus()) ? sid.getStatus().toLowerCase(): null)
                        .build()
                )
                .onErrorResume(e -> Mono.just(fragment));
    }

    protected Flux<ServiceInstanceDetail> listServiceInstances(Space target) {
        return
            buildClient(target)
                .services()
                .listInstances()
                .map(sis ->
                    ServiceInstanceDetail
                        .builder()
                        .serviceInstanceId(sis.getId())
                        .organization(target.getOrganizationName())
                        .space(target.getSpaceName())
                        .name(sis.getName() != null ? sis.getName(): "user_provided_service")
                        .service(sis.getService())
                        .plan(sis.getPlan())
                        .applications(sis.getApplications())
                        .build()
                );
    }

    @Override
    public void onApplicationEvent(SpacesRetrievedEvent event) {
        collect(List.copyOf(event.getSpaces()));
    }

    private static Space buildSpace(String organization, String space) {
        return Space
                .builder()
                .organizationName(organization)
                .spaceName(space)
                .build();
    }
}


================================================
File: src/main/java/org/cftoolsuite/cfapp/task/SpaceUsersTask.java
================================================
package org.cftoolsuite.cfapp.task;

import java.util.List;

import org.cftoolsuite.cfapp.domain.Space;
import org.cftoolsuite.cfapp.domain.SpaceUsers;
import org.cftoolsuite.cfapp.event.SpacesRetrievedEvent;
import org.cftoolsuite.cfapp.service.SpaceUsersService;
import org.cloudfoundry.operations.DefaultCloudFoundryOperations;
import org.cloudfoundry.operations.useradmin.ListSpaceUsersRequest;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.ApplicationListener;
import org.springframework.stereotype.Component;

import lombok.extern.slf4j.Slf4j;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

@Slf4j
@Component
public class SpaceUsersTask implements ApplicationListener<SpacesRetrievedEvent> {

    private DefaultCloudFoundryOperations opsClient;
    private SpaceUsersService service;

    @Autowired
    public SpaceUsersTask(
            DefaultCloudFoundryOperations opsClient,
            SpaceUsersService service) {
        this.opsClient = opsClient;
        this.service = service;
    }

    public void collect(List<Space> spaces) {
        log.info("SpaceUsersTask started");
        service
            .deleteAll()
            .thenMany(Flux.fromIterable(spaces))
            .concatMap(this::getSpaceUsers)
            .flatMap(service::save)
            .thenMany(service.findAll())
            .collectList()
            .subscribe(
                result -> {
                    log.info("SpaceUsersTask completed. {} space users found.", result.size());
                },
                error -> {
                    log.error("SpaceUsersTask terminated with error", error);
                }
            );
    }

    protected Mono<SpaceUsers> getSpaceUsers(Space space) {
        log.trace("Fetching space users in org={} and space={}", space.getOrganizationName(), space.getSpaceName());
        return opsClient
                .userAdmin()
                .listSpaceUsers(
                    ListSpaceUsersRequest
                        .builder()
                        .organizationName(space.getOrganizationName())
                        .spaceName(space.getSpaceName())
                        .build()
                )
                .map(su ->
                    SpaceUsers
                        .builder()
                        .organization(space.getOrganizationName())
                        .space(space.getSpaceName())
                        .auditors(su.getAuditors())
                        .managers(su.getManagers())
                        .developers(su.getDevelopers())
                        .build()
                );
    }

    @Override
    public void onApplicationEvent(SpacesRetrievedEvent event) {
        collect(List.copyOf(event.getSpaces()));
    }

}


================================================
File: src/main/java/org/cftoolsuite/cfapp/task/SpacesRetrievedListener.java
================================================
package org.cftoolsuite.cfapp.task;

import org.cftoolsuite.cfapp.event.AppDetailReadyToBeRetrievedEvent;
import org.cftoolsuite.cfapp.event.SpacesRetrievedEvent;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.ApplicationEventPublisher;
import org.springframework.context.ApplicationListener;
import org.springframework.stereotype.Component;

@Component
public class SpacesRetrievedListener implements ApplicationListener<SpacesRetrievedEvent> {

    private final ApplicationEventPublisher publisher;
    private final AppDetailReadyToBeCollectedDecider appDetailReadyToBeCollectedDecider;

    @Autowired
    public SpacesRetrievedListener(
            ApplicationEventPublisher publisher,
            AppDetailReadyToBeCollectedDecider appDetailReadyToBeCollectedDecider) {
        this.publisher = publisher;
        this.appDetailReadyToBeCollectedDecider = appDetailReadyToBeCollectedDecider;
    }

    @Override
    public void onApplicationEvent(SpacesRetrievedEvent event) {
        appDetailReadyToBeCollectedDecider.informDecision();
        appDetailReadyToBeCollectedDecider.setSpaces(event.getSpaces());
        publisher.publishEvent(new AppDetailReadyToBeRetrievedEvent(this));
    }
}


================================================
File: src/main/java/org/cftoolsuite/cfapp/task/SpacesTask.java
================================================
package org.cftoolsuite.cfapp.task;

import java.util.List;

import org.cftoolsuite.cfapp.domain.Organization;
import org.cftoolsuite.cfapp.domain.Space;
import org.cftoolsuite.cfapp.event.OrganizationsRetrievedEvent;
import org.cftoolsuite.cfapp.event.SpacesRetrievedEvent;
import org.cftoolsuite.cfapp.service.SpaceService;
import org.cloudfoundry.client.v3.spaces.ListSpacesRequest;
import org.cloudfoundry.operations.DefaultCloudFoundryOperations;
import org.cloudfoundry.util.PaginationUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.ApplicationEventPublisher;
import org.springframework.context.ApplicationListener;
import org.springframework.stereotype.Component;

import lombok.extern.slf4j.Slf4j;
import reactor.core.publisher.Flux;

@Slf4j
@Component
public class SpacesTask implements ApplicationListener<OrganizationsRetrievedEvent> {

    private final DefaultCloudFoundryOperations opsClient;
    private final SpaceService service;
    private final ApplicationEventPublisher publisher;

    @Autowired
    public SpacesTask(
            DefaultCloudFoundryOperations opsClient,
            SpaceService service,
            ApplicationEventPublisher publisher) {
        this.opsClient = opsClient;
        this.service = service;
        this.publisher = publisher;
    }

    public void collect(List<Organization> organizations) {
        log.info("SpacesTask started");
        service
            .deleteAll()
            .thenMany(Flux.fromIterable(organizations))
            .flatMap(this::getSpaces)
            .flatMap(service::save)
            .thenMany(service.findAll())
            .collectList()
            .subscribe(
                result -> {
                    publisher.publishEvent(new SpacesRetrievedEvent(this).spaces(result));
                    log.info("SpacesTask completed. {} spaces found.", result.size());
                },
                error -> {
                    log.error("SpacesTask terminated with error", error);
                }
            );
    }

    protected Flux<Space> getSpaces(Organization organization) {
        return PaginationUtils.requestClientV3Resources(
                page ->
                    opsClient
                        .getCloudFoundryClient()
                        .spacesV3()
                        .list(ListSpacesRequest.builder().page(page).organizationIds(new String[] { organization.getId() }).build()))
                        .map(response ->
                            Space
                                .builder()
                                .organizationId(organization.getId())
                                .organizationName(organization.getName())
                                .spaceId(response.getId())
                                .spaceName(response.getName())
                                .build()
                        );
    }

    @Override
    public void onApplicationEvent(OrganizationsRetrievedEvent event) {
        collect(List.copyOf(event.getOrganizations()));
    }

}


================================================
File: src/main/java/org/cftoolsuite/cfapp/task/StackChangeAppInstancesPolicyExecutorTask.java
================================================
package org.cftoolsuite.cfapp.task;

import java.time.Duration;
import java.time.LocalDateTime;
import java.util.List;
import java.util.Optional;
import java.util.function.Predicate;

import org.cftoolsuite.cfapp.domain.AppDetail;
import org.cftoolsuite.cfapp.domain.ApplicationOperation;
import org.cftoolsuite.cfapp.domain.ApplicationPolicy;
import org.cftoolsuite.cfapp.domain.HistoricalRecord;
import org.cftoolsuite.cfapp.service.AppDetailService;
import org.cftoolsuite.cfapp.service.HistoricalRecordService;
import org.cftoolsuite.cfapp.service.PoliciesService;
import org.cftoolsuite.cfapp.util.PolicyFilter;
import org.cloudfoundry.client.v3.Lifecycle;
import org.cloudfoundry.client.v3.LifecycleData;
import org.cloudfoundry.client.v3.LifecycleType;
import org.cloudfoundry.client.v3.Relationship;
import org.cloudfoundry.client.v3.applications.SetApplicationCurrentDropletRequest;
import org.cloudfoundry.client.v3.applications.SetApplicationCurrentDropletResponse;
import org.cloudfoundry.client.v3.applications.UpdateApplicationRequest;
import org.cloudfoundry.client.v3.applications.UpdateApplicationResponse;
import org.cloudfoundry.client.v3.builds.BuildState;
import org.cloudfoundry.client.v3.builds.CreateBuildRequest;
import org.cloudfoundry.client.v3.builds.CreateBuildResponse;
import org.cloudfoundry.client.v3.builds.GetBuildRequest;
import org.cloudfoundry.client.v3.builds.GetBuildResponse;
import org.cloudfoundry.client.v3.packages.ListPackagesRequest;
import org.cloudfoundry.client.v3.packages.PackageResource;
import org.cloudfoundry.client.v3.packages.PackageState;
import org.cloudfoundry.operations.DefaultCloudFoundryOperations;
import org.cloudfoundry.operations.applications.RestartApplicationRequest;
import org.cloudfoundry.util.DelayTimeoutException;
import org.cloudfoundry.util.DelayUtils;
import org.cloudfoundry.util.ExceptionUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import lombok.Builder;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

@Slf4j
@Component
public class StackChangeAppInstancesPolicyExecutorTask implements PolicyExecutorTask {

    private final PolicyFilter filter;
    private final DefaultCloudFoundryOperations opsClient;
    private final AppDetailService appInfoService;
    private final PoliciesService policiesService;
    private final HistoricalRecordService historicalRecordService;

    @Autowired
    public StackChangeAppInstancesPolicyExecutorTask(
            PolicyFilter filter,
            DefaultCloudFoundryOperations opsClient,
            AppDetailService appInfoService,
            PoliciesService policiesService,
            HistoricalRecordService historicalRecordService
            ) {
        this.filter = filter;
        this.opsClient = opsClient;
        this.appInfoService = appInfoService;
        this.policiesService = policiesService;
        this.historicalRecordService = historicalRecordService;
    }

    private Mono<UpdateApplicationResponse> assignTargetStack(ApplicationPolicy policy, AppDetail detail) {
        LifecycleData data =
            BuildpackLifecycleData
                .builder()
                .stack(policy.getOption("stack-to", String.class))
                .build();
        Lifecycle lifecycle =
            Lifecycle
                .builder()
                .type(LifecycleType.BUILDPACK)
                .data(data)
                .build();
        return DefaultCloudFoundryOperations.builder()
                .from(opsClient)
                .organization(detail.getOrganization())
                .space(detail.getSpace())
                .build()
                .getCloudFoundryClient()
                .applicationsV3()
                .update(
                    UpdateApplicationRequest
                        .builder()
                        .applicationId(detail.getAppId())
                        .lifecycle(lifecycle)
                        .build()
                );
    }

    private Mono<CreateBuildResponse> createBuild(PackageResource packageResource, AppDetail detail) {
        log.info("Attempting to create build with package {}", packageResource);
        Relationship pkg = Relationship.builder().id(packageResource.getId()).build();
        return DefaultCloudFoundryOperations.builder()
                .from(opsClient)
                .organization(detail.getOrganization())
                .space(detail.getSpace())
                .build()
                .getCloudFoundryClient()
                .builds()
                .create(CreateBuildRequest.builder().getPackage(pkg).build());
    }

    @Override
    public void execute(String id) {
        log.info("StackChangeAppInstancesPolicyExecutorTask with id={} started", id);
        stackChangeApplications(id)
            .subscribe(
                result -> {
                    log.info("StackChangeAppInstancesPolicyExecutorTask with id={} completed", id);
                    log.info("-- {} applications updated.", result.size());
                },
                error -> {
                    log.error(String.format("StackChangeAppInstancesPolicyExecutorTask with id=%s terminated with error", id), error);
                }
            );
    }

    private Mono<GetBuildResponse> getBuild(CreateBuildResponse build, AppDetail detail) {
        return DefaultCloudFoundryOperations.builder()
                .from(opsClient)
                .organization(detail.getOrganization())
                .space(detail.getSpace())
                .build()
                .getCloudFoundryClient()
                .builds()
                .get(GetBuildRequest.builder().buildId(build.getId()).build());
    }

    private Mono<PackageResource> getPackage(UpdateApplicationResponse updatedApplication, AppDetail detail) {
        log.info("Attempting to fetch package from {}", updatedApplication.getLinks().get("packages").getHref());
        return DefaultCloudFoundryOperations.builder()
                .from(opsClient)
                .organization(detail.getOrganization())
                .space(detail.getSpace())
                .build()
                .getCloudFoundryClient()
                .packages()
                .list(ListPackagesRequest.builder().applicationId(detail.getAppId()).build())
                .flatMapMany(response -> Flux.fromIterable(response.getResources()))
                .filter(resource -> resource.getState().equals(PackageState.READY))
                .next();
    }

    private Mono<Void> restartApp(AppDetail detail) {
        return DefaultCloudFoundryOperations.builder()
                .from(opsClient)
                .organization(detail.getOrganization())
                .space(detail.getSpace())
                .build()
                .applications()
                .restart(RestartApplicationRequest.builder().name(detail.getAppName()).build());
    }

    private Mono<SetApplicationCurrentDropletResponse> setDroplet(GetBuildResponse build, AppDetail detail) {
        Relationship data = Relationship.builder().id(build.getDroplet().getId()).build();
        return DefaultCloudFoundryOperations.builder()
                .from(opsClient)
                .organization(detail.getOrganization())
                .space(detail.getSpace())
                .build()
                .getCloudFoundryClient()
                .applicationsV3()
                .setCurrentDroplet(SetApplicationCurrentDropletRequest.builder().applicationId(detail.getAppId()).data(data).build());
    }

    protected Mono<HistoricalRecord> stackChangeApplication(ApplicationPolicy policy, AppDetail detail) {
        return assignTargetStack(policy, detail)
                .flatMap(updatedApp -> getPackage(updatedApp, detail))
                .flatMap(pkg -> createBuild(pkg, detail))
                .flatMap(build -> waitForStagedBuild(build, detail, null))
                .flatMap(build -> setDroplet(build, detail))
                .flatMap(build -> restartApp(detail))
                .then(
                    Mono.just(
                        HistoricalRecord
                            .builder()
                            .transactionDateTime(LocalDateTime.now())
                            .actionTaken("change-stack")
                            .organization(detail.getOrganization())
                            .space(detail.getSpace())
                            .appId(detail.getAppId())
                            .type("application")
                            .name(detail.getAppName())
                            .build()
                    )
                );
    }

    // FIXME current implementation has no recoverability and is not capable of zero-downtime deployment
    protected Mono<List<HistoricalRecord>> stackChangeApplications(String id) {
        return
            policiesService
                .findByApplicationOperation(ApplicationOperation.CHANGE_STACK)
                .flux()
                .flatMap(p -> Flux.fromIterable(p.getApplicationPolicies()))
                .filter(ap -> ap.getId().equals(id))
                .flatMap(ap -> Flux.concat(appInfoService.findByApplicationPolicy(ap, false), appInfoService.findByApplicationPolicy(ap, true)))
                .distinct()
                .filter(wl -> filter.isWhitelisted(wl.getT2(), wl.getT1().getOrganization()))
                .filter(bl -> filter.isBlacklisted(bl.getT1().getOrganization(), bl.getT1().getSpace()))
                .filter(from -> from.getT1().getStack().equals(from.getT2().getOption("stack-from", String.class)))
                .flatMap(ad -> {
                    log.info("{} is a candidate for stack change using policy {}.", ad.getT1(), ad.getT2());
                    return stackChangeApplication(ad.getT2(), ad.getT1());
                })
                .flatMap(historicalRecordService::save)
                .collectList();
    }

    private Mono<GetBuildResponse> waitForStagedBuild(CreateBuildResponse build, AppDetail detail, Duration stagingTimeout) {
        Duration timeout = Optional.ofNullable(stagingTimeout).orElse(Duration.ofMinutes(15));
        return getBuild(build, detail)
                .filter(isStagingComplete())
                .repeatWhenEmpty(DelayUtils.exponentialBackOff(Duration.ofSeconds(1), Duration.ofSeconds(15), timeout))
                .filter(isStaged())
                .switchIfEmpty(ExceptionUtils.illegalState("Build %s failed during staging", build.getId()))
                .onErrorResume(DelayTimeoutException.class, t -> ExceptionUtils.illegalState("Build %s timed out during staging", build.getId()));
    }

    @Builder
    @Getter
    static class BuildpackLifecycleData implements LifecycleData {
        private List<String> buildpacks;
        private String stack;
    }

    private static Predicate<GetBuildResponse> isStaged() {
        return response -> response.getState().equals(BuildState.STAGED);
    }

    private static Predicate<GetBuildResponse> isStagingComplete() {
        return response -> response.getState().equals(BuildState.STAGED) || response.getState().equals(BuildState.FAILED);
    }
}


================================================
File: src/main/java/org/cftoolsuite/cfapp/task/StacksTask.java
================================================
package org.cftoolsuite.cfapp.task;

import org.cftoolsuite.cfapp.event.StacksRetrievedEvent;
import org.cftoolsuite.cfapp.event.TkRetrievedEvent;
import org.cftoolsuite.cfapp.service.StacksCache;
import org.cloudfoundry.operations.DefaultCloudFoundryOperations;
import org.cloudfoundry.operations.stacks.Stack;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.ApplicationEventPublisher;
import org.springframework.context.ApplicationListener;
import org.springframework.stereotype.Component;

import lombok.extern.slf4j.Slf4j;
import reactor.core.publisher.Flux;

@Slf4j
@Component
public class StacksTask implements ApplicationListener<TkRetrievedEvent> {

    private final DefaultCloudFoundryOperations opsClient;
    private final StacksCache cache;
    private final ApplicationEventPublisher publisher;

    @Autowired
    public StacksTask(
            DefaultCloudFoundryOperations opsClient,
            StacksCache cache,
            ApplicationEventPublisher publisher) {
        this.opsClient = opsClient;
        this.cache = cache;
        this.publisher = publisher;
    }


    public void collect() {
        log.info("StacksTask started");
        getStacks()
        .collectList()
        .map(list -> cache.from(list))
        .subscribe(
            result -> {
                publisher.publishEvent(new StacksRetrievedEvent(this));
                log.trace("Stacks cache contains {}", result);
                log.info("StacksTask completed. {} stacks found.", result.size());
            },
            error -> {
                log.error("StacksTask terminated with error", error);
            }
        );
    }

    protected Flux<Stack> getStacks() {
        return opsClient
                .stacks()
                .list();
    }

    @Override
    public void onApplicationEvent(TkRetrievedEvent event) {
        collect();
    }

}


================================================
File: src/main/java/org/cftoolsuite/cfapp/task/StopAppPolicyExecutorTask.java
================================================
package org.cftoolsuite.cfapp.task;

import java.time.LocalDateTime;

import org.cftoolsuite.cfapp.domain.AppDetail;
import org.cftoolsuite.cfapp.domain.ApplicationOperation;
import org.cftoolsuite.cfapp.domain.HistoricalRecord;
import org.cftoolsuite.cfapp.service.AppDetailService;
import org.cftoolsuite.cfapp.service.HistoricalRecordService;
import org.cftoolsuite.cfapp.service.PoliciesService;
import org.cftoolsuite.cfapp.util.PolicyFilter;
import org.cloudfoundry.client.v3.applications.StopApplicationRequest;
import org.cloudfoundry.operations.DefaultCloudFoundryOperations;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import lombok.extern.slf4j.Slf4j;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

@Slf4j
@Component
public class StopAppPolicyExecutorTask implements PolicyExecutorTask {

    private PolicyFilter filter;
    private DefaultCloudFoundryOperations opsClient;
    private AppDetailService appInfoService;
    private PoliciesService policiesService;
    private HistoricalRecordService historicalRecordService;

    @Autowired
    public StopAppPolicyExecutorTask(
            PolicyFilter filter,
            DefaultCloudFoundryOperations opsClient,
            AppDetailService appInfoService,
            PoliciesService policiesService,
            HistoricalRecordService historicalRecordService
            ) {
        this.filter = filter;
        this.opsClient = opsClient;
        this.appInfoService = appInfoService;
        this.policiesService = policiesService;
        this.historicalRecordService = historicalRecordService;
    }

    @Override
    public void execute(String id) {
        log.info("StopAppPolicyExecutorTask with id={} started", id);
        stopApplications(id)
        .collectList()
        .subscribe(
            result -> {
                log.info("StopAppPolicyExecutorTask with id={} completed", id);
                log.info("-- {} applications stopped.", result.size());
            },
            error -> {
                log.error(String.format("StopAppPolicyExecutorTask with id=%s terminated with error", id), error);
            }
        );
    }

    protected Mono<HistoricalRecord> stopApplication(AppDetail detail) {
        return DefaultCloudFoundryOperations.builder()
                .from(opsClient)
                .organization(detail.getOrganization())
                .space(detail.getSpace())
                .build()
                .getCloudFoundryClient()
                .applicationsV3()
                .stop(
                    StopApplicationRequest
                        .builder()
                        .applicationId(detail.getAppId())
                        .build()
                )
                .then(
                    Mono.just(
                        HistoricalRecord
                            .builder()
                            .transactionDateTime(LocalDateTime.now())
                            .actionTaken("stop")
                            .organization(detail.getOrganization())
                            .space(detail.getSpace())
                            .appId(detail.getAppId())
                            .type("application")
                            .name(detail.getAppName())
                            .build()
                    )
                );
    }

    protected Flux<HistoricalRecord> stopApplications(String id) {
        return policiesService
                .findByApplicationOperation(ApplicationOperation.STOP)
                .flux()
                .flatMap(p -> Flux.fromIterable(p.getApplicationPolicies()))
                .filter(ap -> ap.equals(id))
                .flatMap(ap -> Flux.concat(appInfoService.findByApplicationPolicy(ap, false), appInfoService.findByApplicationPolicy(ap, true)))
                .distinct()
                .filter(wl -> filter.isWhitelisted(wl.getT2(), wl.getT1().getOrganization()))
                .filter(bl -> filter.isBlacklisted(bl.getT1().getOrganization(), bl.getT1().getSpace()))
                .flatMap(ad -> stopApplication(ad.getT1()))
                .flatMap(historicalRecordService::save);
    }
}


================================================
File: src/main/java/org/cftoolsuite/cfapp/task/TkTask.java
================================================
package org.cftoolsuite.cfapp.task;

import org.cftoolsuite.cfapp.event.DatabaseCreatedEvent;
import org.cftoolsuite.cfapp.event.TkRetrievedEvent;
import org.cftoolsuite.cfapp.service.TimeKeeperService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.ApplicationEventPublisher;
import org.springframework.context.ApplicationListener;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Component;

import lombok.extern.slf4j.Slf4j;

@Slf4j
@Component
public class TkTask implements ApplicationListener<DatabaseCreatedEvent> {

    private final TimeKeeperService tkService;
    private final ApplicationEventPublisher publisher;

    @Autowired
    public TkTask(
            TimeKeeperService tkService,
            ApplicationEventPublisher publisher) {
        this.tkService = tkService;
        this.publisher = publisher;
    }

    public void collect() {
        log.info("TkTask started");
        tkService
            .deleteOne()
            .then(tkService.save())
            .then(tkService.findOne())
            .subscribe(
                result -> {
                    publisher.publishEvent(new TkRetrievedEvent(this).lastCollected(result));
                    log.info("TkTask completed");
                    log.trace("Last collected time was set to {}", result);
                },
                error -> {
                    log.error("TkTask terminated with error", error);
                }
            );
    }

    @Override
    public void onApplicationEvent(DatabaseCreatedEvent event) {
        collect();
    }

    @Scheduled(cron = "${cron.collection}")
    protected void runTask() {
        collect();
    }

}


================================================
File: src/main/java/org/cftoolsuite/cfapp/task/UsageTask.java
================================================
package org.cftoolsuite.cfapp.task;

import org.cftoolsuite.cfapp.event.TkRetrievedEvent;
import org.cftoolsuite.cfapp.service.UsageCache;
import org.cftoolsuite.cfapp.service.UsageService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.ApplicationListener;
import org.springframework.stereotype.Component;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;

import lombok.extern.slf4j.Slf4j;

@Slf4j
@Component
public class UsageTask implements ApplicationListener<TkRetrievedEvent> {

    private final UsageService service;
    private final UsageCache cache;
    private final ObjectMapper mapper;

    @Autowired
    public UsageTask(
            UsageService service,
            UsageCache cache,
            ObjectMapper mapper) {
        this.service = service;
        this.cache = cache;
        this.mapper = mapper;
    }

    public void collect() {
        log.info("UsageTask started");
        service
            .getApplicationReport()
            .doOnNext(r -> {
                log.trace(mapWithException("AppUsageReport", r));
                cache.setApplicationReport(r);
            })
            .then(service.getServiceReport())
            .doOnNext(r -> {
                log.trace(mapWithException("ServiceUsageReport", r));
                cache.setServiceReport(r);
            })
            .then(service.getTaskReport())
            .doOnNext(r -> {
                log.trace(mapWithException("TaskUsageReport", r));
                cache.setTaskReport(r);
            })
            .subscribe(
                result -> log.info("UsageTask completed"),
                error -> log.error("UsageTask terminated with error", error)
            );
    }

    private String mapWithException(String type, Object value) {
        try {
            return mapper.writeValueAsString(value);
        } catch (JsonProcessingException jpe) {
            throw new RuntimeException("Problem mapping " + type);
        }
    }

    @Override
    public void onApplicationEvent(TkRetrievedEvent event) {
        collect();
    }

}


================================================
File: src/main/java/org/cftoolsuite/cfapp/util/CsvUtil.java
================================================
package org.cftoolsuite.cfapp.util;

import java.io.IOException;
import java.io.StringReader;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

import org.apache.commons.csv.CSVFormat;
import org.apache.commons.csv.CSVParser;
import org.apache.commons.csv.CSVRecord;
import org.apache.commons.lang3.StringUtils;

import lombok.extern.slf4j.Slf4j;

@Slf4j
public class CsvUtil {

    public static Set<String> parse(String csvInput) {
        Set<String> result = new HashSet<>();
        if (StringUtils.isNotBlank(csvInput)) {
            try {
                CSVParser csvParser = CSVParser.parse(new StringReader(csvInput), CSVFormat.DEFAULT);
                for (CSVRecord csvRecord : csvParser) {
                    List<String> value = csvRecord.toList();
                    result.addAll(value);
                }
            } catch (IOException e) {
                log.error("Error parsing CSV input", e);
            }
        }
        return result;
    }
}


================================================
File: src/main/java/org/cftoolsuite/cfapp/util/DbmsOnlyCondition.java
================================================
package org.cftoolsuite.cfapp.util;

import org.springframework.context.annotation.Condition;
import org.springframework.context.annotation.ConditionContext;
import org.springframework.core.env.Environment;
import org.springframework.core.type.AnnotatedTypeMetadata;


public class DbmsOnlyCondition implements Condition {

    @Override
    public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) {
        Environment env = context.getEnvironment();
        return null == env.getProperty("cf.policies.git.uri");
    }
}

================================================
File: src/main/java/org/cftoolsuite/cfapp/util/DropletProcessingCondition.java
================================================
package org.cftoolsuite.cfapp.util;

import java.util.Set;

import org.springframework.context.annotation.Condition;
import org.springframework.context.annotation.ConditionContext;
import org.springframework.core.env.Environment;
import org.springframework.core.type.AnnotatedTypeMetadata;


public class DropletProcessingCondition implements Condition {

    @Override
    public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) {
        Set<String> activationValues = Set.of("unpack-pom-contents-in-droplet", "list-jars-in-droplet");
        Environment env = context.getEnvironment();
        return activationValues.contains(env.getProperty("java.artifacts.fetch.mode",""));
    }
}

================================================
File: src/main/java/org/cftoolsuite/cfapp/util/JarManifestUtil.java
================================================
package org.cftoolsuite.cfapp.util;

import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.util.jar.Attributes;
import java.util.jar.Manifest;

public class JarManifestUtil {

    public static String obtainAttributeValue(String contents, String key) throws IOException {
        Manifest manifest = new Manifest(new ByteArrayInputStream(contents.getBytes()));
        Attributes attributes = manifest.getMainAttributes();
        return attributes.getValue(key);
    }

}


================================================
File: src/main/java/org/cftoolsuite/cfapp/util/JarSetFilterReader.java
================================================
package org.cftoolsuite.cfapp.util;

import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.Map;
import java.util.Set;
import java.util.stream.Collectors;

public class JarSetFilterReader implements JavaArtifactReader {

    private Map<String, String> filters;

    public JarSetFilterReader(Map<String, String> filters) {
        this.filters = filters;
    }

    public Set<String> read(String jars) {
        if (jars != null && !jars.isEmpty()) {
            Map<String, String> latestVersions = new HashMap<>();
            Arrays.stream(jars.split("\n"))
                    .filter(jar -> filters.keySet().stream().anyMatch(jar::startsWith))
                    .forEach(jar -> {
                        String group = findGroupForJar(jar);
                        if (!group.isEmpty()) {
                            int dashIndex = jar.lastIndexOf('-');
                            int dotIndex = jar.lastIndexOf('.');
                            if (dashIndex != -1 && dotIndex != -1) {
                                String version = jar.substring(dashIndex + 1, dotIndex);
                                String currentLatestVersion = latestVersions.getOrDefault(group, "");
                                if (currentLatestVersion.isEmpty() || isNewerVersion(version, currentLatestVersion)) {
                                    latestVersions.put(group, version);
                                }
                            }
                        }
                    });
            return latestVersions.entrySet().stream()
                    .map(entry -> String.format("%s:%s", entry.getKey(), entry.getValue()))
                    .collect(Collectors.toSet());
        } else {
            return Collections.emptySet();
        }
    }

    private boolean isNewerVersion(String version1, String version2) {
        String[] parts1 = version1.split("\\.");
        String[] parts2 = version2.split("\\.");
        int minLength = Math.min(parts1.length, parts2.length);
        for (int i = 0; i < minLength; i++) {
            int v1 = Integer.parseInt(parts1[i]);
            int v2 = Integer.parseInt(parts2[i]);
            if (v1 != v2) {
                return v1 > v2;
            }
        }
        return parts1.length > parts2.length;
    }

    private String findGroupForJar(String jarName) {
        for (String key : filters.keySet()) {
            if (jarName.startsWith(key)) {
                return filters.get(key);
            }
        }
        return "";
    }

    public String mode() {
        return "list-jars";
    }
}

================================================
File: src/main/java/org/cftoolsuite/cfapp/util/JarSetFilterReaderCondition.java
================================================
package org.cftoolsuite.cfapp.util;

import java.util.Set;

import org.springframework.context.annotation.Condition;
import org.springframework.context.annotation.ConditionContext;
import org.springframework.core.env.Environment;
import org.springframework.core.type.AnnotatedTypeMetadata;


public class JarSetFilterReaderCondition implements Condition {

    @Override
    public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) {
        Set<String> activationValues = Set.of("list-jars-in-droplet", "obtain-jars-from-runtime-metadata");
        Environment env = context.getEnvironment();
        return activationValues.contains(env.getProperty("java.artifacts.fetch.mode",""));
    }
}

================================================
File: src/main/java/org/cftoolsuite/cfapp/util/JavaArtifactReader.java
================================================
package org.cftoolsuite.cfapp.util;

import java.util.Set;

public interface JavaArtifactReader {

    Set<String> read(String input);
    String mode();
}


================================================
File: src/main/java/org/cftoolsuite/cfapp/util/JsonToCsvConverter.java
================================================
package org.cftoolsuite.cfapp.util;

import java.io.IOException;
import java.io.StringWriter;
import java.util.ArrayList;
import java.util.List;

import org.apache.commons.csv.CSVFormat;
import org.apache.commons.csv.CSVPrinter;
import org.springframework.stereotype.Component;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.JsonMappingException;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;

import lombok.extern.slf4j.Slf4j;

@Component
@Slf4j
public class JsonToCsvConverter {

    private final ObjectMapper objectMapper;

    public JsonToCsvConverter(ObjectMapper objectMapper) {
        this.objectMapper = objectMapper;
    }

    public String convert(String jsonString) throws JsonMappingException, JsonProcessingException {
        StringWriter writer = new StringWriter();
        JsonNode jsonNode = objectMapper.readTree(jsonString);
        List<JsonNode> jsonNodes = new ArrayList<>();
        if (jsonNode.isArray()) {
            jsonNode.forEach(jsonNodes::add);
        } else {
            jsonNodes.add(jsonNode);
        }
        if (jsonNodes.isEmpty()) {
            throw new IllegalArgumentException("JSON string must contain at least one element");
        }
        List<String> headers = new ArrayList<>();
        jsonNodes.get(0).fieldNames().forEachRemaining(headers::add);
        CSVFormat csvFormat = CSVFormat.DEFAULT.builder().setHeader(headers.toArray(new String[]{})).build();
        try (CSVPrinter csvPrinter = new CSVPrinter(writer, csvFormat)) {
            for (JsonNode row : jsonNodes) {
                var values = new ArrayList<>();
                headers.forEach(header -> values.add(row.get(header).asText()));
                csvPrinter.printRecord(values);
            }
            csvPrinter.flush();
        } catch (IOException e) {
            log.error("Could not write comma-separated value string");
        }
        return writer.toString();
    }

}


================================================
File: src/main/java/org/cftoolsuite/cfapp/util/MavenPomReader.java
================================================
package org.cftoolsuite.cfapp.util;

import java.io.File;
import java.io.IOException;
import java.io.StringReader;
import java.util.Collections;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.Optional;
import java.util.Set;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;

import org.apache.commons.lang3.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.xml.sax.InputSource;
import org.xml.sax.SAXException;

public class MavenPomReader implements JavaArtifactReader {

    private Logger log = LoggerFactory.getLogger(MavenPomReader.class);

    private Set<String> groups = new HashSet<>();
    private boolean omitInheritedVersions;

    public MavenPomReader(Set<String> groups) {
        this.groups = groups;
    }

    public MavenPomReader(Set<String> groups, boolean omitInheritedVersions) {
        this.groups = groups;
        this.omitInheritedVersions = omitInheritedVersions;
    }

    public Set<String> read(String pomFile) {
        try {
            return readPOM(pomFile);
        } catch (ParserConfigurationException | SAXException | IOException e) {
            log.warn("Could not determine Spring dependencies", e);
            return Collections.emptySet();
        }
    }

    public Set<String> readPOM(File pomFile) throws ParserConfigurationException, SAXException, IOException {
        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
        DocumentBuilder builder = factory.newDocumentBuilder();
        Document document = builder.parse(pomFile);
        return processDocument(document);
    }

    public Set<String> readPOM(String pomContent) throws ParserConfigurationException, SAXException, IOException {
        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
        DocumentBuilder builder = factory.newDocumentBuilder();
        Document document = builder.parse(new InputSource(new StringReader(pomContent)));
        return processDocument(document);
    }

    private Set<String> processDocument(Document document) {
        Set<String> dependenciesInfo = new LinkedHashSet<>();
        document.getDocumentElement().normalize();

        // Check for parent artifact
        NodeList parents = document.getElementsByTagName("parent");
        extractDependencyInfo(parents, dependenciesInfo);

        // Check for managed dependencies
        NodeList managedDependencies = document.getElementsByTagName("dependencyManagement");
        extractDependencyInfo(managedDependencies, dependenciesInfo);

        // Check for dependencies
        NodeList dependencies = document.getElementsByTagName("dependency");
        extractDependencyInfo(dependencies, dependenciesInfo);

        return dependenciesInfo;
    }

    private void extractDependencyInfo(NodeList nodes, Set<String> dependenciesInfo) {
        for (int i = 0; i < nodes.getLength(); i++) {
            Element element = (Element) nodes.item(i);

            String artifactId = getTagValue("artifactId", element);
            String groupId = getTagValue("groupId", element);

            if (containsDependency(groupId)) {
                String version = getTagValue("version", element);

                if (omitInheritedVersions && StringUtils.isNotBlank(version)) {
                    addDependencyInfo(dependenciesInfo, groupId, artifactId, version);
                } else if (!omitInheritedVersions) {
                    version = StringUtils.isBlank(version) ? getManagedVersion(dependenciesInfo, groupId) : version;
                    addDependencyInfo(dependenciesInfo, groupId, artifactId, version);
                }
            }
        }
    }

    private void addDependencyInfo(Set<String> dependenciesInfo, String groupId, String artifactId, String version) {
        dependenciesInfo.add(String.format("%s:%s:%s", groupId, artifactId, version));
    }

    private String getManagedVersion(Set<String> dependenciesInfo, String groupId) {
        return dependenciesInfo.stream()
            .filter(d -> d.startsWith(groupId))
            .filter(d -> d.split(":").length == 3)
            .findFirst()
            .map(d -> d.split(":")[2])
            .orElse("");
    }

    private String getTagValue(String tag, Element element) {
        NodeList nodes = element.getElementsByTagName(tag);
        if (nodes.getLength() == 0) {
            return "";
        }

        Node targetNode = nodes.item(0);
        String value = targetNode.getTextContent();

        String parentName = getNodeName(targetNode.getParentNode());
        String grandParentName = getNodeName(getParentNode(targetNode, 2));
        String greatGrandParentName = getNodeName(getParentNode(targetNode, 3));

        if (isValidHierarchy(parentName, grandParentName, greatGrandParentName)) {
            return value;
        }
        return "";
    }

    private String getNodeName(Node node) {
        return Optional.ofNullable(node).map(Node::getNodeName).orElse("");
    }

    private Node getParentNode(Node node, int level) {
        Node parentNode = node;
        for (int i = 0; i < level && parentNode != null; i++) {
            parentNode = parentNode.getParentNode();
        }
        return parentNode;
    }

    private boolean isValidHierarchy(String parentName, String grandParentName, String greatGrandParentName) {
        if ("parent".equals(parentName)) {
            return "project".equals(grandParentName);
        } else if ("dependency".equals(parentName)) {
            return ("dependencies".equals(grandParentName) && "project".equals(greatGrandParentName)) ||
                ("dependencies".equals(grandParentName) && "dependencyManagement".equals(greatGrandParentName));
        }
        return false;
    }

    private boolean containsDependency(String groupId) {
        boolean exactlyOneMatch = groups.stream().anyMatch(group -> groupId.startsWith(group)) &&
                          groups.stream().noneMatch(group ->
                              !group.equals(groups.stream().filter(g -> groupId.startsWith(g)).findFirst().orElse(null)) &&
                              groupId.startsWith(group));
        return exactlyOneMatch;
    }

    public String mode() {
        return "unpack-pom-contents-in-droplet";
    }

    public static void main(String[] args) {
        MavenPomReader reader = new MavenPomReader(Set.of("org.springframework", "io.pivotal.spring.cloud"), true);
        try {
            //Set<String> dependenciesInfo = reader.readPOM(new File("/home/cphillipson/Documents/development/pivotal/cf/cf-butler/pom.xml")); // or reader.readPOM(pomString);
            Set<String> dependenciesInfo = reader.readPOM(new File(args[0]));
            for (String info : dependenciesInfo) {
                System.out.println("Found dependency: " + info);
            }
        } catch (ParserConfigurationException | SAXException | IOException e) {
            e.printStackTrace();
        }
    }
}


================================================
File: src/main/java/org/cftoolsuite/cfapp/util/PolicyFilter.java
================================================
package org.cftoolsuite.cfapp.util;

import java.util.HashSet;
import java.util.Set;

import org.cftoolsuite.cfapp.config.PasSettings;
import org.cftoolsuite.cfapp.domain.HasOrganizationWhiteList;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;
import org.springframework.util.CollectionUtils;

@Component
public class PolicyFilter {

    private PasSettings settings;

    @Autowired
    public PolicyFilter(PasSettings settings) {
        this.settings = settings;
    }

    public boolean isBlacklisted(String organization, String space) {
        if (settings.hasSpaceBlackList()) {
            return !settings.getSpaceBlackList().contains(String.join(":", organization, space));
        } else {
            return !settings.getOrganizationBlackList().contains(organization);
        }
    }

    public boolean isWhitelisted(HasOrganizationWhiteList policy, String organization) {
        Set<String> prunedSet = new HashSet<>(policy.getOrganizationWhiteList());
        while (prunedSet.remove(""));
        Set<String> whitelist =
                CollectionUtils.isEmpty(prunedSet) ?
                        prunedSet: policy.getOrganizationWhiteList();
        return
                whitelist.isEmpty() ? true: policy.getOrganizationWhiteList().contains(organization);
    }
}


================================================
File: src/main/java/org/cftoolsuite/cfapp/util/RetryableTokenProvider.java
================================================
package org.cftoolsuite.cfapp.util;

import java.time.Duration;

import org.cloudfoundry.reactor.DefaultConnectionContext;
import org.cloudfoundry.reactor.TokenProvider;
import org.springframework.http.HttpStatus;
import org.springframework.web.reactive.function.client.WebClientResponseException;

import reactor.core.publisher.Mono;
import reactor.util.retry.Retry;

public class RetryableTokenProvider {

    public static Mono<String> getToken(TokenProvider provider, DefaultConnectionContext connectionContext) {
        return Mono.defer(() ->
                provider.getToken(connectionContext)
                    .onErrorResume(WebClientResponseException.class, throwable -> {
                        if (throwable.getStatusCode() == HttpStatus.UNAUTHORIZED) {
                            provider.invalidate(connectionContext);
                            // Retry logic
                            return Mono.error(throwable); // Propagate error to trigger retry
                        }
                        return Mono.error(throwable); // Propagate other errors
                    })
                    .retryWhen(Retry
                        .backoff(2, Duration.ofSeconds(2))
                    )
        );
    }
}


================================================
File: src/main/java/org/cftoolsuite/cfapp/util/TgzUtil.java
================================================
package org.cftoolsuite.cfapp.util;

import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.stream.IntStream;

import org.apache.commons.compress.archivers.ArchiveException;
import org.apache.commons.compress.archivers.ArchiveStreamFactory;
import org.apache.commons.compress.archivers.tar.TarArchiveEntry;
import org.apache.commons.compress.archivers.tar.TarArchiveInputStream;
import org.apache.commons.compress.compressors.CompressorException;
import org.apache.commons.compress.compressors.CompressorInputStream;
import org.apache.commons.compress.compressors.CompressorStreamFactory;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.core.io.buffer.DataBuffer;
import org.springframework.core.io.buffer.DataBufferUtils;
import org.springframework.core.io.buffer.DefaultDataBufferFactory;

import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

public class TgzUtil {

    private static Logger log = LoggerFactory.getLogger(TgzUtil.class);

    public static Mono<String> findMatchingFiles(Flux<DataBuffer> incoming, String extension) {
        Mono<DataBuffer> fullContent =
            DataBufferUtils
                .join(incoming);
        Mono<InputStream> inputStreamMono = fullContent.map(dataBuffer ->
            dataBuffer.asInputStream(true)
        );
        return inputStreamMono.flatMapMany(is -> findMatchingFiles(is, extension))
                .collectList()
                .map(list -> String.join(System.getProperty("line.separator"), list));
    }

    private static Flux<String> findMatchingFiles(InputStream is, String extension) {
        try {
            CompressorInputStream cis = new CompressorStreamFactory().createCompressorInputStream(is);
            TarArchiveInputStream tarIs = new ArchiveStreamFactory().createArchiveInputStream("tar", cis);
            return Flux.create(sink -> {
                try {
                    TarArchiveEntry entry;
                    while ((entry = (TarArchiveEntry) tarIs.getNextEntry()) != null) {
                        if (!tarIs.canReadEntryData(entry)) {
                            continue;
                        }
                        if (!entry.isDirectory() && entry.getName().endsWith(extension)) {
                            Path tarEntryFilePath = Paths.get(entry.getName()).getFileName();
                            String tarEntryFilename = tarEntryFilePath != null ? tarEntryFilePath.toString() : "";
                            log.trace("Found {}", tarEntryFilename);
                            sink.next(tarEntryFilename);
                        }
                    }
                    sink.complete();
                } catch (IOException e) {
                    log.error(String.format("Could not process entry in TarArchiveInputStream with extension %s", extension), e);
                    sink.error(e);
                } finally {
                    try {
                        tarIs.close();
                    } catch (IOException e) {
                        log.error("Problem closing TarArchiveInputStream", e);
                    }
                }
            });
        } catch (ArchiveException | CompressorException e) {
            log.error("Problem creating TarArchiveInputStream", e);
            return Flux.error(e);
        }
    }

    public static Mono<String> extractFileContent(Flux<DataBuffer> incoming, String filename) {
        Mono<DataBuffer> fullContent =
            DataBufferUtils
                .join(incoming);
        Mono<InputStream> inputStreamMono = fullContent.map(dataBuffer ->
            dataBuffer.asInputStream(true)
        );
        return inputStreamMono.flatMapMany(is -> extractFileContent(is, filename))
                .collectList()
                .map(list -> String.join("", list));
    }

    private static Flux<String> extractFileContent(InputStream is, String filename) {
        try {
            CompressorInputStream cis = new CompressorStreamFactory().createCompressorInputStream(is);
            TarArchiveInputStream tarIs = new ArchiveStreamFactory().createArchiveInputStream("tar", cis);
            return Flux.create(sink -> {
                try {
                    TarArchiveEntry entry;
                    while ((entry = (TarArchiveEntry) tarIs.getNextEntry()) != null) {
                        if (!tarIs.canReadEntryData(entry)) {
                            continue;
                        }
                        if (!entry.isDirectory() && entry.getName().endsWith(filename)) {
                            log.trace("Found {}", filename);
                            byte[] buffer = new byte[1024];
                            int len;
                            while ((len = tarIs.read(buffer)) != -1) {
                                sink.next(new String(buffer, 0, len, StandardCharsets.UTF_8));
                            }
                        }
                    }
                    sink.complete();
                } catch (IOException e) {
                    log.error(String.format("Could not find entry in TarArchiveInputStream with filename %s", filename), e);
                    sink.error(e);
                } finally {
                    try {
                        tarIs.close();
                    } catch (IOException e) {
                        log.error("Problem closing TarArchiveInputStream", e);
                    }
                }
            });
        } catch (ArchiveException | CompressorException e) {
            log.error("Problem creating TarArchiveInputStream", e);
            return Flux.error(e);
        }
    }

    public static void main(String[] args) {
        //File droplet = new File("/tmp/droplet_2be29bc3-0e2c-40f9-b454-db89c15c723f.tgz");
        File droplet = new File(args[0]);
        IntStream.rangeClosed(1, 30).forEach(i -> {
            if (droplet.exists()) {
                try {
                    byte[] bytes = Files.readAllBytes(droplet.toPath());
                    DefaultDataBufferFactory factory = new DefaultDataBufferFactory();
                    DataBuffer db1 = factory.wrap(bytes);
                    DataBuffer db2 = factory.wrap(bytes);
                    TgzUtil
                        .extractFileContent(Flux.just(db1), "pom.xml")
                        .log()
                        .subscribe();
                    TgzUtil
                        .findMatchingFiles(Flux.just(db2), ".jar")
                        .log()
                        .subscribe();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        });
    }
}


================================================
File: src/test/java/org/cftoolsuite/cfapp/ButlerTest.java
================================================
package org.cftoolsuite.cfapp;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.test.context.TestPropertySource;

@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
@SpringBootTest
@TestPropertySource(locations="classpath:/test.properties")
public @interface ButlerTest { }


================================================
File: src/test/java/org/cftoolsuite/cfapp/domain/EmbeddedMetadataTest.java
================================================
package org.cftoolsuite.cfapp.domain;

import org.apache.commons.lang3.RandomStringUtils;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

public class EmbeddedMetadataTest {

    @Test
    public void assertThatEmbeddedMetadataOnlyWithAnnotationIsValid() {
        EmbeddedMetadata m =
                EmbeddedMetadata
                .builder()
                .annotation("annotation-name", "annotation-value")
                .build();
        Assertions.assertTrue(m.isValid());
    }

    @Test
    public void assertThatEmbeddedMetadataOnlyWithLabelIsValid() {
        EmbeddedMetadata m =
                EmbeddedMetadata
                .builder()
                .label("label-name", "label-value")
                .build();
        Assertions.assertTrue(m.isValid());
    }

    @Test
    public void assertThatEmbeddedMetadataWithExceptionalAnnotationIsInvalid() {
        EmbeddedMetadata m =
                EmbeddedMetadata
                .builder()
                .annotation("annotation&name", "annotation-value")
                .build();
        Assertions.assertFalse(m.isValid());
    }

    @Test
    public void assertThatEmbeddedMetadataWithExceptionalLabelIsInvalid() {
        EmbeddedMetadata m =
                EmbeddedMetadata
                .builder()
                .label("label&name", "label-value")
                .build();
        Assertions.assertFalse(m.isValid());
    }

    @Test
    public void assertThatEmbeddedMetadataWithLabelAndAnnotationIsValid() {
        EmbeddedMetadata m =
                EmbeddedMetadata
                .builder()
                .label("label-name", "label-value")
                .annotation("annotation-name", "annotation-value")
                .build();
        Assertions.assertTrue(m.isValid());
    }

    @Test
    public void assertThatEmbeddedMetadataWithLongAnnotationKeyIsInvalid() {
        EmbeddedMetadata m =
                EmbeddedMetadata
                .builder()
                .annotation(RandomStringUtils.randomAlphanumeric(100), "annotation-value")
                .build();
        Assertions.assertFalse(m.isValid());
    }

    @Test
    public void assertThatEmbeddedMetadataWithLongAnnotationValueIsInvalid() {
        EmbeddedMetadata m =
                EmbeddedMetadata
                .builder()
                .annotation(RandomStringUtils.randomAlphanumeric(15), RandomStringUtils.randomAlphanumeric(7500))
                .build();
        Assertions.assertFalse(m.isValid());
    }

    @Test
    public void assertThatEmbeddedMetadataWithLongLabelKeyIsInvalid() {
        EmbeddedMetadata m =
                EmbeddedMetadata
                .builder()
                .label(RandomStringUtils.randomAlphanumeric(100), "label-value")
                .build();
        Assertions.assertFalse(m.isValid());
    }

    @Test
    public void assertThatEmbeddedMetadataWithLongLabelValueIsInvalid() {
        EmbeddedMetadata m =
                EmbeddedMetadata
                .builder()
                .label(RandomStringUtils.randomAlphanumeric(15), RandomStringUtils.randomAlphanumeric(100))
                .build();
        Assertions.assertFalse(m.isValid());
    }

    @Test
    public void assertThatEmbeddedMetadataWithNamespacedKeyForAnnotationIsValid() {
        EmbeddedMetadata m =
                EmbeddedMetadata
                .builder()
                .annotation("annotation.prefix/annotation-name", "annotation-value")
                .build();
        Assertions.assertTrue(m.isValid());
    }

    @Test
    public void assertThatEmbeddedMetadataWithNamespacedKeyForLabelIsValid() {
        EmbeddedMetadata m =
                EmbeddedMetadata
                .builder()
                .label("label.prefix/label-name", "label-value")
                .build();
        Assertions.assertTrue(m.isValid());
    }

    @Test
    public void assertThatEmbeddedMetadataWithoutLabelsAndAnnotationsIsValid() {
        EmbeddedMetadata m =
                EmbeddedMetadata
                .builder()
                .build();
        Assertions.assertTrue(m.isValid());
    }
}


================================================
File: src/test/java/org/cftoolsuite/cfapp/domain/OrganizationTest.java
================================================
package org.cftoolsuite.cfapp.domain;

import java.util.HashSet;
import java.util.List;
import java.util.Set;

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

public class OrganizationTest {

    @Test
    public void assertThatOrganizationsAreEqual() {
        Organization org1 = new Organization("000eaf", "zoo-labs");
        Organization org2 = new Organization("000eaf", "zoo-labs");
        Assertions.assertTrue(org1.equals(org2));
        Set<Organization> orgs = new HashSet<>(List.of(org1, org2));
        Assertions.assertTrue(orgs.size() == 1);
    }
}


================================================
File: src/test/java/org/cftoolsuite/cfapp/domain/PoliciesValidatorTest.java
================================================
package org.cftoolsuite.cfapp.domain;

import java.time.LocalDateTime;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;

import org.assertj.core.api.Assertions;
import org.cftoolsuite.cfapp.ButlerTest;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.test.context.junit.jupiter.SpringExtension;

@ButlerTest
@ExtendWith(SpringExtension.class)
public class PoliciesValidatorTest {

    private final PoliciesValidator policiesValidator;

    @Autowired
    public PoliciesValidatorTest(PoliciesValidator policiesValidator) {
        this.policiesValidator = policiesValidator;
    }

    @Test
    public void assertInvalidApplicationPolicy() {
        Map<String, Object> options = new HashMap<>();
        options.put("from-duration", "PT30S");
        options.put("from-datetime", LocalDateTime.now().minusSeconds(30));
        ApplicationPolicy invalidDeletePolicy =
                ApplicationPolicy
                .builder()
                .description("Delete applications in stopped state that were pushed more than 30s ago, but with multiple timeframes.")
                .operation(ApplicationOperation.DELETE.getName())
                .organizationWhiteList(Set.of("zoo-labs"))
                .options(options)
                .state(ApplicationState.STOPPED.getName())
                .pk(100L)
                .id(null)
                .build();
        Assertions.assertThat(policiesValidator.validate(invalidDeletePolicy) == false);

        ApplicationPolicy invalidScalingPolicy =
                ApplicationPolicy
                .builder()
                .description("Scale all applications, no parameters supplied")
                .operation(ApplicationOperation.SCALE_INSTANCES.getName())
                .organizationWhiteList(Set.of("zoo-labs"))
                .state(ApplicationState.STOPPED.getName())
                .pk(100L)
                .id(null)
                .build();
        Assertions.assertThat(policiesValidator.validate(invalidScalingPolicy) == false);
    }

    @Test
    public void assertInvalidQueryPolicy() {
        Set<Query> queries = new HashSet<>();
        Query query =
                Query
                .builder()
                .name("malicious-query")
                .description("Delete the cache of applicatin detail")
                .sql("delete from application_detail")
                .build();
        queries.add(query);
        EmailNotificationTemplate template =
                EmailNotificationTemplate
                .builder()
                .to(Set.of("bruce@wayneenterprises.com"))
                .from("tony@starkventures.com")
                .subject("Ha ha")
                .body("You got nothing")
                .build();
        QueryPolicy policy =
                QueryPolicy
                .builder()
                .queries(queries)
                .emailNotificationTemplate(template)
                .build();
        Assertions.assertThat(policiesValidator.validate(policy) == false);
    }

    @Test
    public void assertValidApplicationPolicy() {
        Map<String, Object> options = new HashMap<>();
        options.put("from-duration", "PT30S");
        ApplicationPolicy durationPolicy =
                ApplicationPolicy
                .builder()
                .description("Delete applications in stopped state that were pushed more than 30s ago.")
                .operation(ApplicationOperation.DELETE.getName())
                .organizationWhiteList(Set.of("zoo-labs"))
                .options(options)
                .state(ApplicationState.STOPPED.getName())
                .pk(100L)
                .id(null)
                .build();
        Assertions.assertThat(policiesValidator.validate(durationPolicy) == true);

        ApplicationPolicy noTimeframePolicy =
                ApplicationPolicy
                .builder()
                .description("Delete all applications in stopped state.")
                .operation(ApplicationOperation.DELETE.getName())
                .organizationWhiteList(Set.of("zoo-labs"))
                .state(ApplicationState.STOPPED.getName())
                .pk(100L)
                .id(null)
                .build();
        Assertions.assertThat(policiesValidator.validate(noTimeframePolicy) == true);

        Map<String, Object> options2 = new HashMap<>();
        options.put("from-datetime", LocalDateTime.now().minusDays(2));
        ApplicationPolicy dateTimePolicy =
                ApplicationPolicy
                .builder()
                .description("Delete all applications in stopped state that were pushed after date/time.")
                .operation(ApplicationOperation.DELETE.getName())
                .options(options2)
                .organizationWhiteList(Set.of("zoo-labs"))
                .state(ApplicationState.STOPPED.getName())
                .pk(100L)
                .id(null)
                .build();
        Assertions.assertThat(policiesValidator.validate(dateTimePolicy) == true);

        Map<String, Object> options3 = new HashMap<>();
        options.put("instances-from", 1);
        options.put("instances-to", 2);
        ApplicationPolicy scalingPolicy =
                ApplicationPolicy
                .builder()
                .description("Scale all applications ")
                .operation(ApplicationOperation.SCALE_INSTANCES.getName())
                .options(options3)
                .organizationWhiteList(Set.of("zoo-labs"))
                .state(ApplicationState.STOPPED.getName())
                .pk(100L)
                .id(null)
                .build();
        Assertions.assertThat(policiesValidator.validate(scalingPolicy) == true);
    }

    @Test
    public void assertValidQueryPolicy() {
        Set<Query> queries = new HashSet<>();
        Query query =
                Query
                .builder()
                .name("docker-images")
                .description("Find all running docker images")
                .sql("select * from application_detail where running_instances > 0 and requested_state = 'started' and image is not null")
                .build();
        queries.add(query);
        EmailNotificationTemplate template =
                EmailNotificationTemplate
                .builder()
                .to(Set.of("bruce@wayneenterprises.com"))
                .from("tony@starkventures.com")
                .subject("Contemplating K8s")
                .body("Here's a boatload of containers")
                .build();
        QueryPolicy policy =
                QueryPolicy
                .builder()
                .queries(queries)
                .emailNotificationTemplate(template)
                .build();
        Assertions.assertThat(policiesValidator.validate(policy) == true);
    }
}


================================================
File: src/test/java/org/cftoolsuite/cfapp/domain/product/OmInfoTest.java
================================================
package org.cftoolsuite.cfapp.domain.product;

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

public class OmInfoTest {

    @Test
    public void testGetMajorMinorVersion() {
        OmInfo info = OmInfo.builder().info(new OmInfo.Info("2.5.0-build.79")).build();
        Integer expectedMajor = 2;
        Integer expectedMinor = 5;
        Integer actualMajor = info.getMajorVersion();
        Integer actualMinor = info.getMinorVersion();
        Assertions.assertEquals(actualMajor, expectedMajor);
        Assertions.assertEquals(actualMinor, expectedMinor);
    }

    @Test
    public void testGetMajorMinorVersionWithBuildButNoDot() {
        OmInfo info = OmInfo.builder().info(new OmInfo.Info("2.5.0-build")).build();
        Integer expectedMajor = 2;
        Integer expectedMinor = 5;
        Integer actualMajor = info.getMajorVersion();
        Integer actualMinor = info.getMinorVersion();
        Assertions.assertEquals(actualMajor, expectedMajor);
        Assertions.assertEquals(actualMinor, expectedMinor);
    }

    @Test
    public void testGetMajorMinorVersionNoBuild() {
        OmInfo info = OmInfo.builder().info(new OmInfo.Info("2.5.0")).build();
        Integer expectedMajor = 2;
        Integer expectedMinor = 5;
        Integer actualMajor = info.getMajorVersion();
        Integer actualMinor = info.getMinorVersion();
        Assertions.assertEquals(actualMajor, expectedMajor);
        Assertions.assertEquals(actualMinor, expectedMinor);
    }

    @Test
    public void testGetMajorMinorVersionNoReleaseNoBuild() {
        OmInfo info = OmInfo.builder().info(new OmInfo.Info("2.5")).build();
        Integer expectedMajor = 2;
        Integer expectedMinor = 5;
        Integer actualMajor = info.getMajorVersion();
        Integer actualMinor = info.getMinorVersion();
        Assertions.assertEquals(actualMajor, expectedMajor);
        Assertions.assertEquals(actualMinor, expectedMinor);
    }

}


================================================
File: src/test/java/org/cftoolsuite/cfapp/notifier/JavaMailNotifierTest.java
================================================
package org.cftoolsuite.cfapp.notifier;

import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

import java.io.IOException;

import org.cftoolsuite.cfapp.event.EmailNotificationEvent;
import org.cftoolsuite.cfapp.util.EmailTestUtil;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import org.springframework.mail.javamail.JavaMailSender;

import jakarta.mail.internet.MimeMessage;

class JavaMailNotifierTest {

    @Mock
    private JavaMailSender javaMailSender;

    @Mock
    private MimeMessage mimeMessage;

    private JavaMailNotifier javaMailNotifier;

    @BeforeEach
    void setUp() {
        MockitoAnnotations.openMocks(this);
        javaMailNotifier = new JavaMailNotifier(null, javaMailSender);
        when(javaMailSender.createMimeMessage()).thenReturn(mimeMessage);
    }

    @Test
    void testSendSimpleEmail() throws IOException {
        EmailNotificationEvent event = EmailTestUtil.readEmailTemplate("simple-email.json");
        javaMailNotifier.onApplicationEvent(event);

        verify(javaMailSender).send(any(MimeMessage.class));
        verify(javaMailSender, times(1)).createMimeMessage();
    }

    @Test
    void testSendEmailWithAttachments() throws IOException {
        EmailNotificationEvent event = EmailTestUtil.readEmailTemplate("email-with-attachments.json");
        javaMailNotifier.onApplicationEvent(event);

        verify(javaMailSender).send(any(MimeMessage.class));
        verify(javaMailSender, times(1)).createMimeMessage();
    }
}



================================================
File: src/test/java/org/cftoolsuite/cfapp/notifier/SendGridNotifierTest.java
================================================
package org.cftoolsuite.cfapp.notifier;

import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

import java.io.IOException;

import org.cftoolsuite.cfapp.event.EmailNotificationEvent;
import org.cftoolsuite.cfapp.util.EmailTestUtil;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;

import com.sendgrid.Request;
import com.sendgrid.Response;
import com.sendgrid.SendGrid;

class SendGridNotifierTest {

    @Mock
    private SendGrid sendGrid;

    private SendGridNotifier sendGridNotifier;

    @BeforeEach
    void setUp() {
        MockitoAnnotations.openMocks(this);
        sendGridNotifier = new SendGridNotifier(null, sendGrid);
    }

    @Test
    void testSendSimpleEmail() throws IOException {
        EmailNotificationEvent event = EmailTestUtil.readEmailTemplate("simple-email.json");
        Response mockResponse = new Response();
        mockResponse.setStatusCode(200);

        when(sendGrid.api(any(Request.class))).thenReturn(mockResponse);

        sendGridNotifier.onApplicationEvent(event);

        verify(sendGrid).api(any(Request.class));
    }

    @Test
    void testSendEmailWithAttachments() throws IOException {
        EmailNotificationEvent event = EmailTestUtil.readEmailTemplate("email-with-attachments.json");
        Response mockResponse = new Response();
        mockResponse.setStatusCode(200);

        when(sendGrid.api(any(Request.class))).thenReturn(mockResponse);

        sendGridNotifier.onApplicationEvent(event);

        verify(sendGrid).api(any(Request.class));
    }
}



================================================
File: src/test/java/org/cftoolsuite/cfapp/repository/ListRemoteRepositoryExample.java
================================================
package org.cftoolsuite.cfapp.repository;

import org.cftoolsuite.cfapp.client.GitClient;
import org.cftoolsuite.cfapp.config.GitSettings;
import org.eclipse.jgit.lib.Repository;

public class ListRemoteRepositoryExample {

    private static final String REMOTE_URL_1 = "https://github.com/github/testrepo.git";
    private static final String REMOTE_URL_2 = "https://github.com/cf-toolsuite/test-repo.git";
    public static void main(String[] args) throws Exception {
        GitClient helper = new GitClient();
        Repository repo = helper.getRepository(GitSettings.builder().uri(REMOTE_URL_1).build());
        String advice = helper.readFile(repo, "26fc70913efc66a93fe84f8ce1bba09954624490", "test/advice.c");
        System.out.println(advice);

        // This will intentionally fail b/c I'm not sharing credentials for a private repository
        // but it serves to demonstrate how one can retrieve file contests
        repo = helper.getRepository(GitSettings.builder().uri(REMOTE_URL_2).username("change_me").build());
        String readme = helper.readFile(repo, "0f7aac949b32d7636f11918dc34ae8bb251fa610", "README.md");
        System.out.println(readme);
    }

}


================================================
File: src/test/java/org/cftoolsuite/cfapp/repository/R2dbcAppDetailRepositoryTest.java
================================================
package org.cftoolsuite.cfapp.repository;

import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.within;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertNotNull;
import static org.junit.jupiter.api.Assertions.assertNull;
import static org.junit.jupiter.api.Assertions.assertTrue;

import java.time.LocalDateTime;
import java.time.temporal.ChronoUnit;
import java.util.UUID;

import org.cftoolsuite.cfapp.ButlerTest;
import org.cftoolsuite.cfapp.domain.AppDetail;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.test.context.junit.jupiter.SpringExtension;

import reactor.test.StepVerifier;

@ButlerTest
@ExtendWith(SpringExtension.class)
public class R2dbcAppDetailRepositoryTest {

    private final R2dbcAppDetailRepository detailRepo;

    @Autowired
    public R2dbcAppDetailRepositoryTest(
            R2dbcAppDetailRepository detailRepo
            ) {
        this.detailRepo = detailRepo;
    }

    @BeforeEach
    public void setup() {
        StepVerifier.create(detailRepo.deleteAll()).verifyComplete();
    }

    @Test
    public void testSaveWasSuccessful() {
        LocalDateTime now = LocalDateTime.now();
        String appId = UUID.randomUUID().toString();
        AppDetail entity = AppDetail
                .builder()
                .appId(appId)
                .appName("foo")
                .organization("zoo-labs")
                .space("dev")
                .lastPushed(now)
                .stack("cflinuxfs3")
                .buildpack("java")
                .runningInstances(1)
                .totalInstances(1)
                .memoryUsed(1L)
                .diskUsed(1L)
                .requestedState("stopped")
                .build();
        StepVerifier.create(detailRepo.save(entity)
                .thenMany(detailRepo.findAll()))
        .assertNext(ad -> {
            assertNotNull(ad.getPk());
            assertEquals(appId, ad.getAppId());
            assertEquals("foo", ad.getAppName());
            assertEquals("zoo-labs", ad.getOrganization());
            assertEquals("dev", ad.getSpace());
            assertThat(now).isCloseTo(ad.getLastPushed(), within(1, ChronoUnit.SECONDS));
            assertNull(ad.getBuildpackVersion());
            assertEquals("java", ad.getBuildpack());
            assertEquals("cflinuxfs3", ad.getStack());
            assertEquals(1, ad.getRunningInstances());
            assertEquals(1, ad.getTotalInstances());
            assertEquals(1L, ad.getMemoryUsed());
            assertEquals(1L, ad.getDiskUsed());
            assertNotNull(ad.getUrls());
            assertTrue(ad.getUrls().isEmpty());
            assertNull(ad.getLastEvent());
            assertNull(ad.getLastEventActor());
            assertNull(ad.getLastEventTime());
            assertEquals("stopped", ad.getRequestedState());
            assertNull(ad.getBuildpackReleaseType());
            assertNull(ad.getBuildpackReleaseDate());
            assertNull(ad.getBuildpackLatestVersion());
            assertNull(ad.getBuildpackLatestUrl());
        }).verifyComplete();
    }
}


================================================
File: src/test/java/org/cftoolsuite/cfapp/repository/R2dbcAppMetricsRepositoryTest.java
================================================
package org.cftoolsuite.cfapp.repository;

import static org.junit.jupiter.api.Assertions.assertEquals;

import java.time.LocalDate;
import java.time.LocalDateTime;

import org.cftoolsuite.cfapp.ButlerTest;
import org.cftoolsuite.cfapp.domain.AppDetail;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.test.context.junit.jupiter.SpringExtension;

import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;
import reactor.test.StepVerifier;
import reactor.util.function.Tuple2;

@ButlerTest
@ExtendWith(SpringExtension.class)
public class R2dbcAppMetricsRepositoryTest {

    private final R2dbcAppMetricsRepository metricsRepo;
    private final R2dbcAppDetailRepository detailRepo;

    @Autowired
    public R2dbcAppMetricsRepositoryTest(
            R2dbcAppMetricsRepository metricsRepo,
            R2dbcAppDetailRepository detailRepo
            ) {
        this.metricsRepo = metricsRepo;
        this.detailRepo = detailRepo;
    }

    @BeforeEach
    public void setUp() {
        AppDetail entity = AppDetail
                .builder()
                .appId("foo-id")
                .appName("foo")
                .organization("zoo-labs")
                .space("dev")
                .lastPushed(LocalDateTime.now())
                .stack("cflinuxfs3")
                .buildpack("java_buildpack")
                .runningInstances(1)
                .totalInstances(1)
                .memoryUsed(1L)
                .diskUsed(1L)
                .requestedState("stopped")
                .build();
        StepVerifier.create(detailRepo.deleteAll().then(detailRepo.save(entity))).expectNext(entity).verifyComplete();
    }

    @Test
    public void testByBuildpack() {
        Flux<Tuple2<String, Long>> input = metricsRepo.byBuildpack();
        StepVerifier.create(input)
        .assertNext(m -> {
            assertEquals(1L, m.getT2());
            assertEquals("java_buildpack", m.getT1());
        }).verifyComplete();
    }

    @Test
    public void testByDockerImage() {
        Flux<Tuple2<String, Long>> input = metricsRepo.byDockerImage();
        StepVerifier.create(input)
        .assertNext(m -> {
            assertEquals(0L, m.getT2());
            assertEquals("--", m.getT1());
        }).verifyComplete();
    }

    @Test
    public void testByOrganization() {
        Flux<Tuple2<String, Long>> input = metricsRepo.byOrganization();
        StepVerifier.create(input)
        .assertNext(m -> {
            assertEquals(1L, m.getT2());
            assertEquals("zoo-labs", m.getT1());
        }).verifyComplete();
    }

    @Test
    public void testByStack() {
        Flux<Tuple2<String, Long>> input = metricsRepo.byStack();
        StepVerifier.create(input)
        .assertNext(m -> {
            assertEquals(1L, m.getT2());
            assertEquals("cflinuxfs3", m.getT1());
        }).verifyComplete();
    }

    @Test
    public void testCountByDateRange() {
        final LocalDate now = LocalDate.now();
        Mono<Long> input = metricsRepo.countByDateRange(now.minusDays(1), now);
        StepVerifier.create(input).assertNext(r -> assertEquals(1L, r)).verifyComplete();
    }

    @Test
    public void testCountStagnant() {
        final LocalDate now = LocalDate.now();
        Mono<Long> input = metricsRepo.countStagnant(now.minusYears(1));
        StepVerifier.create(input).assertNext(r -> assertEquals(0L, r)).verifyComplete();
    }

    @Test
    public void testTotalApplications() {
        Mono<Long> input = metricsRepo.totalApplications();
        StepVerifier.create(input).assertNext(r -> assertEquals(1L, r)).verifyComplete();
    }

    @Test
    public void testTotalRunningApplications() {
        Mono<Long> input = metricsRepo.totalRunningApplicationInstances();
        StepVerifier.create(input).assertNext(r -> assertEquals(0L, r)).verifyComplete();
    }

    @Test
    public void testTotalStoppedApplications() {
        Mono<Long> input = metricsRepo.totalStoppedApplicationInstances();
        StepVerifier.create(input).assertNext(r -> assertEquals(1L, r)).verifyComplete();
    }

    @Test
    public void testTotalVelocity() {
        Flux<Tuple2<String, Long>> input = metricsRepo.totalVelocity();
        StepVerifier.create(input).expectNextCount(9L).verifyComplete();
    }
}


================================================
File: src/test/java/org/cftoolsuite/cfapp/repository/R2dbcOrganizationRepositoryTest.java
================================================
package org.cftoolsuite.cfapp.repository;

import static org.junit.jupiter.api.Assertions.assertEquals;

import java.util.UUID;

import org.cftoolsuite.cfapp.ButlerTest;
import org.cftoolsuite.cfapp.domain.Organization;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.test.context.junit.jupiter.SpringExtension;

import reactor.test.StepVerifier;

@ButlerTest
@ExtendWith(SpringExtension.class)
public class R2dbcOrganizationRepositoryTest {

    private final R2dbcOrganizationRepository repo;

    @Autowired
    public R2dbcOrganizationRepositoryTest(
            R2dbcOrganizationRepository repo
            ) {
        this.repo = repo;
    }

    @BeforeEach
    public void setup() {
        StepVerifier.create(repo.deleteAll()).verifyComplete();
    }

    @Test
    public void testSaveWasSuccessful() {
        String id = UUID.randomUUID().toString();
        String name = "zoo-labs";
        Organization entity = new Organization(id, name);
        StepVerifier.create(repo.save(entity)
                .thenMany(repo.findAll()))
        .assertNext(o -> {
            assertEquals(id, o.getId());
            assertEquals(name, o.getName());
        }).verifyComplete();
    }
}


================================================
File: src/test/java/org/cftoolsuite/cfapp/repository/R2dbcServiceInstanceDetailRepositoryTest.java
================================================
package org.cftoolsuite.cfapp.repository;

import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.within;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertNotNull;
import static org.junit.jupiter.api.Assertions.assertTrue;

import java.time.LocalDateTime;
import java.time.temporal.ChronoUnit;
import java.util.UUID;

import org.cftoolsuite.cfapp.ButlerTest;
import org.cftoolsuite.cfapp.domain.ServiceInstanceDetail;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.test.context.junit.jupiter.SpringExtension;

import reactor.test.StepVerifier;

@ButlerTest
@ExtendWith(SpringExtension.class)
public class R2dbcServiceInstanceDetailRepositoryTest {

    private final R2dbcServiceInstanceDetailRepository detailRepo;

    @Autowired
    public R2dbcServiceInstanceDetailRepositoryTest(
            R2dbcServiceInstanceDetailRepository detailRepo
            ) {
        this.detailRepo = detailRepo;
    }

    @BeforeEach
    public void setup() {
        StepVerifier.create(detailRepo.deleteAll()).verifyComplete();
    }

    @Test
    public void testSaveWasSuccessful() {
        LocalDateTime now = LocalDateTime.now();
        String serviceInstanceId = UUID.randomUUID().toString();
        ServiceInstanceDetail entity = ServiceInstanceDetail
                .builder()
                .serviceInstanceId(serviceInstanceId)
                .name("foo")
                .organization("zoo-labs")
                .space("dev")
                .lastUpdated(now)
                .description("A MySQL database")
                .dashboardUrl("https://foobagger.com/dashboard/fc317c30-0a15-439c-8e46-e36eaa004420")
                .lastOperation("audit.service_instance.create")
                .type("mysql")
                .plan("db-small")
                .service("p.mysql")
                .requestedState("succeeded")
                .build();
        StepVerifier.create(detailRepo.save(entity)
                .thenMany(detailRepo.findAll()))
        .assertNext(sid -> {
            assertNotNull(sid.getPk());
            assertEquals(serviceInstanceId, sid.getServiceInstanceId());
            assertEquals("foo", sid.getName());
            assertEquals("zoo-labs", sid.getOrganization());
            assertEquals("dev", sid.getSpace());
            assertEquals("A MySQL database", sid.getDescription());
            assertEquals("https://foobagger.com/dashboard/fc317c30-0a15-439c-8e46-e36eaa004420", sid.getDashboardUrl());
            assertThat(now).isCloseTo(sid.getLastUpdated(), within(1, ChronoUnit.SECONDS));
            assertEquals("mysql", sid.getType());
            assertEquals("db-small", sid.getPlan());
            assertEquals("p.mysql", sid.getService());
            assertNotNull(sid.getApplications());
            assertTrue(sid.getApplications().isEmpty());
            assertEquals("succeeded", sid.getRequestedState());
        }).verifyComplete();
    }
}


================================================
File: src/test/java/org/cftoolsuite/cfapp/repository/R2dbcSpaceRepositoryTest.java
================================================
package org.cftoolsuite.cfapp.repository;

import static org.junit.jupiter.api.Assertions.assertEquals;

import java.util.UUID;

import org.cftoolsuite.cfapp.ButlerTest;
import org.cftoolsuite.cfapp.domain.Space;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.test.context.junit.jupiter.SpringExtension;

import reactor.test.StepVerifier;

@ButlerTest
@ExtendWith(SpringExtension.class)
public class R2dbcSpaceRepositoryTest {

    private final R2dbcSpaceRepository repo;

    @Autowired
    public R2dbcSpaceRepositoryTest(
            R2dbcSpaceRepository repo
            ) {
        this.repo = repo;
    }

    @BeforeEach
    public void setup() {
        StepVerifier.create(repo.deleteAll()).verifyComplete();
    }

    @Test
    public void testSaveWasSuccessful() {
        String organizationId = UUID.randomUUID().toString();
        String spaceId = UUID.randomUUID().toString();
        Space entity = Space
                .builder()
                .spaceId(spaceId)
                .spaceName("dev")
                .organizationId(organizationId)
                .organizationName("zoo-labs")
                .build();
        StepVerifier.create(repo.save(entity)
                .thenMany(repo.findAll()))
        .assertNext(s -> {
            assertEquals(spaceId, s.getSpaceId());
            assertEquals("dev", s.getSpaceName());
            assertEquals(organizationId, s.getOrganizationId());
            assertEquals("zoo-labs", s.getOrganizationName());
        }).verifyComplete();
    }
}


================================================
File: src/test/java/org/cftoolsuite/cfapp/repository/R2dbcSpaceUsersRepositoryTest.java
================================================
package org.cftoolsuite.cfapp.repository;

import static org.junit.jupiter.api.Assertions.assertEquals;

import java.util.List;

import org.assertj.core.api.Assertions;
import org.cftoolsuite.cfapp.ButlerTest;
import org.cftoolsuite.cfapp.domain.SpaceUsers;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.test.context.junit.jupiter.SpringExtension;

import reactor.test.StepVerifier;

@ButlerTest
@ExtendWith(SpringExtension.class)
public class R2dbcSpaceUsersRepositoryTest {

    private final R2dbcSpaceUsersRepository repo;

    @Autowired
    public R2dbcSpaceUsersRepositoryTest(
            R2dbcSpaceUsersRepository repo
            ) {
        this.repo = repo;
    }

    @BeforeEach
    public void setup() {
        StepVerifier.create(repo.deleteAll()).verifyComplete();
    }

    @Test
    public void testFindByOrgAndSpaceWasSuccessful() {
        SpaceUsers entity = SpaceUsers
                .builder()
                .organization("zoo-labs")
                .space("dev")
                .developers(List.of("devA", "devB", "devC"))
                .build();
        StepVerifier.create(repo.save(entity)
                .then(repo.findByOrganizationAndSpace("zoo-labs", "dev")))
        .assertNext(su -> {
            assertEquals("zoo-labs", su.getOrganization());
            assertEquals("dev", su.getSpace());
            Assertions.assertThat(su.getAuditors()).isEmpty();
            Assertions.assertThat(su.getDevelopers()).containsAll(List.of("deva", "devb", "devc"));
            Assertions.assertThat(su.getManagers()).isEmpty();
        }).verifyComplete();
    }

    @Test
    public void testSaveWasSuccessful() {
        SpaceUsers entity = SpaceUsers
                .builder()
                .organization("zoo-labs")
                .space("dev")
                .auditors(List.of("auditorA"))
                .developers(List.of("devA", "devB", "devC"))
                .managers(List.of("managerA"))
                .build();
        StepVerifier.create(repo.save(entity)
                .thenMany(repo.findAll()))
        .assertNext(su -> {
            assertEquals("zoo-labs", su.getOrganization());
            assertEquals("dev", su.getSpace());
            Assertions.assertThat(su.getAuditors()).containsAll(List.of("auditora"));
            Assertions.assertThat(su.getDevelopers()).containsAll(List.of("deva", "devb", "devc"));
            Assertions.assertThat(su.getManagers()).containsAll(List.of("managera"));
        }).verifyComplete();
    }
}


================================================
File: src/test/java/org/cftoolsuite/cfapp/repository/R2dbcTimeKeeperRepositoryTest.java
================================================
package org.cftoolsuite.cfapp.repository;

import static org.junit.jupiter.api.Assertions.assertEquals;

import java.time.LocalDateTime;

import org.cftoolsuite.cfapp.ButlerTest;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.test.context.junit.jupiter.SpringExtension;

import reactor.test.StepVerifier;

@ButlerTest
@ExtendWith(SpringExtension.class)
public class R2dbcTimeKeeperRepositoryTest {

    private final R2dbcTimeKeeperRepository repo;

    @Autowired
    public R2dbcTimeKeeperRepositoryTest(
            R2dbcTimeKeeperRepository repo
            ) {
        this.repo = repo;
    }

    @BeforeEach
    public void setup() {
        StepVerifier.create(repo.deleteOne()).verifyComplete();
    }

    @Test
    public void testSaveWasSuccessful() {
        LocalDateTime now  = LocalDateTime.now();
        StepVerifier.create(repo.save(now)
                .thenMany(repo.findOne()))
        .assertNext(one -> {
            assertEquals(now, one);
        }).verifyComplete();
    }
}


================================================
File: src/test/java/org/cftoolsuite/cfapp/service/ApplicationReporterTest.java
================================================
package org.cftoolsuite.cfapp.service;

import java.io.File;
import java.io.IOException;

import org.assertj.core.api.Assertions;
import org.cftoolsuite.cfapp.ButlerTest;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.test.context.junit.jupiter.SpringExtension;

import com.fasterxml.jackson.core.JsonParseException;
import com.fasterxml.jackson.databind.JsonMappingException;
import com.fasterxml.jackson.databind.ObjectMapper;


@ButlerTest
@ExtendWith(SpringExtension.class)
public class ApplicationReporterTest {

    private final ApplicationReporter reporter;
    private final ObjectMapper mapper;

    @Autowired
    public ApplicationReporterTest(
            ApplicationReporter reporter,
            ObjectMapper mapper
            ) {
        this.reporter = reporter;
        this.mapper = mapper;
    }

    @Test
    public void testReportGeneration() throws JsonParseException, JsonMappingException, IOException {
        File file = new File(System.getProperty("user.home") + "/app-reporting-config.json");
        if (file.exists()) {
            ReportRequestSpec spec = mapper.readValue(file, ReportRequestSpec.class);
            reporter.createReport(spec.getOutput(), spec.getInput());
            Assertions.assertThat(new File(spec.getOutput()).exists()).isTrue();
        }
    }

}


================================================
File: src/test/java/org/cftoolsuite/cfapp/service/ReportRequestSpec.java
================================================
package org.cftoolsuite.cfapp.service;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;

import lombok.Builder;
import lombok.Getter;


@Builder
@Getter
@JsonPropertyOrder({ "input", "output" })
public class ReportRequestSpec {

    @JsonProperty("input")
    private final ReportRequest[] input;
    @JsonProperty("output")
    private final String output;

    @JsonCreator
    public ReportRequestSpec(
            @JsonProperty("input") ReportRequest[] input,
            @JsonProperty("output") String output) {
        this.input = input;
        this.output = output;
    }
}


================================================
File: src/test/java/org/cftoolsuite/cfapp/service/ServiceInstanceReporterTest.java
================================================
package org.cftoolsuite.cfapp.service;

import java.io.File;
import java.io.IOException;

import org.assertj.core.api.Assertions;
import org.cftoolsuite.cfapp.ButlerTest;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.test.context.junit.jupiter.SpringExtension;

import com.fasterxml.jackson.core.JsonParseException;
import com.fasterxml.jackson.databind.JsonMappingException;
import com.fasterxml.jackson.databind.ObjectMapper;


@ButlerTest
@ExtendWith(SpringExtension.class)
public class ServiceInstanceReporterTest {

    private final ServiceInstanceReporter reporter;
    private final ObjectMapper mapper;

    @Autowired
    public ServiceInstanceReporterTest(
            ServiceInstanceReporter reporter,
            ObjectMapper mapper
            ) {
        this.reporter = reporter;
        this.mapper = mapper;
    }

    @Test
    public void testReportGeneration() throws JsonParseException, JsonMappingException, IOException {
        File file = new File(System.getProperty("user.home") + "/service-instance-reporting-config.json");
        if (file.exists()) {
            ReportRequestSpec spec = mapper.readValue(file, ReportRequestSpec.class);
            reporter.createReport(spec.getOutput(), spec.getInput());
            Assertions.assertThat(new File(spec.getOutput()).exists()).isTrue();
        }
    }

}


================================================
File: src/test/java/org/cftoolsuite/cfapp/service/SnapshotServiceTest.java
================================================
package org.cftoolsuite.cfapp.service;

import static org.junit.jupiter.api.Assertions.assertEquals;

import java.time.LocalDateTime;
import java.util.Arrays;

import org.cftoolsuite.cfapp.ButlerTest;
import org.cftoolsuite.cfapp.domain.AppDetail;
import org.cftoolsuite.cfapp.domain.ApplicationCounts;
import org.cftoolsuite.cfapp.domain.ServiceInstanceCounts;
import org.cftoolsuite.cfapp.domain.ServiceInstanceDetail;
import org.cftoolsuite.cfapp.domain.SpaceUsers;
import org.cftoolsuite.cfapp.domain.UserCounts;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.test.context.junit.jupiter.SpringExtension;

import reactor.core.publisher.Mono;
import reactor.test.StepVerifier;


@ButlerTest
@ExtendWith(SpringExtension.class)
public class SnapshotServiceTest {

    private final SnapshotService snapService;
    private final AppDetailService appService;
    private final ServiceInstanceDetailService siService;
    private final SpaceUsersService usersService;

    @Autowired
    public SnapshotServiceTest(
            SnapshotService snapService,
            AppDetailService appService,
            ServiceInstanceDetailService siService,
            SpaceUsersService usersService
            ) {
        this.snapService = snapService;
        this.appService = appService;
        this.siService = siService;
        this.usersService = usersService;
    }

    @BeforeEach
    public void setUp() {
        AppDetail ad = AppDetail
                .builder()
                .appId("foo-id")
                .appName("foo")
                .organization("zoo-labs")
                .space("dev")
                .lastPushed(LocalDateTime.now())
                .stack("cflinuxfs3")
                .buildpack("java_buildpack")
                .runningInstances(1)
                .totalInstances(1)
                .memoryUsed(1L)
                .diskUsed(1L)
                .requestedState("stopped")
                .build();
        ServiceInstanceDetail sid = ServiceInstanceDetail
                .builder()
                .serviceInstanceId("bar-id")
                .name("bar")
                .service("MySQL")
                .description("The big kahuna")
                .applications(Arrays.asList(new String[] { "foo" }))
                .lastUpdated(LocalDateTime.now())
                .lastOperation("created")
                .plan("large")
                .requestedState("created")
                .space("dev")
                .organization("zoo-labs")
                .type("managed_service_instance")
                .build();
        SpaceUsers su = SpaceUsers
                .builder()
                .auditors(Arrays.asList(new String[] { "marty@mcfly.org" }))
                .developers(Arrays.asList(new String[] { "bruce@wayneenterprises.com" }))
                .managers(Arrays.asList(new String[] { "nickfury@avengers.com", "NickFury@avengers.com" }))
                .organization("zoo-labs")
                .space("dev")
                .build();
        StepVerifier.create(appService.deleteAll().then(appService.save(ad))).expectNext(ad).verifyComplete();
        StepVerifier.create(siService.deleteAll().then(siService.save(sid))).expectNext(sid).verifyComplete();
        StepVerifier.create(usersService.deleteAll().then(usersService.save(su))).expectNext(su).verifyComplete();
    }

    @Test
    public void testAssembleApplicationCounts() {
        Mono<ApplicationCounts> input = snapService.assembleApplicationCounts();
        StepVerifier.create(input)
        .assertNext(ac -> {
            assertEquals(1, ac.getByBuildpack().get("java_buildpack"));
            assertEquals(1, ac.getByOrganization().get("zoo-labs"));
            assertEquals(1, ac.getByStack().get("cflinuxfs3"));
            assertEquals(0, ac.getByDockerImage().get("--"));
            assertEquals(1, ac.getByStatus().get("stopped"));
        }).verifyComplete();
    }

    @Test
    public void testAssembleServiceInstanceCounts() {
        Mono<ServiceInstanceCounts> input = snapService.assembleServiceInstanceCounts();
        StepVerifier.create(input)
        .assertNext(ac -> {
            assertEquals(1L, ac.getByOrganization().get("zoo-labs"));
            assertEquals(1L, ac.getByService().get("MySQL"));
            assertEquals(1L, ac.getByServiceAndPlan().get("MySQL/large"));
        }).verifyComplete();
    }

    @Test
    public void testAssembleUserCounts() {
        Mono<UserCounts> input = snapService.assembleUserCounts();
        StepVerifier
        .create(input)
        .assertNext(uc -> {
            assertEquals(3, uc.getTotalUserAccounts());
            assertEquals(0, uc.getTotalServiceAccounts());
        })
        .verifyComplete();
    }

}


================================================
File: src/test/java/org/cftoolsuite/cfapp/util/EmailTestUtil.java
================================================
package org.cftoolsuite.cfapp.util;

import java.io.IOException;
import java.io.InputStream;
import java.nio.charset.StandardCharsets;
import java.util.Base64;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.stream.Collectors;

import org.cftoolsuite.cfapp.domain.EmailAttachment;
import org.cftoolsuite.cfapp.domain.EmailAttachment.EmailAttachmentBuilder;
import org.cftoolsuite.cfapp.event.EmailNotificationEvent;

import com.fasterxml.jackson.databind.ObjectMapper;

public class EmailTestUtil {

    private static final ObjectMapper objectMapper = new ObjectMapper();

    public static EmailNotificationEvent readEmailTemplate(String filename) throws IOException {
        try (InputStream is = EmailTestUtil.class.getResourceAsStream("/email-templates/" + filename)) {
            Map<String, Object> data = objectMapper.readValue(is, Map.class);

            EmailNotificationEvent event = new EmailNotificationEvent("Something special");
            event.from((String) data.get("from"));
            event.recipients(Set.copyOf((List<String>) data.get("recipients")));
            event.carbonCopyRecipients(Set.copyOf((List<String>) data.get("carbonCopyRecipients")));
            event.blindCarbonCopyRecipients(Set.copyOf((List<String>) data.get("blindCarbonCopyRecipients")));
            event.subject((String) data.get("subject"));
            event.body((String) data.get("body"));
            event.domain((String) data.get("domain"));

            List<Map<String, Object>> attachmentsData = (List<Map<String, Object>>) data.get("attachments");
            List<EmailAttachment> attachments = attachmentsData.stream()
                .map(EmailTestUtil::createEmailAttachment)
                .collect(Collectors.toList());
            event.attachments(attachments);

            return event;
        }
    }

    private static EmailAttachment createEmailAttachment(Map<String, Object> data) {
        EmailAttachmentBuilder attachment = EmailAttachment.builder();
        attachment.filename((String) data.get("filename"));
        attachment.extension((String) data.get("extension"));
        attachment.mimeType((String) data.get("mimeType"));
        String base64EncodedContent = (String) data.get("content");
        byte[] decodedBytes = Base64.getDecoder().decode(base64EncodedContent);
        String content = new String(decodedBytes, StandardCharsets.UTF_8);
        attachment.content(content);
        return attachment.build();
    }
}


================================================
File: src/test/java/org/cftoolsuite/cfapp/util/JsonToCsvConverterTest.java
================================================
package org.cftoolsuite.cfapp.util;

import static org.junit.jupiter.api.Assertions.fail;

import org.cftoolsuite.cfapp.ButlerTest;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Disabled;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.test.context.junit.jupiter.SpringExtension;

import com.fasterxml.jackson.core.JsonProcessingException;

@ButlerTest
@ExtendWith(SpringExtension.class)
public class JsonToCsvConverterTest {

    @Autowired
    private JsonToCsvConverter converter;

    @Test
    public void testValidJson() {
        try {
            converter.convert("{ \"foo\": \"bar\" }");
        } catch (JsonProcessingException e) {
            fail();
        }
    }

    @Test
    public void testValidJsonArray() {
        try {
            converter.convert("[{ \"foo\": \"bar\" }]");
        } catch (JsonProcessingException e) {
            fail();
        }
    }

    @Test
    public void testStringIsEmpty() {
        Assertions.assertThrows(IllegalArgumentException.class, () -> {
            converter.convert("[]");
        });
    }

    @Test
    public void testInvalidInput() {
        Assertions.assertThrows(JsonProcessingException.class, () -> {
            converter.convert("[{ \"foo\": \"bar\" }");
        });
    }
}


================================================
File: .mvn/wrapper/MavenWrapperDownloader.java
================================================
/*
 * Copyright 2007-present the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import java.net.*;
import java.io.*;
import java.nio.channels.*;
import java.util.Properties;

public class MavenWrapperDownloader {

    private static final String WRAPPER_VERSION = "0.5.6";
    /**
     * Default URL to download the maven-wrapper.jar from, if no 'downloadUrl' is provided.
     */
    private static final String DEFAULT_DOWNLOAD_URL = "https://repo.maven.apache.org/maven2/io/takari/maven-wrapper/"
        + WRAPPER_VERSION + "/maven-wrapper-" + WRAPPER_VERSION + ".jar";

    /**
     * Path to the maven-wrapper.properties file, which might contain a downloadUrl property to
     * use instead of the default one.
     */
    private static final String MAVEN_WRAPPER_PROPERTIES_PATH =
            ".mvn/wrapper/maven-wrapper.properties";

    /**
     * Path where the maven-wrapper.jar will be saved to.
     */
    private static final String MAVEN_WRAPPER_JAR_PATH =
            ".mvn/wrapper/maven-wrapper.jar";

    /**
     * Name of the property which should be used to override the default download url for the wrapper.
     */
    private static final String PROPERTY_NAME_WRAPPER_URL = "wrapperUrl";

    public static void main(String args[]) {
        System.out.println("- Downloader started");
        File baseDirectory = new File(args[0]);
        System.out.println("- Using base directory: " + baseDirectory.getAbsolutePath());

        // If the maven-wrapper.properties exists, read it and check if it contains a custom
        // wrapperUrl parameter.
        File mavenWrapperPropertyFile = new File(baseDirectory, MAVEN_WRAPPER_PROPERTIES_PATH);
        String url = DEFAULT_DOWNLOAD_URL;
        if(mavenWrapperPropertyFile.exists()) {
            FileInputStream mavenWrapperPropertyFileInputStream = null;
            try {
                mavenWrapperPropertyFileInputStream = new FileInputStream(mavenWrapperPropertyFile);
                Properties mavenWrapperProperties = new Properties();
                mavenWrapperProperties.load(mavenWrapperPropertyFileInputStream);
                url = mavenWrapperProperties.getProperty(PROPERTY_NAME_WRAPPER_URL, url);
            } catch (IOException e) {
                System.out.println("- ERROR loading '" + MAVEN_WRAPPER_PROPERTIES_PATH + "'");
            } finally {
                try {
                    if(mavenWrapperPropertyFileInputStream != null) {
                        mavenWrapperPropertyFileInputStream.close();
                    }
                } catch (IOException e) {
                    // Ignore ...
                }
            }
        }
        System.out.println("- Downloading from: " + url);

        File outputFile = new File(baseDirectory.getAbsolutePath(), MAVEN_WRAPPER_JAR_PATH);
        if(!outputFile.getParentFile().exists()) {
            if(!outputFile.getParentFile().mkdirs()) {
                System.out.println(
                        "- ERROR creating output directory '" + outputFile.getParentFile().getAbsolutePath() + "'");
            }
        }
        System.out.println("- Downloading to: " + outputFile.getAbsolutePath());
        try {
            downloadFileFromURL(url, outputFile);
            System.out.println("Done");
            System.exit(0);
        } catch (Throwable e) {
            System.out.println("- Error downloading");
            e.printStackTrace();
            System.exit(1);
        }
    }

    private static void downloadFileFromURL(String urlString, File destination) throws Exception {
        if (System.getenv("MVNW_USERNAME") != null && System.getenv("MVNW_PASSWORD") != null) {
            String username = System.getenv("MVNW_USERNAME");
            char[] password = System.getenv("MVNW_PASSWORD").toCharArray();
            Authenticator.setDefault(new Authenticator() {
                @Override
                protected PasswordAuthentication getPasswordAuthentication() {
                    return new PasswordAuthentication(username, password);
                }
            });
        }
        URL website = new URL(urlString);
        ReadableByteChannel rbc;
        rbc = Channels.newChannel(website.openStream());
        FileOutputStream fos = new FileOutputStream(destination);
        fos.getChannel().transferFrom(rbc, 0, Long.MAX_VALUE);
        fos.close();
        rbc.close();
    }

}


